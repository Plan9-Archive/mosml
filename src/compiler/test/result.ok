Moscow ML version 2.00 (June 2000)
Enter `quit();' to quit.
- linking values
OK: a
OK: b
OK: c
OK: d
OK: e
OK: f
OK: g
OK: h
OK: i
OK: j
OK: k
OK: l
open A
OK:  a
OK:  b
OK:  c
OK:  d
OK:  e
OK:  f
OK:  g
OK:  h
OK:  i
OK:  j
OK:  k
OK:  l
local open A
OK: a
OK: b
OK: c
OK: d
OK: e
OK: f
OK: g
OK: h
OK: i
OK: j
OK: k
OK: llinking structures
OK: a
OK: b
OK: c
OK: d
OK: e
OK: f
OK: g
OK: h
OK: i
OK: j
OK: k
OK: l
open A
OK: a
OK: b
OK: c
OK: d
OK: e
OK: f
OK: g
OK: h
OK: i
OK: j
OK: k
OK: l
local open A
OK: a
OK: b
OK: c
OK: d
OK: e
OK: f
OK: g
OK: h
OK: i
OK: j
OK: k
OK: llinking functors
OK: a
OK: b
OK: c
OK: d
OK: e
OK: f
OK: g
OK: h
OK: i
OK: j
OK: k
OK: l
open A
OK: a
OK: b
OK: c
OK: d
OK: e
OK: f
OK: g
OK: h
OK: i
OK: j
OK: k
OK: l
local open A in
OK:  a
OK:  b
OK:  c
OK:  d
OK:  e
OK:  f
OK:  g
OK:  h
OK:  i
OK:  j
OK:  k
OK:  l
open A B X
value OK: X.a
value OK: B.b
value OK: X.x
value OK: B.y
structure OK: X.a
structure OK: B.b
structure OK: X.x
structure OK: B.y
functor OK: X.a
functor OK: B.b
functor OK: X.x
functor OK: B.y
local open A Y.B X
value OK: X.a
value OK: B.b
value OK: X.x
value OK: B.y
structure OK: X.a
structure OK: B.b
structure OK: X.x
structure OK: B.y
functor OK: X.a
functor OK: B.b
functor OK: X.x
functor OK: B.y
open B A X
value OK: X.a
value OK: b
value OK: X.x
value OK: B.y
structure OK: X.a
structure OK: b
structure OK: X.x
structure OK: B.y
functor OK: X.a
functor OK: b
functor OK: X.x
functor OK: B.y
local open B A X
value OK: X.a
value OK: b
value OK: X.x
value OK: B.y
structure OK: X.a
structure OK: b
structure OK: X.x
structure OK: B.y
functor OK: X.a
functor OK: b
functor OK: X.x
functor OK: B.y
open B X A
value OK: a
value OK: b
value OK: X.x
value OK: B.y
structure OK: a
structure OK: b
structure OK: X.x
structure OK: B.y
functor OK: a
functor OK: b
functor OK: X.x
functor OK: B.y
local open B X A
value OK: a
value OK: b
value OK: X.x
value OK: B.y
structure OK: a
structure OK: b
structure OK: X.x
structure OK: B.y
functor OK: a
functor OK: b
functor OK: X.x
functor OK: B.y
open A X B
value OK: B.a
value OK: B.b
value OK: X.x
value OK: B.y
structure OK: B.a
structure OK: B.b
structure OK: X.x
structure OK: B.y
functor OK: B.a
functor OK: B.b
functor OK: X.x
functor OK: B.y
local open A X B
value OK: B.a
value OK: B.b
value OK: X.x
value OK: B.y
structure OK: B.a
structure OK: B.b
structure OK: X.x
structure OK: B.y
functor OK: B.a
functor OK: B.b
functor OK: X.x
functor OK: B.y
open X A B
value OK: B.a
value OK: B.b
value OK: X.x
value OK: B.y
structure OK: B.a
structure OK: B.b
structure OK: X.x
structure OK: B.y
functor OK: B.a
functor OK: B.b
functor OK: X.x
functor OK: B.y
local open X A B
value OK: B.a
value OK: B.b
value OK: X.x
value OK: B.y
structure OK: B.a
structure OK: B.b
structure OK: X.x
structure OK: B.y
functor OK: B.a
functor OK: B.b
functor OK: X.x
functor OK: B.y
open X B A
value OK: a
value OK: b
value OK: X.x
value OK: B.y
structure OK: a
structure OK: b
structure OK: X.x
structure OK: B.y
functor OK: a
functor OK: b
functor OK: X.x
functor OK: B.y
local open X B A
value OK: a
value OK: b
value OK: X.x
value OK: B.y
structure OK: a
structure OK: b
structure OK: X.x
structure OK: B.y
functor OK: a
functor OK: b
functor OK: X.x
functor OK: B.y- 
- 
Moscow ML version 2.00 (June 2000)
Enter `quit();' to quit.
- > structure A :
  {structure a : {val v : string},
   structure b : {val v : string},
   structure c : {val v : string},
   structure d : {val v : string},
   structure e : {val v : string},
   structure f : {val v : string},
   structure g : {val v : string},
   structure h : {val v : string},
   structure i : {val v : string},
   structure j : {val v : string},
   structure k : {val v : string},
   structure l : {val v : string},
   functor a : {}->{val v : string},
   functor b : {}->{val v : string},
   functor c : {}->{val v : string},
   functor d : {}->{val v : string},
   functor e : {}->{val v : string},
   functor f : {}->{val v : string},
   functor g : {}->{val v : string},
   functor h : {}->{val v : string},
   functor i : {}->{val v : string},
   functor j : {}->{val v : string},
   functor k : {}->{val v : string},
   functor l : {}->{val v : string},
   val a : string,
   val b : string,
   val c : string,
   val d : string,
   val e : string,
   val f : string,
   val g : string,
   val h : string,
   val i : string,
   val j : string,
   val k : string,
   val l : string}
- > structure Y :
  {structure A1 :
     {structure a : {val v : string},
      structure b : {val v : string},
      structure c : {val v : string},
      structure d : {val v : string},
      structure e : {val v : string},
      structure f : {val v : string},
      structure g : {val v : string},
      structure h : {val v : string},
      structure i : {val v : string},
      structure j : {val v : string},
      structure k : {val v : string},
      structure l : {val v : string},
      functor a : {}->{val v : string},
      functor b : {}->{val v : string},
      functor c : {}->{val v : string},
      functor d : {}->{val v : string},
      functor e : {}->{val v : string},
      functor f : {}->{val v : string},
      functor g : {}->{val v : string},
      functor h : {}->{val v : string},
      functor i : {}->{val v : string},
      functor j : {}->{val v : string},
      functor k : {}->{val v : string},
      functor l : {}->{val v : string},
      val a : string,
      val b : string,
      val c : string,
      val d : string,
      val e : string,
      val f : string,
      val g : string,
      val h : string,
      val i : string,
      val j : string,
      val k : string,
      val l : string},
   structure B :
     {structure a : {val v : string},
      structure b : {val v : string},
      structure y : {val v : string},
      functor a : {}->{val v : string},
      functor b : {}->{val v : string},
      functor y : {}->{val v : string},
      val a : string,
      val b : string,
      val y : string},
   structure C1 :
     {structure a : {val v : string},
      structure b : {val v : string},
      structure c : {val v : string},
      structure d : {val v : string},
      structure e : {val v : string},
      structure f : {val v : string},
      structure g : {val v : string},
      structure h : {val v : string},
      structure i : {val v : string},
      structure j : {val v : string},
      structure k : {val v : string},
      structure l : {val v : string},
      functor a : {}->{val v : string},
      functor b : {}->{val v : string},
      functor c : {}->{val v : string},
      functor d : {}->{val v : string},
      functor e : {}->{val v : string},
      functor f : {}->{val v : string},
      functor g : {}->{val v : string},
      functor h : {}->{val v : string},
      functor i : {}->{val v : string},
      functor j : {}->{val v : string},
      functor k : {}->{val v : string},
      functor l : {}->{val v : string},
      val a : string,
      val b : string,
      val c : string,
      val d : string,
      val e : string,
      val f : string,
      val g : string,
      val h : string,
      val i : string,
      val j : string,
      val k : string,
      val l : string},
   structure D1 :
     {structure a : {val v : string},
      structure b : {val v : string},
      structure c : {val v : string},
      structure d : {val v : string},
      structure e : {val v : string},
      structure f : {val v : string},
      structure g : {val v : string},
      structure h : {val v : string},
      structure i : {val v : string},
      structure j : {val v : string},
      structure k : {val v : string},
      structure l : {val v : string},
      functor a : {}->{val v : string},
      functor b : {}->{val v : string},
      functor c : {}->{val v : string},
      functor d : {}->{val v : string},
      functor e : {}->{val v : string},
      functor f : {}->{val v : string},
      functor g : {}->{val v : string},
      functor h : {}->{val v : string},
      functor i : {}->{val v : string},
      functor j : {}->{val v : string},
      functor k : {}->{val v : string},
      functor l : {}->{val v : string},
      val a : string,
      val b : string,
      val c : string,
      val d : string,
      val e : string,
      val f : string,
      val g : string,
      val h : string,
      val i : string,
      val j : string,
      val k : string,
      val l : string},
   functor A1 : {}->{},
   val a : string}
- linking values- > val check = fn : string -> string -> unit
- 
OK: a- 
OK: b- 
OK: c- 
OK: d- 
OK: e- 
OK: f- 
OK: g- 
OK: h- 
OK: i- 
OK: j- 
OK: k- 
OK: l- 
open A
OK: a
OK: b
OK: c
OK: d
OK: e
OK: f
OK: g
OK: h
OK: i
OK: j
OK: k
OK: l- 
local open A
OK: a
OK: b
OK: c
OK: d
OK: e
OK: f
OK: g
OK: h
OK: i
OK: j
OK: k
OK: l- linking structures
OK: a
OK: b
OK: c
OK: d
OK: e
OK: f
OK: g
OK: h
OK: i
OK: j
OK: k
OK: l- 
open A
OK: a
OK: b
OK: c
OK: d
OK: e
OK: f
OK: g
OK: h
OK: i
OK: j
OK: k
OK: l- 
local open A
OK: a
OK: b
OK: c
OK: d
OK: e
OK: f
OK: g
OK: h
OK: i
OK: j
OK: k
OK: l- linking functors
OK: a
OK: b
OK: c
OK: d
OK: e
OK: f
OK: g
OK: h
OK: i
OK: j
OK: k
OK: l- 
open A
OK: a
OK: b
OK: c
OK: d
OK: e
OK: f
OK: g
OK: h
OK: i
OK: j
OK: k
OK: l- 
local open A in
OK: a
OK: b
OK: c
OK: d
OK: e
OK: f
OK: g
OK: h
OK: i
OK: j
OK: k
OK: l- > structure X :
  {structure a : {val v : string},
   structure x : {val v : string},
   functor a : {}->{val v : string},
   functor x : {}->{val v : string},
   val a : string,
   val x : string}
  val check = fn : string -> string -> string -> unit
- 
open A B X
value OK: X.a
value OK: B.b
value OK: X.x
value OK: B.y
structure OK: X.a
structure OK: B.b
structure OK: X.x
structure OK: B.y
functor OK: X.a
functor OK: B.b
functor OK: X.x
functor OK: B.y- 
local open A Y.B X
value OK: X.a
value OK: B.b
value OK: X.x
value OK: B.y
structure OK: X.a
structure OK: B.b
structure OK: X.x
structure OK: B.y
functor OK: X.a
functor OK: B.b
functor OK: X.x
functor OK: B.y- 
open B A X
value OK: X.a
value OK: b
value OK: X.x
value OK: B.y
structure OK: X.a
structure OK: b
structure OK: X.x
structure OK: B.y
functor OK: X.a
functor OK: b
functor OK: X.x
functor OK: B.y- 
local open B A X
value OK: X.a
value OK: b
value OK: X.x
value OK: B.y
structure OK: X.a
structure OK: b
structure OK: X.x
structure OK: B.y
functor OK: X.a
functor OK: b
functor OK: X.x
functor OK: B.y- 
open B X A
value OK: a
value OK: b
value OK: X.x
value OK: B.y
structure OK: a
structure OK: b
structure OK: X.x
structure OK: B.y
functor OK: a
functor OK: b
functor OK: X.x
functor OK: B.y
local open B X A
value OK: a
value OK: b
value OK: X.x
value OK: B.y
structure OK: a
structure OK: b
structure OK: X.x
structure OK: B.y
functor OK: a
functor OK: b
functor OK: X.x
functor OK: B.y- 
open A X B
value OK: B.a
value OK: B.b
value OK: X.x
value OK: B.y
structure OK: B.a
structure OK: B.b
structure OK: X.x
structure OK: B.y
functor OK: B.a
functor OK: B.b
functor OK: X.x
functor OK: B.y- 
local open A X B
value OK: B.a
value OK: B.b
value OK: X.x
value OK: B.y
structure OK: B.a
structure OK: B.b
structure OK: X.x
structure OK: B.y
functor OK: B.a
functor OK: B.b
functor OK: X.x
functor OK: B.y- 
open X A B
value OK: B.a
value OK: B.b
value OK: X.x
value OK: B.y
structure OK: B.a
structure OK: B.b
structure OK: X.x
structure OK: B.y
functor OK: B.a
functor OK: B.b
functor OK: X.x
functor OK: B.y- 
local open X A B
value OK: B.a
value OK: B.b
value OK: X.x
value OK: B.y
structure OK: B.a
structure OK: B.b
structure OK: X.x
structure OK: B.y
functor OK: B.a
functor OK: B.b
functor OK: X.x
functor OK: B.y- 
open X B A
value OK: a
value OK: b
value OK: X.x
value OK: B.y
structure OK: a
structure OK: b
structure OK: X.x
structure OK: B.y
functor OK: a
functor OK: b
functor OK: X.x
functor OK: B.y- 
local open X B A
value OK: a
value OK: b
value OK: X.x
value OK: B.y
structure OK: a
structure OK: b
structure OK: X.x
structure OK: B.y
functor OK: a
functor OK: b
functor OK: X.x
functor OK: B.y- 
- 
Moscow ML version 2.00 (June 2000)
Enter `quit();' to quit.
- > val it = () : unit
- > val it = () : unit
- > val it = () : unit
- > val it = () : unit
- > val it = () : unit
- linking values
OK: a
OK: b
OK: c
OK: d
OK: e
OK: f
OK: g
OK: h
OK: i
OK: j
OK: k
OK: l
open A
OK: a
OK: b
OK: c
OK: d
OK: e
OK: f
OK: g
OK: h
OK: i
OK: j
OK: k
OK: l
local open A
OK: a
OK: b
OK: c
OK: d
OK: e
OK: f
OK: g
OK: h
OK: i
OK: j
OK: k
OK: llinking structures
OK: a
OK: b
OK: c
OK: d
OK: e
OK: f
OK: g
OK: h
OK: i
OK: j
OK: k
OK: l
open A
OK: a
OK: b
OK: c
OK: d
OK: e
OK: f
OK: g
OK: h
OK: i
OK: j
OK: k
OK: l
local open A
OK: a
OK: b
OK: c
OK: d
OK: e
OK: f
OK: g
OK: h
OK: i
OK: j
OK: k
OK: llinking functors
OK: a
OK: b
OK: c
OK: d
OK: e
OK: f
OK: g
OK: h
OK: i
OK: j
OK: k
OK: l
open A
OK: a
OK: b
OK: c
OK: d
OK: e
OK: f
OK: g
OK: h
OK: i
OK: j
OK: k
OK: l
local open A in
OK: a
OK: b
OK: c
OK: d
OK: e
OK: f
OK: g
OK: h
OK: i
OK: j
OK: k
OK: l
 open A B X
value OK: X.a
value OK: B.b
value OK: X.x
value OK: B.y
structure OK: X.a
structure OK: B.b
structure OK: X.x
structure OK: B.y
functor OK: X.a
functor OK: B.b
functor OK: X.x
functor OK: B.y
local open A B X
value OK: X.a
value OK: B.b
value OK: X.x
value OK: B.y
structure OK: X.a
structure OK: B.b
structure OK: X.x
structure OK: B.y
functor OK: X.a
functor OK: B.b
functor OK: X.x
functor OK: B.y
open B A X
value OK: X.a
value OK: b
value OK: X.x
value OK: B.y
structure OK: X.a
structure OK: b
structure OK: X.x
structure OK: B.y
functor OK: X.a
functor OK: b
functor OK: X.x
functor OK: B.y
local open B A X
value OK: X.a
value OK: b
value OK: X.x
value OK: B.y
structure OK: X.a
structure OK: b
structure OK: X.x
structure OK: B.y
functor OK: X.a
functor OK: b
functor OK: X.x
functor OK: B.y
open B X A
value OK: a
value OK: b
value OK: X.x
value OK: B.y
structure OK: a
structure OK: b
structure OK: X.x
structure OK: B.y
functor OK: a
functor OK: b
functor OK: X.x
functor OK: B.y
local open B X A
value OK: a
value OK: b
value OK: X.x
value OK: B.y
structure OK: a
structure OK: b
structure OK: X.x
structure OK: B.y
functor OK: a
functor OK: b
functor OK: X.x
functor OK: B.y
open A X B
value OK: B.a
value OK: B.b
value OK: X.x
value OK: B.y
structure OK: B.a
structure OK: B.b
structure OK: X.x
structure OK: B.y
functor OK: B.a
functor OK: B.b
functor OK: X.x
functor OK: B.y
local open A X B
value OK: B.a
value OK: B.b
value OK: X.x
value OK: B.y
structure OK: B.a
structure OK: B.b
structure OK: X.x
structure OK: B.y
functor OK: B.a
functor OK: B.b
functor OK: X.x
functor OK: B.y
open X A B
value OK: B.a
value OK: B.b
value OK: X.x
value OK: B.y
structure OK: B.a
structure OK: B.b
structure OK: X.x
structure OK: B.y
functor OK: B.a
functor OK: B.b
functor OK: X.x
functor OK: B.y
local open X A B
value OK: B.a
value OK: B.b
value OK: X.x
value OK: B.y
structure OK: B.a
structure OK: B.b
structure OK: X.x
structure OK: B.y
functor OK: B.a
functor OK: B.b
functor OK: X.x
functor OK: B.y
open X B A
value OK: a
value OK: b
value OK: X.x
value OK: B.y
structure OK: a
structure OK: b
structure OK: X.x
structure OK: B.y
functor OK: a
functor OK: b
functor OK: X.x
functor OK: B.y
local open X B A
value OK: a
value OK: b
value OK: X.x
value OK: B.y
structure OK: a
structure OK: b
structure OK: X.x
structure OK: B.y
functor OK: a
functor OK: b
functor OK: X.x
functor OK: B.y
> val it = () : unit
- 
Moscow ML version 2.00 (June 2000)
Enter `quit();' to quit.
- > signature Array =
  /\array.
    {type 'a array = 'a array,
     val 'a init : 'a -> 'a array,
     val 'a sub : 'a array -> int -> 'a,
     val 'a update : 'a array -> int -> 'a -> 'a array}
- > structure ArrayZero :
  {type 'a array = 'a,
   val 'a init : 'a -> 'a,
   val ('a, 'b) sub : 'a -> 'b -> 'a,
   val ('a, 'b, 'c) update : 'a -> 'b -> 'c -> 'c}
- > functor ArraySucc :
  !array.
   {type 'a array = 'a array,
    val 'a init : 'a -> 'a array,
    val 'a sub : 'a array -> int -> 'a,
    val 'a update : 'a array -> int -> 'a -> 'a array}->
       {type 'a array = 'a array * 'a array,
        val 'a init : 'a -> 'a array * 'a array,
        val 'a sub : 'a array * 'a array -> int -> 'a,
        val 'a update :
          'a array * 'a array -> int -> 'a -> 'a array * 'a array}
- > val mkArray = fn :
  int ->
  [?array.
    {type 'a array = 'a array,
     val 'a init : 'a -> 'a array,
     val 'a sub : 'a array -> int -> 'a,
     val 'a update : 'a array -> int -> 'a -> 'a array}]
- > val two = fn : int -> int
- > val n = 10 : int
- > val max = 1024 : int
- > val 'a iter = fn : ('a -> int -> 'a) -> 'a -> int -> 'a
- > New type names: array
  structure A :
  {type 'a array = 'a array,
   val 'a init : 'a -> 'a array,
   val 'a sub : 'a array -> int -> 'a,
   val 'a update : 'a array -> int -> 'a -> 'a array}
- > val a = <array> : int array
- > val test1 = "OK" : string
- > val a = <array> : int array
- > val l =
    [1024, 1023, 1022, 1021, 1020, 1019, 1018, 1017, 1016, 1015, 1014, 1013,
     1012, 1011, 1010, 1009, 1008, 1007, 1006, 1005, 1004, 1003, 1002, 1001,
     1000, 999, 998, 997, 996, 995, 994, 993, 992, 991, 990, 989, 988, 987,
     986, 985, 984, 983, 982, 981, 980, 979, 978, 977, 976, 975, 974, 973, 972,
     971, 970, 969, 968, 967, 966, 965, 964, 963, 962, 961, 960, 959, 958, 957,
     956, 955, 954, 953, 952, 951, 950, 949, 948, 947, 946, 945, 944, 943, 942,
     941, 940, 939, 938, 937, 936, 935, 934, 933, 932, 931, 930, 929, 928, 927,
     926, 925, 924, 923, 922, 921, 920, 919, 918, 917, 916, 915, 914, 913, 912,
     911, 910, 909, 908, 907, 906, 905, 904, 903, 902, 901, 900, 899, 898, 897,
     896, 895, 894, 893, 892, 891, 890, 889, 888, 887, 886, 885, 884, 883, 882,
     881, 880, 879, 878, 877, 876, 875, 874, 873, 872, 871, 870, 869, 868, 867,
     866, 865, 864, 863, 862, 861, 860, 859, 858, 857, 856, 855, 854, 853, 852,
     851, 850, 849, 848, 847, 846, 845, 844, 843, 842, 841, 840, 839, 838, 837,
     836, 835, 834, 833, 832, 831, 830, 829, 828, 827, 826, 825, ...] :
  int list
  val test2 = "OK" : string
- 
Moscow ML version 2.00 (June 2000)
Enter `quit();' to quit.
- > signature Array =
  /\array.
    {type 'a array = 'a array,
     val 'a init : 'a -> 'a array,
     val 'a update : 'a array -> int -> 'a -> 'a array,
     val 'a sub : 'a array -> int -> 'a}
- > structure ArrayZero :
  {type 'a array = 'a,
   val 'a init : 'a -> 'a,
   val ('a, 'b) sub : 'a -> 'b -> 'a,
   val ('a, 'b, 'c) update : 'a -> 'b -> 'c -> 'c}
- > functor ArraySucc :
  !array.
   {type 'a array = 'a array,
    val 'a init : 'a -> 'a array,
    val 'a update : 'a array -> int -> 'a -> 'a array,
    val 'a sub : 'a array -> int -> 'a}->
       {type 'a array = 'a array * 'a array,
        val 'a init : 'a -> 'a array * 'a array,
        val 'a sub : 'a array * 'a array -> int -> 'a,
        val 'a update :
          'a array * 'a array -> int -> 'a -> 'a array * 'a array}
- > val mkArray = fn :
  int ->
  [?array.
    {type 'a array = 'a array,
     val 'a init : 'a -> 'a array,
     val 'a update : 'a array -> int -> 'a -> 'a array,
     val 'a sub : 'a array -> int -> 'a}]
- > val two = fn : int -> int
- > val n = 10 : int
- > val max = 1024 : int
- > val 'a iter = fn : ('a -> int -> 'a) -> 'a -> int -> 'a
- > New type names: array
  structure A :
  {type 'a array = 'a array,
   val 'a init : 'a -> 'a array,
   val 'a sub : 'a array -> int -> 'a,
   val 'a update : 'a array -> int -> 'a -> 'a array}
- > val a = <array> : int array
- > val test1 = "OK" : string
- > val a = <array> : int array
- > val l =
    [1024, 1023, 1022, 1021, 1020, 1019, 1018, 1017, 1016, 1015, 1014, 1013,
     1012, 1011, 1010, 1009, 1008, 1007, 1006, 1005, 1004, 1003, 1002, 1001,
     1000, 999, 998, 997, 996, 995, 994, 993, 992, 991, 990, 989, 988, 987,
     986, 985, 984, 983, 982, 981, 980, 979, 978, 977, 976, 975, 974, 973, 972,
     971, 970, 969, 968, 967, 966, 965, 964, 963, 962, 961, 960, 959, 958, 957,
     956, 955, 954, 953, 952, 951, 950, 949, 948, 947, 946, 945, 944, 943, 942,
     941, 940, 939, 938, 937, 936, 935, 934, 933, 932, 931, 930, 929, 928, 927,
     926, 925, 924, 923, 922, 921, 920, 919, 918, 917, 916, 915, 914, 913, 912,
     911, 910, 909, 908, 907, 906, 905, 904, 903, 902, 901, 900, 899, 898, 897,
     896, 895, 894, 893, 892, 891, 890, 889, 888, 887, 886, 885, 884, 883, 882,
     881, 880, 879, 878, 877, 876, 875, 874, 873, 872, 871, 870, 869, 868, 867,
     866, 865, 864, 863, 862, 861, 860, 859, 858, 857, 856, 855, 854, 853, 852,
     851, 850, 849, 848, 847, 846, 845, 844, 843, 842, 841, 840, 839, 838, 837,
     836, 835, 834, 833, 832, 831, 830, 829, 828, 827, 826, 825, ...] :
  int list
  val test2 = "OK" : string
- 
Moscow ML version 2.00 (June 2000)
Enter `quit();' to quit.
- > val divides = fn : int -> int -> bool
- > val succ = fn : int -> int
- > signature Stream =
  /\state.
    {type state = state,
     val start : state,
     val next : state -> state,
     val value : state -> int}
- > val sift = fn :
  [?state.
    {type state = state,
     val start : state,
     val next : state -> state,
     val value : state -> int}] ->
  [?state.
    {type state = state,
     val start : state,
     val next : state -> state,
     val value : state -> int}]
- > New type names: state
  structure Sieve :
  {type state = state,
   val next : state -> state,
   val start : state,
   val value : state -> int}
- > val nthstate = fn : int -> state
- > val nthprime = fn : int -> int
- > val primes = fn : int -> int list
- > structure StratSieve :
  {structure Start :
     {type state = int,
      val next : int -> int,
      val start : int,
      val 'a value : 'a -> 'a},
   functor Next :
     !state/1.
      {type state = state/1,
       val start : state/1,
       val next : state/1 -> state/1,
       val value : state/1 -> int}->
          {type state = state/1,
           val divisor : int,
           val filter : state/1 -> state/1,
           val next : state/1 -> state/1,
           val start : state/1,
           val value : state/1 -> int},
   functor Value :
     !state/1.
      {type state = state/1,
       val start : state/1,
       val next : state/1 -> state/1,
       val value : state/1 -> int}->{val value : int}}
- > val hundred_primes =
    [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67,
     71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149,
     151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229,
     233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313,
     317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409,
     419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499,
     503, 509, 521, 523, 541] : int list
- > val test = "OK" : string
- 
Moscow ML version 2.00 (June 2000)
Enter `quit();' to quit.
- > signature POLY =
  /\nat.
    {structure Nat :
       {type nat = nat,
        val z : nat,
        val s : nat -> nat,
        val 'a i : 'a -> ('a -> 'a) -> nat -> 'a},
     val eval : nat -> nat list -> nat}
- > functor MkPoly :
  !nat.
   {type nat = nat,
    val z : nat,
    val s : nat -> nat,
    val 'a i : 'a -> ('a -> 'a) -> nat -> 'a}->
       ({type nat = nat,
         val z : nat,
         val s : nat -> nat,
         val 'a i : 'a -> ('a -> 'a) -> nat -> 'a}->
            {val add : nat -> nat -> nat})->
           ({type nat = nat,
             val z : nat,
             val s : nat -> nat,
             val 'a i : 'a -> ('a -> 'a) -> nat -> 'a}->
                ({type nat = nat,
                  val z : nat,
                  val s : nat -> nat,
                  val 'a i : 'a -> ('a -> 'a) -> nat -> 'a}->
                     {val add : nat -> nat -> nat})->
                    {val mult : nat -> nat -> nat})->
               {structure Add : {val add : nat -> nat -> nat},
                structure Mult : {val mult : nat -> nat -> nat},
                structure Nat :
                  {type nat = nat,
                   val 'a i : 'a -> ('a -> 'a) -> nat -> 'a,
                   val s : nat -> nat,
                   val z : nat},
                val eval : nat -> nat list -> nat}
- > structure Nat :
  {type nat = int,
   val 'a i : 'a -> ('a -> 'a) -> int -> 'a,
   val s : int -> int,
   val z : int}
- > structure N :
  {type nat = int,
   val 'a i : 'a -> ('a -> 'a) -> int -> 'a,
   val s : int -> int,
   val z : int}
- > functor A :
  {type nat = int,
   val z : int,
   val s : int -> int,
   val 'a i : 'a -> ('a -> 'a) -> int -> 'a}->{val add : int -> int -> int}
- > functor M :
  {type nat = int,
   val z : int,
   val s : int -> int,
   val 'a i : 'a -> ('a -> 'a) -> int -> 'a}->
      ({type nat = int,
        val z : int,
        val s : int -> int,
        val 'a i : 'a -> ('a -> 'a) -> int -> 'a}->
           {val add : int -> int -> int})->
          {structure Add : {val add : int -> int -> int},
           val mult : int -> int -> int}
- > structure Poly :
  {structure Add : {val add : int -> int -> int},
   structure Mult : {val mult : int -> int -> int},
   structure Nat :
     {type nat = int,
      val 'a i : 'a -> ('a -> 'a) -> int -> 'a,
      val s : int -> int,
      val z : int},
   val eval : int -> int list -> int}
- > val test = 10 : int
- > functor A' :
  !nat.
   {type nat = nat,
    val s : nat -> nat,
    val i : nat -> (nat -> nat) -> nat -> nat}->
       {val add : nat -> nat -> nat, val sum : nat -> nat list -> nat}
- > structure Poly' :
  {structure Add : {val add : int -> int -> int},
   structure Mult : {val mult : int -> int -> int},
   structure Nat :
     {type nat = int,
      val 'a i : 'a -> ('a -> 'a) -> int -> 'a,
      val s : int -> int,
      val z : int},
   val eval : int -> int list -> int}
- > structure N :
  {type nat = int,
   val 'a i : 'a -> ('a -> 'a) -> int -> 'a,
   val s : int -> int,
   val z : int}
- > functor A : {}->{val add : int -> int -> int}
- > functor M :
  {}->
      ({type nat = int,
        val z : int,
        val s : int -> int,
        val 'a i : 'a -> ('a -> 'a) -> int -> 'a}->{})->
          {val mult : int -> int -> int}
- > structure IntPoly :
  {structure Add : {val add : int -> int -> int},
   structure Mult : {val mult : int -> int -> int},
   structure Nat :
     {type nat = int,
      val 'a i : 'a -> ('a -> 'a) -> int -> 'a,
      val s : int -> int,
      val z : int},
   val eval : int -> int list -> int}
- > val test = 10 : int
- > New type names: nat
  structure FastNat :
  {structure N :
     {type nat = nat,
      val 'a i : 'a -> ('a -> 'a) -> nat -> 'a,
      val s : nat -> nat,
      val z : nat},
   functor A : {}->{val add : nat -> nat -> nat},
   functor M :
     {}->
         ({type nat = nat,
           val z : nat,
           val s : nat -> nat,
           val 'a i : 'a -> ('a -> 'a) -> nat -> 'a}->{})->
             {val mult : nat -> nat -> nat}}
- > structure FastPoly :
  {structure Add : {val add : nat -> nat -> nat},
   structure Mult : {val mult : nat -> nat -> nat},
   structure Nat :
     {type nat = nat,
      val 'a i : 'a -> ('a -> 'a) -> nat -> 'a,
      val s : nat -> nat,
      val z : nat},
   val eval : nat -> nat list -> nat}
- 
Moscow ML version 2.00 (June 2000)
Enter `quit();' to quit.
- > functor F : {val a : unit}->{val b : unit}->{val c : unit}->{}
- > structure A : {val a : unit}
  structure B : {val b : unit}
  structure C : {val c : unit}
- > functor F : {val a : unit}->{val b : unit}->{val c : unit}->{}
- > functor FA : {val b : unit}->{val c : unit}->{}
- > functor FAB : {val c : unit}->{}
- > structure FABC : {}
- > functor H : ({}->{})->{}->{}
- > structure X : {}
- > signature A = /\a.{type a = a, val a : a}
- > signature B = /\b.{type b = b, val b : b}
- > signature C = /\c.{type c = c, val c : c}
- > functor X : !a.{type a = a, val a : a}->{type a = a, val a : a}
- > functor X : !a.{type a = a, val a : a}->?a/1.{type a = a/1, val a : a/1}
- > functor X : !a.{type a = a, val a : a}->?a/1.{type a = a/1, val a : a/1}
- > functor X :
  !a.
   {type a = a, val a : a}->
       !b.
        {type b = b, val b : b}->
            !c.{type c = c, val c : c}->{type a = a, val a : a}
- > functor X :
  !a.
   {type a = a, val a : a}->
       !b.
        {type b = b, val b : b}->
            !c.{type c = c, val c : c}->?a/1.{type a = a/1, val a : a/1}
- > functor X :
  !a.
   {type a = a, val a : a}->
       !b.
        {type b = b, val b : b}->
            !c.{type c = c, val c : c}->?a/1.{type a = a/1, val a : a/1}
- > signature F = !a.{type a = a, val a : a}->?b.{type b = b, val b : b}
- > signature G =
  (!a.{type a = a, val a : a}->?b.{type b = b, val b : b})->
      ?c.{type c = c, val c : c}
- > signature H =
  ((!a.{type a = a, val a : a}->?b.{type b = b, val b : b})->
       ?c.{type c = c, val c : c})->
      (!a.{type a = a, val a : a}->?b.{type b = b, val b : b})->
          ?c.{type c = c, val c : c}
- > structure A : {type a = int, val a : int}
- > structure B : {type b = int, val b : int}
- > structure C : {type c = int, val c : int}
- > functor F : !a.{type a = a, val a : a}->{type b = int, val b : int}
- > structure FA : {type b = int, val b : int}
- > functor G :
  (!a.{type a = a, val a : a}->?b.{type b = b, val b : b})->
      ?b.{type c = int, val c : int}
- > New type names: b
  structure GF : {type c = int, val c : int}
- > functor F : {}->{}
- > structure FA : {}
- > functor F : !a.{type a = a, val a : a}->{}
- > structure FA : {}
- > functor F : !a.{type a = a, val a : a}->{}
- > structure FA : {}
- > signature A = /\a.{type a = a, val a : a}
- > signature B = /\b/1.{type b = b/1, val b : b/1}
- > signature C = /\c.{type c = c, val c : c}
- > signature S =
  {functor F1 : !a.{type a = a, val a : a}->?b/1.{type b = b/1, val b : b/1},
   functor F2 : !a.{type a = a, val a : a}->?b/1.{type b = b/1, val b : b/1},
   functor F3 :
     !a.
      {type a = a, val a : a}->
          !b/1.{type b = b/1, val b : b/1}->?c.{type c = c, val c : c}}
- > signature F = !t.{type t = t}->{}
- > signature F = /\u.{}->{type u = u}
- > signature F = /\u.!t.{type t = t}->{type u = (u t)}
- > New type names: =u, =v
  functor F :
  !t w x.
   {type t = t, type w = w, type x = x}->
       {datatype u = ((u t w x),{con C : (u t w x)}),
        datatype v = ((v t w x),{con D : (v t w x)}),
        con C : (u t w x),
        con D : (v t w x)}
- > New type names: =u/1, =v/1
  functor F :
  !t w x.
   {type t = t, type w = w, type x = x}->
       {datatype 'a u = ('a (u/1 t w x),{con 'a C : 'a -> 'a (u/1 t w x)}),
        datatype 'a v = ('a (v/1 t w x),{con 'b D : 'b -> 'b (v/1 t w x)}),
        con 'a C : 'a -> 'a (u/1 t w x),
        con 'b D : 'b -> 'b (v/1 t w x)}
- 
Moscow ML version 2.00 (June 2000)
Enter `quit();' to quit.
- > functor ok :
  !u.(!t.{type t = t}->{type u = (u t)})->!t.{type t = t}->?u/1.{type u = u/1}
- ! Toplevel input:
!     op F:functor X:sig type t end -> sig type u end;
!     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
! Signature mismatch: the module does not match the signature ...
! Scope Violation: type constructor u of the range has specification:
!   type u = (u t)
! in the signature
! but is implemented by the declaration: 
!   type u = u/1
! in the module
! The declaration violates the specification because 
! the type constructor u/1 is a parameter 
! that is declared within the scope of u.
- > signature S = /\u.!w.{type w = w, type t = w}->{type u = (u w)}
- > functor F : !w.{type w = w, type t = w}->{type u = w * w}
- > functor G : !w.{type w = w, type t = w}->{type u = int * int}
- ! Toplevel input:
! functor Fail = (functor (X:sig type t  end) => struct datatype u = C of X.t * X.t end):S;
!                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
! Signature mismatch: the module does not match the signature ...
! Scope Violation: type constructor u of the range has specification:
!   type u = (u w)
! in the signature
! but is implemented by the declaration: 
!   datatype u = (u/1,{con C : w * w -> u/1})
! in the module
! The declaration violates the specification because 
! the type constructor u/1 is a parameter 
! that is declared within the scope of u.
- > New type names: u
  functor F :
  !t.
   {type t = t, val x : t}->
       {datatype u = ((u t),{con C : t -> (u t), con D : (u t) -> (u t)}),
        con C : t -> (u t),
        con D : (u t) -> (u t),
        val y : (u t),
        val z : (u t)}
- > structure X :
  {datatype u =
     ((u string),
      {con C : string -> (u string), con D : (u string) -> (u string)}),
   con C : string -> (u string),
   con D : (u string) -> (u string),
   val y : (u string),
   val z : (u string)}
- > datatype u =
  ((u string),{con C : string -> (u string), con D : (u string) -> (u string)})
  con C = fn : string -> (u string)
  con D = fn : (u string) -> (u string)
  val y = C "x" : (u string)
  val z = D(C "x") : (u string)
- > New type names: u/1
  functor F :
  !s t.
   {type s = s, val w : s, type t = t, val x : t}->
       {datatype u =
          ((u/1 s t),
           {con C : s * t -> (u/1 s t), con D : (u/1 s t) -> (u/1 s t)}),
        con C : s * t -> (u/1 s t),
        con D : (u/1 s t) -> (u/1 s t),
        val y : (u/1 s t),
        val z : (u/1 s t)}
- > structure X :
  {datatype u =
     ((u/1 bool string),
      {con C : bool * string -> (u/1 bool string),
       con D : (u/1 bool string) -> (u/1 bool string)}),
   con C : bool * string -> (u/1 bool string),
   con D : (u/1 bool string) -> (u/1 bool string),
   val y : (u/1 bool string),
   val z : (u/1 bool string)}
- > datatype u =
  ((u/1 bool string),
   {con C : bool * string -> (u/1 bool string),
    con D : (u/1 bool string) -> (u/1 bool string)})
  con C = fn : bool * string -> (u/1 bool string)
  con D = fn : (u/1 bool string) -> (u/1 bool string)
  val y = C(true, "x") : (u/1 bool string)
  val z = D(C(true, "x")) : (u/1 bool string)
- > New type names: u/2
  functor F :
  !s t.
   {type s = s, val w : s, type t = t, val x : t}->
       {datatype 'a u =
          ('a (u/2 s t),
           {con 'a C : s * t * 'a -> 'a (u/2 s t),
            con 'a D : ('a * 'a) (u/2 s t) -> 'a (u/2 s t)}),
        con 'a C : s * t * 'a -> 'a (u/2 s t),
        con 'a D : ('a * 'a) (u/2 s t) -> 'a (u/2 s t),
        val y : int (u/2 s t),
        val z : int (u/2 s t)}
- > structure X :
  {datatype 'a u =
     ('a (u/2 bool string),
      {con 'a C : bool * string * 'a -> 'a (u/2 bool string),
       con 'a D : ('a * 'a) (u/2 bool string) -> 'a (u/2 bool string)}),
   con 'a C : bool * string * 'a -> 'a (u/2 bool string),
   con 'a D : ('a * 'a) (u/2 bool string) -> 'a (u/2 bool string),
   val y : int (u/2 bool string),
   val z : int (u/2 bool string)}
- > datatype 'a u =
  ('a (u/2 bool string),
   {con 'a C : bool * string * 'a -> 'a (u/2 bool string),
    con 'a D : ('a * 'a) (u/2 bool string) -> 'a (u/2 bool string)})
  con 'a C = fn : bool * string * 'a -> 'a (u/2 bool string)
  con 'a D = fn : ('a * 'a) (u/2 bool string) -> 'a (u/2 bool string)
  val y = C(true, "x", 1) : int (u/2 bool string)
  val z = D(C(true, "x", (1, 1))) : int (u/2 bool string)
- > New type names: u/3
  functor A :
  !a b.
   {type a = a, type b = b, val a : a, val b : b}->
       {datatype u = ((u/3 a b),{con C : a * b -> (u/3 a b)}),
        con C : a * b -> (u/3 a b),
        val y : (u/3 a b)}
- > structure A :
  {datatype u = ((u/3 int bool),{con C : int * bool -> (u/3 int bool)}),
   con C : int * bool -> (u/3 int bool),
   val y : (u/3 int bool)}
- > datatype u = ((u/3 int bool),{con C : int * bool -> (u/3 int bool)})
  con C = fn : int * bool -> (u/3 int bool)
  val y = C(1, false) : (u/3 int bool)
- > New type names: u/4, v, =w, x
  functor A :
  !a b c.
   {type a = a,
    type b = b,
    type 'a c = 'a c,
    val 'a a : a,
    val 'a b : b,
    val 'a f : 'a -> 'a c}->
       {datatype u = ((u/4 a b c),{con C : a * b -> (u/4 a b c)}),
        datatype v =
          ((v a b c),
           {con B : (v a b c), con D : a * b * (v a b c) -> (v a b c)}),
        datatype 'a w =
          ('a (w a b c),
           {con 'a B : 'a -> 'a (w a b c),
            con 'a D : ('a * 'a) (w a b c) -> 'a (w a b c)}),
        datatype 'a x =
          ('a (x a b c),
           {con 'a B : 'a -> 'a (x a b c),
            con 'a D : 'a c (x a b c) -> 'a (x a b c)}),
        con 'a B : 'a -> 'a (x a b c),
        con C : a * b -> (u/4 a b c),
        con 'a D : 'a c (x a b c) -> 'a (x a b c),
        val u : (u/4 a b c),
        val v : (v a b c),
        val w : (a * b) (w a b c),
        val x : (a * b) (x a b c)}
- > structure A :
  {datatype u =
     ((u/4 int bool (/\'a.{l : 'a, r : 'a})),
      {con C : int * bool -> (u/4 int bool (/\'a.{l : 'a, r : 'a}))}),
   datatype v =
     ((v int bool (/\'a.{l : 'a, r : 'a})),
      {con B : (v int bool (/\'a.{l : 'a, r : 'a})),
       con D :
         int * bool * (v int bool (/\'a.{l : 'a, r : 'a})) ->
         (v int bool (/\'a.{l : 'a, r : 'a}))}),
   datatype 'a w =
     ('a (w int bool (/\'a'.{l : 'a', r : 'a'})),
      {con 'a B : 'a -> 'a (w int bool (/\'a'.{l : 'a', r : 'a'})),
       con 'a D :
         ('a * 'a) (w int bool (/\'a'.{l : 'a', r : 'a'})) ->
         'a (w int bool (/\'a'.{l : 'a', r : 'a'}))}),
   datatype 'a x =
     ('a (x int bool (/\'a'.{l : 'a', r : 'a'})),
      {con 'a B : 'a -> 'a (x int bool (/\'a'.{l : 'a', r : 'a'})),
       con 'a D :
         {l : 'a, r : 'a} (x int bool (/\'a'.{l : 'a', r : 'a'})) ->
         'a (x int bool (/\'a'.{l : 'a', r : 'a'}))}),
   con 'a B : 'a -> 'a (x int bool (/\'a'.{l : 'a', r : 'a'})),
   con C : int * bool -> (u/4 int bool (/\'a.{l : 'a, r : 'a})),
   con 'a D :
     {l : 'a, r : 'a} (x int bool (/\'a'.{l : 'a', r : 'a'})) ->
     'a (x int bool (/\'a'.{l : 'a', r : 'a'})),
   val u : (u/4 int bool (/\'a.{l : 'a, r : 'a})),
   val v : (v int bool (/\'a.{l : 'a, r : 'a})),
   val w : (int * bool) (w int bool (/\'a.{l : 'a, r : 'a})),
   val x : (int * bool) (x int bool (/\'a.{l : 'a, r : 'a}))}
- > datatype u =
  ((u/4 int bool (/\'a.{l : 'a, r : 'a})),
   {con C : int * bool -> (u/4 int bool (/\'a.{l : 'a, r : 'a}))})
  datatype v =
  ((v int bool (/\'a.{l : 'a, r : 'a})),
   {con B : (v int bool (/\'a.{l : 'a, r : 'a})),
    con D :
      int * bool * (v int bool (/\'a.{l : 'a, r : 'a})) ->
      (v int bool (/\'a.{l : 'a, r : 'a}))})
  datatype 'a w =
  ('a (w int bool (/\'a'.{l : 'a', r : 'a'})),
   {con 'a B : 'a -> 'a (w int bool (/\'a'.{l : 'a', r : 'a'})),
    con 'a D :
      ('a * 'a) (w int bool (/\'a'.{l : 'a', r : 'a'})) ->
      'a (w int bool (/\'a'.{l : 'a', r : 'a'}))})
  datatype 'a x =
  ('a (x int bool (/\'a'.{l : 'a', r : 'a'})),
   {con 'a B : 'a -> 'a (x int bool (/\'a'.{l : 'a', r : 'a'})),
    con 'a D :
      {l : 'a, r : 'a} (x int bool (/\'a'.{l : 'a', r : 'a'})) ->
      'a (x int bool (/\'a'.{l : 'a', r : 'a'}))})
  con 'a B = fn : 'a -> 'a (x int bool (/\'a'.{l : 'a', r : 'a'}))
  con C = fn : int * bool -> (u/4 int bool (/\'a.{l : 'a, r : 'a}))
  con 'a D = fn :
  {l : 'a, r : 'a} (x int bool (/\'a'.{l : 'a', r : 'a'})) ->
  'a (x int bool (/\'a'.{l : 'a', r : 'a'}))
  val u = C(1, false) : (u/4 int bool (/\'a.{l : 'a, r : 'a}))
  val v = D(1, false, D(1, false, D(1, false, B))) :
  (v int bool (/\'a.{l : 'a, r : 'a}))
  val w = D(B((1, false), (1, false))) :
  (int * bool) (w int bool (/\'a.{l : 'a, r : 'a}))
  val x = D(B{l = (1, false), r = (1, false)}) :
  (int * bool) (x int bool (/\'a.{l : 'a, r : 'a}))
- 
Moscow ML version 2.00 (June 2000)
Enter `quit();' to quit.
- > structure A :
  {structure B : {val b : bool, val c : string},
   type t = int,
   val a : int,
   val 'a d : 'a list,
   exn e : exn}
- > type u = int
- > type u = int
- > New type names: =v
  functor A : {}->{datatype v = (v,{con C : v}), con C : v}
- > type u = v
- > datatype u = (v,{con C : v})
  con C = C : v
- ! Toplevel input:
! type fail = X.t where X = struct type v = int datatype t = C of t end;
!             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
! Illegal projection: this projection causes an existential type constructor to escape its scope
- ! Toplevel input:
! type fail = X.v where X = struct datatype t = C of t type v = t end;
!             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
! Illegal projection: this projection causes an existential type constructor to escape its scope
- > functor G : {}->?=v/1.{datatype v = (v/1,{con C : v/1}), con C : v/1}
- ! Toplevel input:
! type fail = X.v where X = G();
!             ^^^^^^^^^^^^^^^^^
! Illegal projection: this projection causes an existential type constructor to escape its scope
- 
Moscow ML version 2.00 (June 2000)
Enter `quit();' to quit.
- > signature Collection =
  /\e t.{type e = e, type t = t, val empty : t, val add : e -> t -> t}
- > functor Set :
  !e.
   {type e = e, val ord : e * e -> bool}->
       ?t.{type e = e, type t = t, val add : e -> t -> t, val empty : t}
- > New type names: t
  structure IncSet :
  {type e = int, type t = t, val add : int -> t -> t, val empty : t}
- > New type names: t/1
  structure DecSet :
  {type e = int, type t = t/1, val add : int -> t/1 -> t/1, val empty : t/1}
- ! Toplevel input:
! val fail =  DecSet.add 2 (IncSet.add 1 IncSet.empty);
!                           ^^^^^^^^^^^^^^^^^^^^^^^^^
! Type clash: expression of type
!   t
! cannot have type
!   t/1
- > New type names: t/2
  functor List :
  !e.
   {type e = e}->
       {type e = e,
        type t = (t/2 e),
        val add : e -> (t/2 e) -> (t/2 e),
        val empty : (t/2 e)}
- > structure IncList :
  {type e = int,
   type t = (t/2 int),
   val add : int -> (t/2 int) -> (t/2 int),
   val empty : (t/2 int)}
- > structure DecList :
  {type e = int,
   type t = (t/2 int),
   val add : int -> (t/2 int) -> (t/2 int),
   val empty : (t/2 int)}
- > val ok = <t/2 int> : (t/2 int)
- > structure BoolList :
  {type e = bool,
   type t = (t/2 bool),
   val add : bool -> (t/2 bool) -> (t/2 bool),
   val empty : (t/2 bool)}
- ! Toplevel input:
! val fail = BoolList.add true (IncList.add 1 IncList.empty);
!                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^
! Type clash: expression of type
!   (t/2 int)
! cannot have type
!   (t/2 bool)
- 
Moscow ML version 2.00 (June 2000)
Enter `quit();' to quit.
- > structure X : {type 'a r = 'a ref}
- > type 'a r = 'a ref
- > structure Y : {type 'a r = 'a ref}
- > structure Z : {type 'a r = 'a ref}
  type 'a r = 'a ref
- 
Moscow ML version 2.00 (June 2000)
Enter `quit();' to quit.
- > New type names: =u
  structure A :
  {datatype u = ((u unit),{con C : unit ref -> (u unit)}),
   con C : unit ref -> (u unit)}
  functor F :
  !t.
   {type t = t}->
       {datatype u = ((u t),{con C : t ref -> (u t)}), con C : t ref -> (u t)}
- > val ok = fn : (u unit) * (u unit) -> bool
- > structure B :
  {datatype u =
     ((u (unit -> unit)),{con C : (unit -> unit) ref -> (u (unit -> unit))}),
   con C : (unit -> unit) ref -> (u (unit -> unit))}
- > val ok = fn : (u (unit -> unit)) * (u (unit -> unit)) -> bool
- > New type names: u/1
  functor G :
  !t.
   {type t = t}->
       {datatype u = ((u/1 t),{con C : t -> (u/1 t)}), con C : t -> (u/1 t)}
- > structure C :
  {datatype u = ((u/1 unit),{con C : unit -> (u/1 unit)}),
   con C : unit -> (u/1 unit)}
- ! Toplevel input:
! val fail = op = : C.u * C.u -> bool;
!            ^^^^
! Type clash: expression of type
!   ''a * ''a -> bool
! cannot have type
!   (u/1 unit) * (u/1 unit) -> bool
- > structure D :
  {datatype u =
     ((u/1 (unit -> unit)),{con C : (unit -> unit) -> (u/1 (unit -> unit))}),
   con C : (unit -> unit) -> (u/1 (unit -> unit))}
- ! Toplevel input:
! val fail = op = : D.u * D.u -> bool;
!            ^^^^
! Type clash: expression of type
!   ''a * ''a -> bool
! cannot have type
!   (u/1 (unit -> unit)) * (u/1 (unit -> unit)) -> bool
- > New type names: =u/2
  functor H :
  !=t.
   {type t = t}->
       {datatype u = ((u/2 t),{con C : t -> (u/2 t)}), con C : t -> (u/2 t)}
- > structure E :
  {datatype u = ((u/2 unit),{con C : unit -> (u/2 unit)}),
   con C : unit -> (u/2 unit)}
- > val ok = fn : (u/2 unit) * (u/2 unit) -> bool
- > New type names: =u/3
  functor I :
  !s =t.
   {type s = s, type t = t}->
       {datatype u = ((u/3 s t),{con C : t -> (u/3 s t)}),
        con C : t -> (u/3 s t)}
- > structure F :
  {datatype u = ((u/3 unit unit),{con C : unit -> (u/3 unit unit)}),
   con C : unit -> (u/3 unit unit)}
- > val ok = fn : (u/3 unit unit) * (u/3 unit unit) -> bool
- > structure G :
  {datatype u =
     ((u/3 (unit -> unit) unit),{con C : unit -> (u/3 (unit -> unit) unit)}),
   con C : unit -> (u/3 (unit -> unit) unit)}
- > val ok = fn : (u/3 (unit -> unit) unit) * (u/3 (unit -> unit) unit) -> bool
- > functor ok :
  !=u/4.
   (!t.{type t = t}->{type u = (u/4 t)})->!t.{type t = t}->{type u = (u/4 t)}
- > functor ok :
  !=u/4.
   (!t.{type t = t}->{type u = (u/4 t)})->!=t.{type t = t}->{type u = (u/4 t)}
- > functor ok :
  !=u/4.
   (!t.{type t = t}->{type u = (u/4 t)})->!t.{type t = t}->{type u = (u/4 t)}
- > functor ok :
  !=u/4.
   (!t.{type t = t}->{type u = (u/4 t)})->!=t.{type t = t}->{type u = (u/4 t)}
- ! Toplevel input:
!     op F:functor X:sig type t end -> sig type u end;
!     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
! Signature mismatch: the module does not match the signature ...
! Equality type mismatch: type constructor t of the domain
! is specified as admitting equality in the module
!   type t = t
! but its declaration does not admit equality in the signature
!   type t = t/1
- ! Toplevel input:
!     op F:functor X:sig eqtype t end -> sig eqtype u end;
!     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
! Signature mismatch: the module does not match the signature ...
! Equality type mismatch: type constructor u of the range
! is specified as admitting equality in the signature
!   type u = (u/4 t)
! but its declaration does not admit equality in the module
!   type u = (u/5 t)
- 
Moscow ML version 2.00 (June 2000)
Enter `quit();' to quit.
- > val 'a ok = fn : 'a -> 'a
- > val ('a, 'b) ok = fn : ('a -> 'b) -> 'a -> 'b
- ! Toplevel input:
! type fail = 'a -> 'b;
! ^^^^^^^^^^^^^^^^^^^^
! Unguarded type variables at the top-level
- > val 'a ok = fn : 'a -> 'a
- > val 'b ok = fn : 'b -> int
- ! Toplevel input:
! val fail = fn x:'b => let datatype d = C type t = 'b * d in (x,C): t end;
!                                                                ^
! Type clash: expression of type
!   d
! cannot have type
!   'a
! because of a scope violation:
! the type constructor d is a parameter 
! that is declared within the scope of 'a
- > val 'a ok = fn : 'a -> 'a
- > New type names: =t
  structure Ok : {datatype t = (t,{con c : int -> t}), con c : int -> t}
- > New type names: t/1, t/2
  structure Ok' :
  {datatype t = (t/1,{con c : (unit -> unit) -> t/1}),
   con c : (unit -> unit) -> t/1}
  structure Ok :
  {datatype t = (t/2,{con c : (bool -> bool) -> t/2}),
   con c : (bool -> bool) -> t/2}
- > val it = () : unit
- > New type names: t/3, t/4
  structure Ok' :
  {datatype t = (t/3,{con c : (unit -> unit) -> t/3}),
   con c : (unit -> unit) -> t/3}
  structure Ok :
  {datatype t = (t/4,{con c : (bool -> bool) -> t/4}),
   con c : (bool -> bool) -> t/4}
- > val it = () : unit
- > val 'a ok = fn : 'a -> 'a
- > val 'a ok = fn : 'a -> [{val x : 'a}]
- > signature Fail = {val 'a x : 'a -> 'a}
- > val 'a ok = fn : 'a -> [{val x : 'a}]
- ! Toplevel input:
!     in [structure struct val x = x end as S ]
!        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
! Signature mismatch: the structure does not match the signature ...
! Scheme mismatch: value identifier x
! is specified with type scheme 
!   val 'a' x : 'a'
! in the signature
! but its declaration has the unrelated type scheme 
!   val x : 'a
! in the structure
! The declared type scheme should be at least as general as the specified type scheme
- ! Toplevel input:
!     in [structure struct val x = x end as S ]
!        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
! Signature mismatch: the structure does not match the signature ...
! Scheme mismatch: value identifier x
! is specified with type scheme 
!   val 'b x : 'b
! in the signature
! but its declaration has the unrelated type scheme 
!   val x : 'a
! in the structure
! The declared type scheme should be at least as general as the specified type scheme
- > val 'a ok = fn : 'a -> [{val x : 'a -> 'a}]
- > val 'a ok = fn : 'a -> [{val 'a' x : 'a' -> 'a'}]
- > val 'a ok = fn : 'a -> [{val 'b x : 'b -> 'b}]
- ! Toplevel input:
! ....(functor(X:sig type t end)=>struct datatype u = C of X.t end)
!     :functor X:sig type t end -> sig type u end.
! Signature mismatch: the module does not match the signature ...
! Scope Violation: type constructor u of the range has specification:
!   type u = (u t/5)
! in the signature
! but is implemented by the declaration: 
!   datatype u = (u/1,{con C : t/5 -> u/1})
! in the module
! The declaration violates the specification because 
! the type constructor u/1 is a parameter 
! that is declared within the scope of u.
- 
Moscow ML version 2.00 (June 2000)
Enter `quit();' to quit.
- > New type names: =v, =u, =t
  val matchsuc = "OK" : string
- 
Moscow ML version 2.00 (June 2000)
Enter `quit();' to quit.
- ! Toplevel input:
! structure X = struct open General end: sig val + : (int * int) -> int end;
!               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
! Signature mismatch: the module does not match the signature ...
! Scheme mismatch: value identifier +
! is specified with type scheme 
!   val + : int * int -> int
! in the signature
! but its declaration has the unrelated type scheme 
!   val + : num * num -> num 
! in the module
! The declared type scheme should be at least as general as the specified type scheme
- ! Toplevel input:
! structure X = struct val x = fn 1 => Div end : sig exception x of int end;
!               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
! Signature mismatch: the module does not match the signature ...
! Status mismatch: identifier x
! is specified as an exception in the signature
!   exn x : int -> exn
! but declared as an ordinary value in the module
!   val x : int -> exn
- ! Toplevel input:
! structure X = struct val x = fn y => y end : sig prim_val  x : 'a ->'a = 1 "identity" end;
!               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
! Signature mismatch: the module does not match the signature ...
! Status mismatch: identifier x
! is specified as a primitive in the signature
!   val 'a x : 'a -> 'a
! but declared as an ordinary value in the module
!   val 'a x : 'a -> 'a
- > exn e = e : exn
- > structure X : {exn e : exn}
- ! Toplevel input:
! structure X = struct val x = fn 1 => 1 end : sig val x : 'a -> 'a end;
!               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
! Signature mismatch: the module does not match the signature ...
! Scheme mismatch: value identifier x
! is specified with type scheme 
!   val 'a x : 'a -> 'a
! in the signature
! but its declaration has the unrelated type scheme 
!   val x : int -> int
! in the module
! The declared type scheme should be at least as general as the specified type scheme
- ! Toplevel input:
! structure X = struct val x = fn 1 => Div end : sig exception x of int end;
!               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
! Signature mismatch: the module does not match the signature ...
! Status mismatch: identifier x
! is specified as an exception in the signature
!   exn x : int -> exn
! but declared as an ordinary value in the module
!   val x : int -> exn
- ! Toplevel input:
! structure X = struct val x = fn y => y end : sig prim_val  x : 'a ->'a = 1 "identity" end;
!               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
! Signature mismatch: the module does not match the signature ...
! Status mismatch: identifier x
! is specified as a primitive in the signature
!   val 'a x : 'a -> 'a
! but declared as an ordinary value in the module
!   val 'a x : 'a -> 'a
- ! Toplevel input:
! structure X = struct datatype t = C of int end : sig datatype t = C of bool end;
!               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
! Signature mismatch: the module does not match the signature ...
! Scheme mismatch: value identifier C
! is specified with type scheme 
!   con C : bool -> t
! in the signature
! but its declaration has the unrelated type scheme 
!   con C : int -> t
! in the module
! The declared type scheme should be at least as general as the specified type scheme
- ! Toplevel input:
! signature S = sig type t end where type 'a t = int;
!                                    ^^^^^^^^^^^^^^^
! Illegal where constraint: the type constructor t
! cannot be constrained in this way because ...
! Arity mismatch: type constructor t
! is specified with arity 0 in the signature
!   type t = t
! but declared with arity 1 in the constraint
!   type 'a t = int
! The arities should agree
- ! Toplevel input:
! signature S = sig structure X : sig type t end end where type 'a X.t = int;
!                                                          ^^^^^^^^^^^^^^^^^
! Illegal where constraint: the type constructor X.t
! cannot be constrained in this way because ...
! Arity mismatch: type constructor X.t
! is specified with arity 0 in the signature
!   type t = t
! but declared with arity 1 in the constraint
!   type 'a t = int
! The arities should agree
- ! Toplevel input:
! signature S = sig structure Y : sig structure X : sig type t end end end where type 'a Y.X.t = int;
!                                                                                ^^^^^^^^^^^^^^^^^^^
! Illegal where constraint: the type constructor Y.X.t
! cannot be constrained in this way because ...
! Arity mismatch: type constructor Y.X.t
! is specified with arity 0 in the signature
!   type t = t
! but declared with arity 1 in the constraint
!   type 'a t = int
! The arities should agree
- ! Toplevel input:
! structure X = struct end:functor(X:sig end)->sig end;
!               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
! Signature mismatch: the module does not match the signature ...
! Module mismatch: The signature specifies a functor
! but the module is a structure
- ! Toplevel input:
! functor X = (functor(X:sig end)=>struct end) : sig end;
!             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
! Signature mismatch: the module does not match the signature ...
! Module mismatch: The signature specifies a structure
! but the module is a functor
- ! Toplevel input:
! functor X = (functor(X:sig end)=>struct end): functor(X:sig end)->functor(X:sig end)->sig end;
!             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
! Signature mismatch: the module does not match the signature ...
! Module mismatch: the range
! is specified as a functor in the signature
! but declared as a structure in the module
- ! Toplevel input:
! functor X = (functor(X:sig end)=>functor(X:sig end)=>struct end): functor(X:sig end)->sig end;
!             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
! Signature mismatch: the module does not match the signature ...
! Module mismatch: the range
! is specified as a structure in the signature
! but declared as a functor in the module
- ! Toplevel input:
! functor X = (functor(X:functor(X:sig end)->sig end)=>struct end): functor(X:sig end)->sig end;
!             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
! Signature mismatch: the module does not match the signature ...
! Module mismatch: the domain
! is specified as a functor in the module
! but declared as a structure in the signature
- ! Toplevel input:
! functor X = (functor(X:sig end)=>struct end): functor(F:functor(X:sig end)->sig end)->sig end;
!             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
! Signature mismatch: the module does not match the signature ...
! Module mismatch: the domain
! is specified as a structure in the module
! but declared as a functor in the signature
- > signature G = {type t = unit}
- > signature L = {}
- ! Toplevel input:
!   L:G;
!   ^^^
! Signature mismatch: the module does not match the signature ...
! Missing declaration: type constructor t
! is specified in the signature as 
!   type t = unit
! but not declared in the module
- ! Toplevel input:
!   LL:functor(L:L)->G;
!   ^^^^^^^^^^^^^^^^^^
! Signature mismatch: the module does not match the signature ...
! Missing declaration: type constructor t of the range
! is specified in the signature as 
!   type t = unit
! but not declared in the module
- ! Toplevel input:
!   GL:functor(L:L)->L;
!   ^^^^^^^^^^^^^^^^^^
! Signature mismatch: the module does not match the signature ...
! Missing declaration: type constructor t of the domain
! is specified in the module as 
!   type t = unit
! but not declared in the signature
- ! Toplevel input:
!   YL:sig structure Y: G end;
!   ^^^^^^^^^^^^^^^^^^^^^^^^^
! Signature mismatch: the module does not match the signature ...
! Missing declaration: type constructor Y.t
! is specified in the signature as 
!   type t = unit
! but not declared in the module
- ! Toplevel input:
!   L_YL:functor(L:L)->sig structure Y: G end;
!   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
! Signature mismatch: the module does not match the signature ...
! Missing declaration: type constructor Y.t of the range
! is specified in the signature as 
!   type t = unit
! but not declared in the module
- ! Toplevel input:
!   YG_L:functor(YL:sig structure Y: L end)->L;
!   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
! Signature mismatch: the module does not match the signature ...
! Missing declaration: type constructor Y.t of the domain
! is specified in the module as 
!   type t = unit
! but not declared in the signature
- ! Toplevel input:
!   L_YG_L:functor(L:L)->functor(YL:sig structure Y:L end)->L;
!   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
! Signature mismatch: the module does not match the signature ...
! Missing declaration: type constructor Y.t of the domain of the range
! is specified in the module as 
!   type t = unit
! but not declared in the signature
- ! Toplevel input:
!   FLYGL:sig functor F: functor(L:L)->functor(YL:sig structure Y:L end)->L end;
!   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
! Signature mismatch: the module does not match the signature ...
! Missing declaration: type constructor Y.t of the domain of the range of F
! is specified in the module as 
!   type t = unit
! but not declared in the signature
- > signature G = {val x : unit}
- > signature L = {}
- ! Toplevel input:
!   L:G;
!   ^^^
! Signature mismatch: the module does not match the signature ...
! Missing declaration: value x
! is specified in the signature as 
!   val x : unit
! but not declared in the module
- ! Toplevel input:
!   LL:functor(L:L)->G;
!   ^^^^^^^^^^^^^^^^^^
! Signature mismatch: the module does not match the signature ...
! Missing declaration: value x of the range
! is specified in the signature as 
!   val x : unit
! but not declared in the module
- ! Toplevel input:
!   GL:functor(L:L)->L;
!   ^^^^^^^^^^^^^^^^^^
! Signature mismatch: the module does not match the signature ...
! Missing declaration: value x of the domain
! is specified in the module as 
!   val x : unit
! but not declared in the signature
- ! Toplevel input:
!   YL:sig structure Y: G end;
!   ^^^^^^^^^^^^^^^^^^^^^^^^^
! Signature mismatch: the module does not match the signature ...
! Missing declaration: value Y.x
! is specified in the signature as 
!   val x : unit
! but not declared in the module
- ! Toplevel input:
!   L_YL:functor(L:L)->sig structure Y: G end;
!   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
! Signature mismatch: the module does not match the signature ...
! Missing declaration: value Y.x of the range
! is specified in the signature as 
!   val x : unit
! but not declared in the module
- ! Toplevel input:
!   YG_L:functor(YL:sig structure Y: L end)->L;
!   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
! Signature mismatch: the module does not match the signature ...
! Missing declaration: value Y.x of the domain
! is specified in the module as 
!   val x : unit
! but not declared in the signature
- ! Toplevel input:
!   L_YG_L:functor(L:L)->functor(YL:sig structure Y:L end)->L;
!   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
! Signature mismatch: the module does not match the signature ...
! Missing declaration: value Y.x of the domain of the range
! is specified in the module as 
!   val x : unit
! but not declared in the signature
- ! Toplevel input:
!   FLYGL:sig functor F: functor(L:L)->functor(YL:sig structure Y:L end)->L end;
!   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
! Signature mismatch: the module does not match the signature ...
! Missing declaration: value Y.x of the domain of the range of F
! is specified in the module as 
!   val x : unit
! but not declared in the signature
- > signature G = {structure X : {}}
- > signature L = {}
- ! Toplevel input:
!   L:G;
!   ^^^
! Signature mismatch: the module does not match the signature ...
! Missing declaration: structure X
! is specified in the signature as 
!   structure X : {}
! but not declared in the module
- ! Toplevel input:
!   LL:functor(L:L)->G;
!   ^^^^^^^^^^^^^^^^^^
! Signature mismatch: the module does not match the signature ...
! Missing declaration: structure X of the range
! is specified in the signature as 
!   structure X : {}
! but not declared in the module
- ! Toplevel input:
!   GL:functor(L:L)->L;
!   ^^^^^^^^^^^^^^^^^^
! Signature mismatch: the module does not match the signature ...
! Missing declaration: structure X of the domain
! is specified in the module as 
!   structure X : {}
! but not declared in the signature
- ! Toplevel input:
!   YL:sig structure Y: G end;
!   ^^^^^^^^^^^^^^^^^^^^^^^^^
! Signature mismatch: the module does not match the signature ...
! Missing declaration: structure Y.X
! is specified in the signature as 
!   structure X : {}
! but not declared in the module
- ! Toplevel input:
!   L_YL:functor(L:L)->sig structure Y: G end;
!   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
! Signature mismatch: the module does not match the signature ...
! Missing declaration: structure Y.X of the range
! is specified in the signature as 
!   structure X : {}
! but not declared in the module
- ! Toplevel input:
!   YG_L:functor(YL:sig structure Y: L end)->L;
!   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
! Signature mismatch: the module does not match the signature ...
! Missing declaration: structure Y.X of the domain
! is specified in the module as 
!   structure X : {}
! but not declared in the signature
- ! Toplevel input:
!   L_YG_L:functor(L:L)->functor(YL:sig structure Y:L end)->L;
!   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
! Signature mismatch: the module does not match the signature ...
! Missing declaration: structure Y.X of the domain of the range
! is specified in the module as 
!   structure X : {}
! but not declared in the signature
- ! Toplevel input:
!   FLYGL:sig functor F: functor(L:L)->functor(YL:sig structure Y:L end)->L end;
!   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
! Signature mismatch: the module does not match the signature ...
! Missing declaration: structure Y.X of the domain of the range of F
! is specified in the module as 
!   structure X : {}
! but not declared in the signature
- > signature G = {functor F : {}->{}}
- > signature L = {}
- ! Toplevel input:
!   L:G;
!   ^^^
! Signature mismatch: the module does not match the signature ...
! Missing declaration: functor F
! is specified in the signature as 
!   functor F : {}->{}
! but not declared in the module
- ! Toplevel input:
!   LL:functor(L:L)->G;
!   ^^^^^^^^^^^^^^^^^^
! Signature mismatch: the module does not match the signature ...
! Missing declaration: functor F of the range
! is specified in the signature as 
!   functor F : {}->{}
! but not declared in the module
- ! Toplevel input:
!   GL:functor(L:L)->L;
!   ^^^^^^^^^^^^^^^^^^
! Signature mismatch: the module does not match the signature ...
! Missing declaration: functor F of the domain
! is specified in the module as 
!   functor F : {}->{}
! but not declared in the signature
- ! Toplevel input:
!   YL:sig structure Y: G end;
!   ^^^^^^^^^^^^^^^^^^^^^^^^^
! Signature mismatch: the module does not match the signature ...
! Missing declaration: functor Y.F
! is specified in the signature as 
!   functor F : {}->{}
! but not declared in the module
- ! Toplevel input:
!   L_YL:functor(L:L)->sig structure Y: G end;
!   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
! Signature mismatch: the module does not match the signature ...
! Missing declaration: functor Y.F of the range
! is specified in the signature as 
!   functor F : {}->{}
! but not declared in the module
- ! Toplevel input:
!   YG_L:functor(YL:sig structure Y: L end)->L;
!   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
! Signature mismatch: the module does not match the signature ...
! Missing declaration: functor Y.F of the domain
! is specified in the module as 
!   functor F : {}->{}
! but not declared in the signature
- ! Toplevel input:
!   L_YG_L:functor(L:L)->functor(YL:sig structure Y:L end)->L;
!   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
! Signature mismatch: the module does not match the signature ...
! Missing declaration: functor Y.F of the domain of the range
! is specified in the module as 
!   functor F : {}->{}
! but not declared in the signature
- ! Toplevel input:
!   FLYGL:sig functor F: functor(L:L)->functor(YL:sig structure Y:L end)->L end;
!   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
! Signature mismatch: the module does not match the signature ...
! Missing declaration: functor Y.F of the domain of the range of F
! is specified in the module as 
!   functor F : {}->{}
! but not declared in the signature
- > signature G = {val 'a x : 'a -> 'a}
- > signature L = {val x : int -> int}
- ! Toplevel input:
!   L:G;
!   ^^^
! Signature mismatch: the module does not match the signature ...
! Scheme mismatch: value identifier x
! is specified with type scheme 
!   val 'a x : 'a -> 'a
! in the signature
! but its declaration has the unrelated type scheme 
!   val x : int -> int
! in the module
! The declared type scheme should be at least as general as the specified type scheme
- ! Toplevel input:
!   LL:functor(L:L)->G;
!   ^^^^^^^^^^^^^^^^^^
! Signature mismatch: the module does not match the signature ...
! Scheme mismatch: value identifier x of the range
! is specified with type scheme 
!   val 'a x : 'a -> 'a
! in the signature
! but its declaration has the unrelated type scheme 
!   val x : int -> int
! in the module
! The declared type scheme should be at least as general as the specified type scheme
- ! Toplevel input:
!   GL:functor(L:L)->L;
!   ^^^^^^^^^^^^^^^^^^
! Signature mismatch: the module does not match the signature ...
! Scheme mismatch: value identifier x of the domain
! is specified with type scheme 
!   val 'a x : 'a -> 'a
! in the module
! but its declaration has the unrelated type scheme 
!   val x : int -> int
! in the signature
! The declared type scheme should be at least as general as the specified type scheme
- ! Toplevel input:
!   YL:sig structure Y: G end;
!   ^^^^^^^^^^^^^^^^^^^^^^^^^
! Signature mismatch: the module does not match the signature ...
! Scheme mismatch: value identifier Y.x
! is specified with type scheme 
!   val 'a x : 'a -> 'a
! in the signature
! but its declaration has the unrelated type scheme 
!   val x : int -> int
! in the module
! The declared type scheme should be at least as general as the specified type scheme
- ! Toplevel input:
!   L_YL:functor(L:L)->sig structure Y: G end;
!   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
! Signature mismatch: the module does not match the signature ...
! Scheme mismatch: value identifier Y.x of the range
! is specified with type scheme 
!   val 'a x : 'a -> 'a
! in the signature
! but its declaration has the unrelated type scheme 
!   val x : int -> int
! in the module
! The declared type scheme should be at least as general as the specified type scheme
- ! Toplevel input:
!   YG_L:functor(YL:sig structure Y: L end)->L;
!   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
! Signature mismatch: the module does not match the signature ...
! Scheme mismatch: value identifier Y.x of the domain
! is specified with type scheme 
!   val 'a x : 'a -> 'a
! in the module
! but its declaration has the unrelated type scheme 
!   val x : int -> int
! in the signature
! The declared type scheme should be at least as general as the specified type scheme
- ! Toplevel input:
!   L_YG_L:functor(L:L)->functor(YL:sig structure Y:L end)->L;
!   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
! Signature mismatch: the module does not match the signature ...
! Scheme mismatch: value identifier Y.x of the domain of the range
! is specified with type scheme 
!   val 'a x : 'a -> 'a
! in the module
! but its declaration has the unrelated type scheme 
!   val x : int -> int
! in the signature
! The declared type scheme should be at least as general as the specified type scheme
- ! Toplevel input:
!   FLYGL:sig functor F: functor(L:L)->functor(YL:sig structure Y:L end)->L end;
!   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
! Signature mismatch: the module does not match the signature ...
! Scheme mismatch: value identifier Y.x of the domain of the range of F
! is specified with type scheme 
!   val 'a x : 'a -> 'a
! in the module
! but its declaration has the unrelated type scheme 
!   val x : int -> int
! in the signature
! The declared type scheme should be at least as general as the specified type scheme
- ! Toplevel input:
! 	  L:G;
! 	  ^^^
! Signature mismatch: the module does not match the signature ...
! Scheme mismatch: value identifier x
! is specified with type scheme 
!   val 'a x : ('a -> 'a) -> 'a -> 'a
! in the signature
! but its declaration has the unrelated type scheme 
!   val 'a x : ('a -> 'a) -> 'b -> 'b
! in the module
! The declared type scheme should be at least as general as the specified type scheme
- ! Toplevel input:
! 	  LL:functor(L:L)->G;
! 	  ^^^^^^^^^^^^^^^^^^
! Signature mismatch: the module does not match the signature ...
! Scheme mismatch: value identifier x of the range
! is specified with type scheme 
!   val 'a x : ('a -> 'a) -> 'a -> 'a
! in the signature
! but its declaration has the unrelated type scheme 
!   val 'a x : ('a -> 'a) -> 'b -> 'b
! in the module
! The declared type scheme should be at least as general as the specified type scheme
- ! Toplevel input:
! 	  GL:functor(L:L)->L;
! 	  ^^^^^^^^^^^^^^^^^^
! Signature mismatch: the module does not match the signature ...
! Scheme mismatch: value identifier x of the domain
! is specified with type scheme 
!   val 'a x : ('a -> 'a) -> 'a -> 'a
! in the module
! but its declaration has the unrelated type scheme 
!   val 'a x : ('a -> 'a) -> 'b -> 'b
! in the signature
! The declared type scheme should be at least as general as the specified type scheme
- ! Toplevel input:
! 	  YL:sig structure Y: G end;
! 	  ^^^^^^^^^^^^^^^^^^^^^^^^^
! Signature mismatch: the module does not match the signature ...
! Scheme mismatch: value identifier Y.x
! is specified with type scheme 
!   val 'a x : ('a -> 'a) -> 'a -> 'a
! in the signature
! but its declaration has the unrelated type scheme 
!   val 'a x : ('a -> 'a) -> 'b -> 'b
! in the module
! The declared type scheme should be at least as general as the specified type scheme
- ! Toplevel input:
! 	  L_YL:functor(L:L)->sig structure Y: G end;
! 	  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
! Signature mismatch: the module does not match the signature ...
! Scheme mismatch: value identifier Y.x of the range
! is specified with type scheme 
!   val 'a x : ('a -> 'a) -> 'a -> 'a
! in the signature
! but its declaration has the unrelated type scheme 
!   val 'a x : ('a -> 'a) -> 'b -> 'b
! in the module
! The declared type scheme should be at least as general as the specified type scheme
- ! Toplevel input:
! 	  YG_L:functor(YL:sig structure Y: L end)->L;
! 	  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
! Signature mismatch: the module does not match the signature ...
! Scheme mismatch: value identifier Y.x of the domain
! is specified with type scheme 
!   val 'a x : ('a -> 'a) -> 'a -> 'a
! in the module
! but its declaration has the unrelated type scheme 
!   val 'a x : ('a -> 'a) -> 'b -> 'b
! in the signature
! The declared type scheme should be at least as general as the specified type scheme
- ! Toplevel input:
! 	  L_YG_L:functor(L:L)->functor(YL:sig structure Y:L end)->L;
! 	  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
! Signature mismatch: the module does not match the signature ...
! Scheme mismatch: value identifier Y.x of the domain of the range
! is specified with type scheme 
!   val 'a x : ('a -> 'a) -> 'a -> 'a
! in the module
! but its declaration has the unrelated type scheme 
!   val 'a x : ('a -> 'a) -> 'b -> 'b
! in the signature
! The declared type scheme should be at least as general as the specified type scheme
- ! Toplevel input:
! 	  FLYGL:sig functor F: functor(L:L)->functor(YL:sig structure Y:L end)->L end;
! 	  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
! Signature mismatch: the module does not match the signature ...
! Scheme mismatch: value identifier Y.x of the domain of the range of F
! is specified with type scheme 
!   val 'a x : ('a -> 'a) -> 'a -> 'a
! in the module
! but its declaration has the unrelated type scheme 
!   val 'a x : ('a -> 'a) -> 'b -> 'b
! in the signature
! The declared type scheme should be at least as general as the specified type scheme
- > signature G = {exn x : exn}
- > signature L = {val x : exn}
- ! Toplevel input:
!   L:G;
!   ^^^
! Signature mismatch: the module does not match the signature ...
! Status mismatch: identifier x
! is specified as an exception in the signature
!   exn x : exn
! but declared as an ordinary value in the module
!   val x : exn
- ! Toplevel input:
!   LL:functor(L:L)->G;
!   ^^^^^^^^^^^^^^^^^^
! Signature mismatch: the module does not match the signature ...
! Status mismatch: identifier x of the range
! is specified as an exception in the signature
!   exn x : exn
! but declared as an ordinary value in the module
!   val x : exn
- ! Toplevel input:
!   GL:functor(L:L)->L;
!   ^^^^^^^^^^^^^^^^^^
! Signature mismatch: the module does not match the signature ...
! Status mismatch: identifier x of the domain
! is specified as an exception in the module
!   exn x : exn
! but declared as an ordinary value in the signature
!   val x : exn
- ! Toplevel input:
!   YL:sig structure Y: G end;
!   ^^^^^^^^^^^^^^^^^^^^^^^^^
! Signature mismatch: the module does not match the signature ...
! Status mismatch: identifier Y.x
! is specified as an exception in the signature
!   exn x : exn
! but declared as an ordinary value in the module
!   val x : exn
- ! Toplevel input:
!   L_YL:functor(L:L)->sig structure Y: G end;
!   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
! Signature mismatch: the module does not match the signature ...
! Status mismatch: identifier Y.x of the range
! is specified as an exception in the signature
!   exn x : exn
! but declared as an ordinary value in the module
!   val x : exn
- ! Toplevel input:
!   YG_L:functor(YL:sig structure Y: L end)->L;
!   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
! Signature mismatch: the module does not match the signature ...
! Status mismatch: identifier Y.x of the domain
! is specified as an exception in the module
!   exn x : exn
! but declared as an ordinary value in the signature
!   val x : exn
- ! Toplevel input:
!   L_YG_L:functor(L:L)->functor(YL:sig structure Y:L end)->L;
!   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
! Signature mismatch: the module does not match the signature ...
! Status mismatch: identifier Y.x of the domain of the range
! is specified as an exception in the module
!   exn x : exn
! but declared as an ordinary value in the signature
!   val x : exn
- ! Toplevel input:
!   FLYGL:sig functor F: functor(L:L)->functor(YL:sig structure Y:L end)->L end;
!   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
! Signature mismatch: the module does not match the signature ...
! Status mismatch: identifier Y.x of the domain of the range of F
! is specified as an exception in the module
!   exn x : exn
! but declared as an ordinary value in the signature
!   val x : exn
- > signature G = /\=t.{datatype t = (t,{con C : int -> t}), con C : int -> t}
- > signature L = /\=t.{datatype t = (t,{con D : int -> t}), con D : int -> t}
- ! Toplevel input:
!   L:G;
!   ^^^
! Signature mismatch: the module does not match the signature ...
! Datatype mismatch: type constructor t
! is specified as the datatype
!   datatype t = (t,{con C : int -> t})
! in the signature
! but declared as the different datatype
!   datatype t = (t,{con D : int -> t})
! in the module
! The datatypes should agree on the names and the order of value constructors
- ! Toplevel input:
!   LL:functor(L:L)->G;
!   ^^^^^^^^^^^^^^^^^^
! Signature mismatch: the module does not match the signature ...
! Datatype mismatch: type constructor t of the range
! is specified as the datatype
!   datatype t = (t,{con C : int -> t})
! in the signature
! but declared as the different datatype
!   datatype t = (t,{con D : int -> t})
! in the module
! The datatypes should agree on the names and the order of value constructors
- ! Toplevel input:
!   GL:functor(L:L)->L;
!   ^^^^^^^^^^^^^^^^^^
! Signature mismatch: the module does not match the signature ...
! Datatype mismatch: type constructor t of the domain
! is specified as the datatype
!   datatype t = (t,{con C : int -> t})
! in the module
! but declared as the different datatype
!   datatype t = (t,{con D : int -> t})
! in the signature
! The datatypes should agree on the names and the order of value constructors
- ! Toplevel input:
!   YL:sig structure Y: G end;
!   ^^^^^^^^^^^^^^^^^^^^^^^^^
! Signature mismatch: the module does not match the signature ...
! Datatype mismatch: type constructor Y.t
! is specified as the datatype
!   datatype t = (t,{con C : int -> t})
! in the signature
! but declared as the different datatype
!   datatype t = (t,{con D : int -> t})
! in the module
! The datatypes should agree on the names and the order of value constructors
- ! Toplevel input:
!   L_YL:functor(L:L)->sig structure Y: G end;
!   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
! Signature mismatch: the module does not match the signature ...
! Datatype mismatch: type constructor Y.t of the range
! is specified as the datatype
!   datatype t = (t,{con C : int -> t})
! in the signature
! but declared as the different datatype
!   datatype t = (t,{con D : int -> t})
! in the module
! The datatypes should agree on the names and the order of value constructors
- ! Toplevel input:
!   YG_L:functor(YL:sig structure Y: L end)->L;
!   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
! Signature mismatch: the module does not match the signature ...
! Datatype mismatch: type constructor Y.t of the domain
! is specified as the datatype
!   datatype t = (t,{con C : int -> t})
! in the module
! but declared as the different datatype
!   datatype t = (t,{con D : int -> t})
! in the signature
! The datatypes should agree on the names and the order of value constructors
- ! Toplevel input:
!   L_YG_L:functor(L:L)->functor(YL:sig structure Y:L end)->L;
!   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
! Signature mismatch: the module does not match the signature ...
! Datatype mismatch: type constructor Y.t of the domain of the range
! is specified as the datatype
!   datatype t = (t,{con C : int -> t})
! in the module
! but declared as the different datatype
!   datatype t = (t,{con D : int -> t})
! in the signature
! The datatypes should agree on the names and the order of value constructors
- ! Toplevel input:
!   FLYGL:sig functor F: functor(L:L)->functor(YL:sig structure Y:L end)->L end;
!   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
! Signature mismatch: the module does not match the signature ...
! Datatype mismatch: type constructor Y.t of the domain of the range of F
! is specified as the datatype
!   datatype t = (t,{con C : int -> t})
! in the module
! but declared as the different datatype
!   datatype t = (t,{con D : int -> t})
! in the signature
! The datatypes should agree on the names and the order of value constructors
- > signature G = {type t = unit}
- > signature L = {type 'a t = unit}
- ! Toplevel input:
!   L:G;
!   ^^^
! Signature mismatch: the module does not match the signature ...
! Arity mismatch: type constructor t
! is specified with arity 0 in the signature
!   type t = unit
! but declared with arity 1 in the module
!   type 'a t = unit
! The arities should agree
- ! Toplevel input:
!   LL:functor(L:L)->G;
!   ^^^^^^^^^^^^^^^^^^
! Signature mismatch: the module does not match the signature ...
! Arity mismatch: type constructor t of the range
! is specified with arity 0 in the signature
!   type t = unit
! but declared with arity 1 in the module
!   type 'a t = unit
! The arities should agree
- ! Toplevel input:
!   GL:functor(L:L)->L;
!   ^^^^^^^^^^^^^^^^^^
! Signature mismatch: the module does not match the signature ...
! Arity mismatch: type constructor t of the domain
! is specified with arity 0 in the module
!   type t = unit
! but declared with arity 1 in the signature
!   type 'a t = unit
! The arities should agree
- ! Toplevel input:
!   YL:sig structure Y: G end;
!   ^^^^^^^^^^^^^^^^^^^^^^^^^
! Signature mismatch: the module does not match the signature ...
! Arity mismatch: type constructor Y.t
! is specified with arity 0 in the signature
!   type t = unit
! but declared with arity 1 in the module
!   type 'a t = unit
! The arities should agree
- ! Toplevel input:
!   L_YL:functor(L:L)->sig structure Y: G end;
!   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
! Signature mismatch: the module does not match the signature ...
! Arity mismatch: type constructor Y.t of the range
! is specified with arity 0 in the signature
!   type t = unit
! but declared with arity 1 in the module
!   type 'a t = unit
! The arities should agree
- ! Toplevel input:
!   YG_L:functor(YL:sig structure Y: L end)->L;
!   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
! Signature mismatch: the module does not match the signature ...
! Arity mismatch: type constructor Y.t of the domain
! is specified with arity 0 in the module
!   type t = unit
! but declared with arity 1 in the signature
!   type 'a t = unit
! The arities should agree
- ! Toplevel input:
!   L_YG_L:functor(L:L)->functor(YL:sig structure Y:L end)->L;
!   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
! Signature mismatch: the module does not match the signature ...
! Arity mismatch: type constructor Y.t of the domain of the range
! is specified with arity 0 in the module
!   type t = unit
! but declared with arity 1 in the signature
!   type 'a t = unit
! The arities should agree
- ! Toplevel input:
!   FLYGL:sig functor F: functor(L:L)->functor(YL:sig structure Y:L end)->L end;
!   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
! Signature mismatch: the module does not match the signature ...
! Arity mismatch: type constructor Y.t of the domain of the range of F
! is specified with arity 0 in the module
!   type t = unit
! but declared with arity 1 in the signature
!   type 'a t = unit
! The arities should agree
- > signature G = {type 'a myref = 'a ref}
- > signature L = {type 'a myref = 'a}
- ! Toplevel input:
!   L:G;
!   ^^^
! Signature mismatch: the module does not match the signature ...
! Equality type mismatch: type constructor myref
! is specified as a `prim_EQtype' in the signature
!   type 'a myref = 'a ref
! but is not declared as a `prim_EQtype' in the module
!   type 'a myref = 'a
- ! Toplevel input:
!   LL:functor(L:L)->G;
!   ^^^^^^^^^^^^^^^^^^
! Signature mismatch: the module does not match the signature ...
! Equality type mismatch: type constructor myref of the range
! is specified as a `prim_EQtype' in the signature
!   type 'a myref = 'a ref
! but is not declared as a `prim_EQtype' in the module
!   type 'a myref = 'a
- ! Toplevel input:
!   GL:functor(L:L)->L;
!   ^^^^^^^^^^^^^^^^^^
! Signature mismatch: the module does not match the signature ...
! Equality type mismatch: type constructor myref of the domain
! is specified as a `prim_EQtype' in the module
!   type 'a myref = 'a ref
! but is not declared as a `prim_EQtype' in the signature
!   type 'a myref = 'a
- ! Toplevel input:
!   YL:sig structure Y: G end;
!   ^^^^^^^^^^^^^^^^^^^^^^^^^
! Signature mismatch: the module does not match the signature ...
! Equality type mismatch: type constructor Y.myref
! is specified as a `prim_EQtype' in the signature
!   type 'a myref = 'a ref
! but is not declared as a `prim_EQtype' in the module
!   type 'a myref = 'a
- ! Toplevel input:
!   L_YL:functor(L:L)->sig structure Y: G end;
!   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
! Signature mismatch: the module does not match the signature ...
! Equality type mismatch: type constructor Y.myref of the range
! is specified as a `prim_EQtype' in the signature
!   type 'a myref = 'a ref
! but is not declared as a `prim_EQtype' in the module
!   type 'a myref = 'a
- ! Toplevel input:
!   YG_L:functor(YL:sig structure Y: L end)->L;
!   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
! Signature mismatch: the module does not match the signature ...
! Equality type mismatch: type constructor Y.myref of the domain
! is specified as a `prim_EQtype' in the module
!   type 'a myref = 'a ref
! but is not declared as a `prim_EQtype' in the signature
!   type 'a myref = 'a
- ! Toplevel input:
!   L_YG_L:functor(L:L)->functor(YL:sig structure Y:L end)->L;
!   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
! Signature mismatch: the module does not match the signature ...
! Equality type mismatch: type constructor Y.myref of the domain of the range
! is specified as a `prim_EQtype' in the module
!   type 'a myref = 'a ref
! but is not declared as a `prim_EQtype' in the signature
!   type 'a myref = 'a
- ! Toplevel input:
!   FLYGL:sig functor F: functor(L:L)->functor(YL:sig structure Y:L end)->L end;
!   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
! Signature mismatch: the module does not match the signature ...
! Equality type mismatch: type constructor Y.myref of the domain of the range of F
! is specified as a `prim_EQtype' in the module
!   type 'a myref = 'a ref
! but is not declared as a `prim_EQtype' in the signature
!   type 'a myref = 'a
- > signature G = /\=t.{type t = t}
- > signature L = /\t.{type t = t}
- ! Toplevel input:
!   L:G;
!   ^^^
! Signature mismatch: the module does not match the signature ...
! Equality type mismatch: type constructor t
! is specified as a `prim_EQtype' in the signature
!   type t = t
! but is not declared as a `prim_EQtype' in the module
!   type t = t/1
- ! Toplevel input:
!   LL:functor(L:L)->G;
!   ^^^^^^^^^^^^^^^^^^
! Signature mismatch: the module does not match the signature ...
! Equality type mismatch: type constructor t of the range
! is specified as a `prim_EQtype' in the signature
!   type t = t
! but is not declared as a `prim_EQtype' in the module
!   type t = t/1
- ! Toplevel input:
!   GL:functor(L:L)->L;
!   ^^^^^^^^^^^^^^^^^^
! Signature mismatch: the module does not match the signature ...
! Equality type mismatch: type constructor t of the domain
! is specified as a `prim_EQtype' in the module
!   type t = t
! but is not declared as a `prim_EQtype' in the signature
!   type t = t/1
- ! Toplevel input:
!   YL:sig structure Y: G end;
!   ^^^^^^^^^^^^^^^^^^^^^^^^^
! Signature mismatch: the module does not match the signature ...
! Equality type mismatch: type constructor Y.t
! is specified as a `prim_EQtype' in the signature
!   type t = t
! but is not declared as a `prim_EQtype' in the module
!   type t = t/1
- ! Toplevel input:
!   L_YL:functor(L:L)->sig structure Y: G end;
!   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
! Signature mismatch: the module does not match the signature ...
! Equality type mismatch: type constructor Y.t of the range
! is specified as a `prim_EQtype' in the signature
!   type t = t
! but is not declared as a `prim_EQtype' in the module
!   type t = t/1
- ! Toplevel input:
!   YG_L:functor(YL:sig structure Y: L end)->L;
!   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
! Signature mismatch: the module does not match the signature ...
! Equality type mismatch: type constructor Y.t of the domain
! is specified as a `prim_EQtype' in the module
!   type t = t
! but is not declared as a `prim_EQtype' in the signature
!   type t = t/1
- ! Toplevel input:
!   L_YG_L:functor(L:L)->functor(YL:sig structure Y:L end)->L;
!   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
! Signature mismatch: the module does not match the signature ...
! Equality type mismatch: type constructor Y.t of the domain of the range
! is specified as a `prim_EQtype' in the module
!   type t = t
! but is not declared as a `prim_EQtype' in the signature
!   type t = t/1
- ! Toplevel input:
!   FLYGL:sig functor F: functor(L:L)->functor(YL:sig structure Y:L end)->L end;
!   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
! Signature mismatch: the module does not match the signature ...
! Equality type mismatch: type constructor Y.t of the domain of the range of F
! is specified as a `prim_EQtype' in the module
!   type t = t
! but is not declared as a `prim_EQtype' in the signature
!   type t = t/1
- > signature G = /\=t.{type t = t}
- > signature L = {type t = unit -> unit}
- ! Toplevel input:
!   L:G;
!   ^^^
! Signature mismatch: the module does not match the signature ...
! Equality type mismatch: type constructor t
! is specified as admitting equality in the signature
!   type t = t
! but its declaration does not admit equality in the module
!   type t = unit -> unit
- ! Toplevel input:
!   LL:functor(L:L)->G;
!   ^^^^^^^^^^^^^^^^^^
! Signature mismatch: the module does not match the signature ...
! Equality type mismatch: type constructor t of the range
! is specified as admitting equality in the signature
!   type t = t
! but its declaration does not admit equality in the module
!   type t = unit -> unit
- ! Toplevel input:
!   GL:functor(L:L)->L;
!   ^^^^^^^^^^^^^^^^^^
! Signature mismatch: the module does not match the signature ...
! Equality type mismatch: type constructor t of the domain
! is specified as admitting equality in the module
!   type t = t
! but its declaration does not admit equality in the signature
!   type t = unit -> unit
- ! Toplevel input:
!   YL:sig structure Y: G end;
!   ^^^^^^^^^^^^^^^^^^^^^^^^^
! Signature mismatch: the module does not match the signature ...
! Equality type mismatch: type constructor Y.t
! is specified as admitting equality in the signature
!   type t = t
! but its declaration does not admit equality in the module
!   type t = unit -> unit
- ! Toplevel input:
!   L_YL:functor(L:L)->sig structure Y: G end;
!   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
! Signature mismatch: the module does not match the signature ...
! Equality type mismatch: type constructor Y.t of the range
! is specified as admitting equality in the signature
!   type t = t
! but its declaration does not admit equality in the module
!   type t = unit -> unit
- ! Toplevel input:
!   YG_L:functor(YL:sig structure Y: L end)->L;
!   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
! Signature mismatch: the module does not match the signature ...
! Equality type mismatch: type constructor Y.t of the domain
! is specified as admitting equality in the module
!   type t = t
! but its declaration does not admit equality in the signature
!   type t = unit -> unit
- ! Toplevel input:
!   L_YG_L:functor(L:L)->functor(YL:sig structure Y:L end)->L;
!   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
! Signature mismatch: the module does not match the signature ...
! Equality type mismatch: type constructor Y.t of the domain of the range
! is specified as admitting equality in the module
!   type t = t
! but its declaration does not admit equality in the signature
!   type t = unit -> unit
- ! Toplevel input:
!   FLYGL:sig functor F: functor(L:L)->functor(YL:sig structure Y:L end)->L end;
!   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
! Signature mismatch: the module does not match the signature ...
! Equality type mismatch: type constructor Y.t of the domain of the range of F
! is specified as admitting equality in the module
!   type t = t
! but its declaration does not admit equality in the signature
!   type t = unit -> unit
- > signature G = {type t = unit}
- > signature L = {type t = unit -> unit}
- ! Toplevel input:
!   L:G;
!   ^^^
! Signature mismatch: the module does not match the signature ...
! Equality type mismatch: type constructor t
! is specified as admitting equality in the signature
!   type t = unit
! but its declaration does not admit equality in the module
!   type t = unit -> unit
- ! Toplevel input:
!   LL:functor(L:L)->G;
!   ^^^^^^^^^^^^^^^^^^
! Signature mismatch: the module does not match the signature ...
! Equality type mismatch: type constructor t of the range
! is specified as admitting equality in the signature
!   type t = unit
! but its declaration does not admit equality in the module
!   type t = unit -> unit
- ! Toplevel input:
!   GL:functor(L:L)->L;
!   ^^^^^^^^^^^^^^^^^^
! Signature mismatch: the module does not match the signature ...
! Equality type mismatch: type constructor t of the domain
! is specified as admitting equality in the module
!   type t = unit
! but its declaration does not admit equality in the signature
!   type t = unit -> unit
- ! Toplevel input:
!   YL:sig structure Y: G end;
!   ^^^^^^^^^^^^^^^^^^^^^^^^^
! Signature mismatch: the module does not match the signature ...
! Equality type mismatch: type constructor Y.t
! is specified as admitting equality in the signature
!   type t = unit
! but its declaration does not admit equality in the module
!   type t = unit -> unit
- ! Toplevel input:
!   L_YL:functor(L:L)->sig structure Y: G end;
!   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
! Signature mismatch: the module does not match the signature ...
! Equality type mismatch: type constructor Y.t of the range
! is specified as admitting equality in the signature
!   type t = unit
! but its declaration does not admit equality in the module
!   type t = unit -> unit
- ! Toplevel input:
!   YG_L:functor(YL:sig structure Y: L end)->L;
!   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
! Signature mismatch: the module does not match the signature ...
! Equality type mismatch: type constructor Y.t of the domain
! is specified as admitting equality in the module
!   type t = unit
! but its declaration does not admit equality in the signature
!   type t = unit -> unit
- ! Toplevel input:
!   L_YG_L:functor(L:L)->functor(YL:sig structure Y:L end)->L;
!   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
! Signature mismatch: the module does not match the signature ...
! Equality type mismatch: type constructor Y.t of the domain of the range
! is specified as admitting equality in the module
!   type t = unit
! but its declaration does not admit equality in the signature
!   type t = unit -> unit
- ! Toplevel input:
!   FLYGL:sig functor F: functor(L:L)->functor(YL:sig structure Y:L end)->L end;
!   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
! Signature mismatch: the module does not match the signature ...
! Equality type mismatch: type constructor Y.t of the domain of the range of F
! is specified as admitting equality in the module
!   type t = unit
! but its declaration does not admit equality in the signature
!   type t = unit -> unit
- > signature G = /\=t.{datatype t = (t,{con C : t}), con C : t}
- > signature L = {type t = unit}
- ! Toplevel input:
!   L:G;
!   ^^^
! Signature mismatch: the module does not match the signature ...
! Datatype mismatch: type constructor t
! is specified as a datatype in the signature
!   datatype t = (unit,{con C : unit})
! but not declared as a datatype in the module
!   type t = unit
! The declaration should also be a datatype
- ! Toplevel input:
!   LL:functor(L:L)->G;
!   ^^^^^^^^^^^^^^^^^^
! Signature mismatch: the module does not match the signature ...
! Datatype mismatch: type constructor t of the range
! is specified as a datatype in the signature
!   datatype t = (unit,{con C : unit})
! but not declared as a datatype in the module
!   type t = unit
! The declaration should also be a datatype
- ! Toplevel input:
!   GL:functor(L:L)->L;
!   ^^^^^^^^^^^^^^^^^^
! Signature mismatch: the module does not match the signature ...
! Datatype mismatch: type constructor t of the domain
! is specified as a datatype in the module
!   datatype t = (unit,{con C : unit})
! but not declared as a datatype in the signature
!   type t = unit
! The declaration should also be a datatype
- ! Toplevel input:
!   YL:sig structure Y: G end;
!   ^^^^^^^^^^^^^^^^^^^^^^^^^
! Signature mismatch: the module does not match the signature ...
! Datatype mismatch: type constructor Y.t
! is specified as a datatype in the signature
!   datatype t = (unit,{con C : unit})
! but not declared as a datatype in the module
!   type t = unit
! The declaration should also be a datatype
- ! Toplevel input:
!   L_YL:functor(L:L)->sig structure Y: G end;
!   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
! Signature mismatch: the module does not match the signature ...
! Datatype mismatch: type constructor Y.t of the range
! is specified as a datatype in the signature
!   datatype t = (unit,{con C : unit})
! but not declared as a datatype in the module
!   type t = unit
! The declaration should also be a datatype
- ! Toplevel input:
!   YG_L:functor(YL:sig structure Y: L end)->L;
!   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
! Signature mismatch: the module does not match the signature ...
! Datatype mismatch: type constructor Y.t of the domain
! is specified as a datatype in the module
!   datatype t = (unit,{con C : unit})
! but not declared as a datatype in the signature
!   type t = unit
! The declaration should also be a datatype
- ! Toplevel input:
!   L_YG_L:functor(L:L)->functor(YL:sig structure Y:L end)->L;
!   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
! Signature mismatch: the module does not match the signature ...
! Datatype mismatch: type constructor Y.t of the domain of the range
! is specified as a datatype in the module
!   datatype t = (unit,{con C : unit})
! but not declared as a datatype in the signature
!   type t = unit
! The declaration should also be a datatype
- ! Toplevel input:
!   FLYGL:sig functor F: functor(L:L)->functor(YL:sig structure Y:L end)->L end;
!   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
! Signature mismatch: the module does not match the signature ...
! Datatype mismatch: type constructor Y.t of the domain of the range of F
! is specified as a datatype in the module
!   datatype t = (unit,{con C : unit})
! but not declared as a datatype in the signature
!   type t = unit
! The declaration should also be a datatype
- > signature G = /\u.!t.{type t = t}->{type u = (u t)}
- > signature L = !t.{type t = t}->?u.{type u = u}
- ! Toplevel input:
!   L:G;
!   ^^^
! Signature mismatch: the module does not match the signature ...
! Scope Violation: type constructor u of the range has specification:
!   type u = (u t)
! in the signature
! but is implemented by the declaration: 
!   type u = u/1
! in the module
! The declaration violates the specification because 
! the type constructor u/1 is a parameter 
! that is declared within the scope of u.
- ! Toplevel input:
!   LL:functor(L:L)->G;
!   ^^^^^^^^^^^^^^^^^^
! Signature mismatch: the module does not match the signature ...
! Scope Violation: type constructor u of the range of the range has specification:
!   type u = (u t)
! in the signature
! but is implemented by the declaration: 
!   type u = u/1
! in the module
! The declaration violates the specification because 
! the type constructor u/1 is a parameter 
! that is declared within the scope of u.
- ! Toplevel input:
!   GL:functor(L:L)->L;
!   ^^^^^^^^^^^^^^^^^^
! Signature mismatch: the module does not match the signature ...
! Scope Violation: type constructor u of the range of the domain has specification:
!   type u = (u t)
! in the module
! but is implemented by the declaration: 
!   type u = u/1
! in the signature
! The declaration violates the specification because 
! the type constructor u/1 is a parameter 
! that is declared within the scope of u.
- > signature G = /\u.{functor F : !t.{type t = t}->{type u = (u t)}}
- > signature L = {functor F : !t.{type t = t}->?u.{type u = u}}
- ! Toplevel input:
!   YL:sig structure Y: G end;
!   ^^^^^^^^^^^^^^^^^^^^^^^^^
! Signature mismatch: the module does not match the signature ...
! Scope Violation: type constructor u of the range of Y.F has specification:
!   type u = (u t)
! in the signature
! but is implemented by the declaration: 
!   type u = u/1
! in the module
! The declaration violates the specification because 
! the type constructor u/1 is a parameter 
! that is declared within the scope of u.
- ! Toplevel input:
!   L_YL:functor(L:L)->sig structure Y: G end;
!   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
! Signature mismatch: the module does not match the signature ...
! Scope Violation: type constructor u of the range of Y.F of the range has specification:
!   type u = (u t)
! in the signature
! but is implemented by the declaration: 
!   type u = u/1
! in the module
! The declaration violates the specification because 
! the type constructor u/1 is a parameter 
! that is declared within the scope of u.
- ! Toplevel input:
!   YG_L:functor(YL:sig structure Y: L end)->L;
!   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
! Signature mismatch: the module does not match the signature ...
! Scope Violation: type constructor u of the range of Y.F of the domain has specification:
!   type u = (u t)
! in the module
! but is implemented by the declaration: 
!   type u = u/1
! in the signature
! The declaration violates the specification because 
! the type constructor u/1 is a parameter 
! that is declared within the scope of u.
- ! Toplevel input:
!   L_YG_L:functor(L:L)->functor(YL:sig structure Y:L end)->L;
!   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
! Signature mismatch: the module does not match the signature ...
! Scope Violation: type constructor u of the range of Y.F of the domain of the range has specification:
!   type u = (u t)
! in the module
! but is implemented by the declaration: 
!   type u = u/1
! in the signature
! The declaration violates the specification because 
! the type constructor u/1 is a parameter 
! that is declared within the scope of u.
- ! Toplevel input:
!   FLYGL:sig functor F: functor(L:L)->functor(YL:sig structure Y:L end)->L end;
!   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
! Signature mismatch: the module does not match the signature ...
! Scope Violation: type constructor u of the range of Y.F of the domain of the range of F has specification:
!   type u = (u t)
! in the module
! but is implemented by the declaration: 
!   type u = u/1
! in the signature
! The declaration violates the specification because 
! the type constructor u/1 is a parameter 
! that is declared within the scope of u.
- 
Moscow ML version 2.00 (June 2000)
Enter `quit();' to quit.
- > signature OK = {type t = int}
- > signature OK = {structure X : {type t = int}}
- > signature OK = {structure Y : {structure X : {type t = int}}}
- > signature OK = /\t.{type t = t, type u = t}
- > signature OK = /\u.{type u = u, type t = u}
- > signature OK = /\t.{structure X : {type t = t, type u = t}, type u = t}
- > signature OK =
  /\t.
    {structure Y : {structure X : {type t = t, type u = t}, type u = t},
     type u = t}
- > signature OK =
  /\t u u/1 a v.
    {structure Y :
       {structure X : {type t = t, type u = u}, type u = u/1, type a = a},
     structure Z :
       {structure Y :
          {structure X : {type t = t, type u = u}, type u = u/1, type v = v}},
     structure W : {type u = u/1, type v = v}}
- 
Moscow ML version 2.00 (June 2000)
Enter `quit();' to quit.
- > structure X : {exn e : int -> exn}
- > structure Y : {val e : int -> exn}
- > val it = "OK" : string
- > functor F : {}->{exn e : int -> exn}
- > structure X : {exn e : int -> exn}
- > structure Y : {exn e : int -> exn}
- > val it = "OK" : string
- > val it = "OK" : string
- > exn s = s : exn
- > val it = (s, s) : exn * exn
- 
Moscow ML version 2.00 (June 2000)
Enter `quit();' to quit.
- > signature S = {}
- > signature F = {}->{}
- > functor Ok : {}->{}
- ! Toplevel input:
! functor Fail(X:S) = op X;
!                     ^^^^
! Unbound functor identifier: X
! (In this context, it is assumed that 
!    op X
!  refers to a functor.
!  If you actually meant the structure of the same name,
!  you must use the syntax: 
!    X
!  to indicate this.)
- > functor Ok : ({}->{})->{}->{}
- ! Toplevel input:
! functor Fail(X:F) = X;
!                     ^
! Cannot access unit X before it has been loaded.
! (In this context, it is assumed that 
!    X
!  refers to a structure.
!  If you actually meant the functor of the same name,
!  you must use the syntax: 
!    op X
!  to indicate this.)
- > functor Ok : {}->{}
- > functor OK : {}->{}
- > functor Ok : ({}->{})->{}->{}
- > functor OK : ({}->{})->{}->{}
- > functor Ok : {}->{}
- > functor OK : {}->{}
- > functor Ok : ({}->{})->{}->{}
- > functor OK : ({}->{})->{}->{}
- > structure S : {}
- > functor F : {}->{}
- > functor H : ({}->{})->{}->{}
- > structure Ok : {}
- > structure Ok : {}
- > functor Ok : {}->{}
- > functor Ok : {}->{}
- > structure S : {}
- > functor F : {}->{}
- > functor G : {}->{}
- > functor H : ({}->{})->{}->{}
- > structure Ok : {}
- > structure Ok : {}
- > functor Ok : {}->{}
- > functor Ok : {}->{}
- > functor Ok : {}->{}
- ! Toplevel input:
! functor Fail(X:S) = let in op X end;
!                            ^^^^
! Unbound functor identifier: X
! (In this context, it is assumed that 
!    op X
!  refers to a functor.
!  If you actually meant the structure of the same name,
!  you must use the syntax: 
!    X
!  to indicate this.)
- > functor Ok : ({}->{})->{}->{}
- ! Toplevel input:
! functor Fail(X:F) = let in X end;
!                            ^
! Cannot access unit X before it has been loaded.
! (In this context, it is assumed that 
!    X
!  refers to a structure.
!  If you actually meant the functor of the same name,
!  you must use the syntax: 
!    op X
!  to indicate this.)
- > functor Ok : {}->{}
- > functor OK : {}->{}
- > functor Ok : ({}->{})->{}->{}
- > functor OK : ({}->{})->{}->{}
- 
Moscow ML version 2.00 (June 2000)
Enter `quit();' to quit.
- > val integer = fn : int -> int
- > val ok = fn : int -> int
- - > val ok = fn : int -> int
- > val ok = fn : int -> int
- > functor OK : !a.{type a = a, val a : a}->{val 'a x : a -> 'a -> a}
- ! Toplevel input:
! 					       else  B.b
! 					             ^^^
! Type clash: expression of type
!   b
! cannot have type
!   'a
! because of a scope violation:
! the type constructor b is a parameter 
! that is declared within the scope of 'a
- > functor OK : !a.{type a = a, val a : a}->{val 'a x : 'a -> 'a -> 'a}
- - ! Toplevel input:
!             		                     (if true then j else B.b))
!             		                                          ^^^
! Type clash: expression of type
!   b
! cannot have type
!   'a
! because of a scope violation:
! the type constructor b is a parameter 
! that is declared within the scope of 'a
- 
Moscow ML version 2.00 (June 2000)
Enter `quit();' to quit.
- ! Toplevel input:
! ..................rec(Fail: sig type a; type b end)
!     sig 
!     end.
! Illegal recursive signature: the body does not match the forward specification...
! Missing declaration: type constructor a
! is specified in the forward specification as 
!   type a = a
! but not declared in the body
- ! Toplevel input:
! signature Fail2 = rec(Fail:functor(Y:sig end)->sig end)
!                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^
! Illegal recursive signature: the forward specification should specify a structure but actually specifies a functor
- ! Toplevel input:
!     functor(Fail:sig end)->sig end;
!     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
! Illegal recursive signature: the body should specify a structure but actually specifies a functor
- ! Toplevel input:
! ..................rec(Fail: sig type a; type b end)
!                 sig type a = Fail.a
!                     type b = Fail.b
!                  end.
! Illegal recursive signature: the body does not match the forward specification...
! Circularity: type constructor a has specification:
!   type a = a
! in the forward specification
! but is implemented by the declaration: 
!   type a = a
! in the body
! The declaration violates the specification because 
! of the circular occurrence of a
- ! Toplevel input:
! ..................rec(Fail: sig type a; type b end)
!                 sig type a = Fail.b
!                     type b = Fail.a
!                  end.
! Illegal recursive signature: the body does not match the forward specification...
! Circularity: type constructor b has specification:
!   type b = b
! in the forward specification
! but is implemented by the declaration: 
!   type b = b
! in the body
! The declaration violates the specification because 
! of the circular occurrence of b
- ! Toplevel input:
! ..................rec(Fail: sig type a; eqtype b end)
!                  sig datatype a = Aa | Ba of Fail.b 
!                      datatype b = Ab | Bb of Fail.a
!                  end.
! Illegal recursive signature: the body does not match the forward specification...
! Equality type mismatch: type constructor b
! is specified as admitting equality in the forward specification
!   type b = b
! but its declaration does not admit equality in the body
!   datatype b = (b/1,{con Ab : b/1, con Bb : a -> b/1})
- > signature Ok1 =
  /\a b.
    rec ({type a = a, type b = b},
            {datatype a = (a,{con Aa : a, con Ba : b -> a}),
             con Aa : a,
             con Ba : b -> a,
             datatype b = (b,{con Ab : b, con Bb : a -> b}),
             con Ab : b,
             con Bb : a -> b})
- > signature Ok2 =
  /\a b.
    rec ({type a = a, type b = b},
            {datatype a = (a,{con Aa : a, con Ba : b -> a}),
             con Aa : a,
             con Ba : b -> a,
             datatype b = (b,{con Ab : b, con Bb : a -> b}),
             con Ab : b,
             con Bb : a -> b})
- > signature Ok3 =
  /\b a.
    rec ({type a = a, type b = b},
            {datatype b = (b,{con Ab : b, con Bb : a -> b}),
             con Ab : b,
             con Bb : a -> b,
             datatype a = (a,{con Aa : a, con Ba : b -> a}),
             con Aa : a,
             con Ba : b -> a})
- > signature OK4 =
  /\=a =b.
    rec ({type a = a, type b = b},
            {datatype a = (a,{con Aa : a, con Ba : b -> a}),
             con Aa : a,
             con Ba : b -> a,
             datatype b = (b,{con Ab : b, con Bb : a -> b}),
             con Ab : b,
             con Bb : a -> b})
- > signature Ok5 = /\a b.rec ({type a = a, type b = b},{type a = a, type b = b})
- > signature Ok6 = rec ({type a = int},{type a = int})
- > signature OK7 =
  /\=a =b.
    rec ({datatype a = (a,{con Aa : a, con Ba : b -> a}),
          datatype b = (b,{con Ab : b, con Bb : a -> b}),
          con Aa : a,
          con Ba : b -> a,
          con Ab : b,
          con Bb : a -> b},
            {datatype a = (a,{con Aa : a, con Ba : b -> a}),
             con Aa : a,
             con Ba : b -> a,
             datatype b = (b,{con Ab : b, con Bb : a -> b}),
             con Ab : b,
             con Bb : a -> b})
- > signature OK8 =
  /\=b =a.
    rec ({datatype a = (a,{con Aa : a, con Ba : b -> a}),
          datatype b = (b,{con Ab : b, con Bb : a -> b}),
          con Aa : a,
          con Ba : b -> a,
          con Ab : b,
          con Bb : a -> b},
            {datatype a = (a,{con Aa : a, con Ba : b -> a}),
             datatype b = (b,{con Ab : b, con Bb : a -> b}),
             con Aa : a,
             con Ba : b -> a,
             con Ab : b,
             con Bb : a -> b})
- > structure Ok : {}
- > structure Even : {val even : int -> bool}
- > val test1 = true : bool
- > structure EvenOdd : {val even : int -> bool, val odd : int -> bool}
- > val test2 = true : bool
- > val tes3 = false : bool
- > signature U =
  /\a b.
    rec ({structure A : {type a = a}, structure B : {type b = b}},
            {structure A :
               {datatype a = (a,{con Aa : a, con Ba : b -> a}),
                con Aa : a,
                con Ba : b -> a},
             structure B :
               {datatype b = (b,{con Ab : b, con Bb : a -> b}),
                con Ab : b,
                con Bb : a -> b}})
- > New type names: a, b
  structure U :
  {structure A :
     {datatype a = (a,{con Aa : a, con Ba : b -> a}),
      con Aa : a,
      con Ba : b -> a},
   structure B :
     {datatype b = (b,{con Ab : b, con Bb : a -> b}),
      con Ab : b,
      con Bb : a -> b}}
- > signature V =
  /\a/1 b/1.
    rec ({structure A : {type a = a/1}, structure B : {type b = b/1}},
            {structure A :
               {datatype a = (a/1,{con Aa : a/1, con Ba : b/1 -> a/1}),
                con Aa : a/1,
                con Ba : b/1 -> a/1,
                val height : a/1 -> int},
             structure B :
               {datatype b = (b/1,{con Ab : b/1, con Bb : a/1 -> b/1}),
                con Ab : b/1,
                con Bb : a/1 -> b/1,
                val height : b/1 -> int}})
- > New type names: a/1, b/1
  structure V :
  {structure A :
     {datatype a = (a/1,{con Aa : a/1, con Ba : b/1 -> a/1}),
      con Aa : a/1,
      con Ba : b/1 -> a/1,
      val height : a/1 -> int},
   structure B :
     {datatype b = (b/1,{con Ab : b/1, con Bb : a/1 -> b/1}),
      con Ab : b/1,
      con Bb : a/1 -> b/1,
      val height : b/1 -> int}}
- > val test4 = 2 : int
- > val test5 = 3 : int
- > structure V1 :
  {structure A :
     {datatype a = (a/1,{con Aa : a/1, con Ba : b/1 -> a/1}),
      con Aa : a/1,
      con Ba : b/1 -> a/1,
      val height : a/1 -> int},
   structure B :
     {datatype b = (b/1,{con Ab : b/1, con Bb : a/1 -> b/1}),
      con Ab : b/1,
      con Bb : a/1 -> b/1,
      val height : b/1 -> int}}
- > New type names: a/2, b/2
  structure V2 :
  {structure A :
     {datatype a = (a/2,{con Aa : a/2, con Ba : b/2 -> a/2}),
      con Aa : a/2,
      con Ba : b/2 -> a/2,
      val height : a/2 -> int},
   structure B :
     {datatype b = (b/2,{con Ab : b/2, con Bb : a/2 -> b/2}),
      con Ab : b/2,
      con Bb : a/2 -> b/2,
      val height : b/2 -> int}}
- > New type names: a/3, b/3
  structure Y :
  {structure A :
     {datatype a = (a/3,{con Aa : a/3, con Ba : b/3 -> a/3}),
      con Aa : a/3,
      con Ba : b/3 -> a/3,
      val foo : int,
      val height : a/3 -> int},
   structure B :
     {datatype b = (b/3,{con Ab : b/3, con Bb : a/3 -> b/3}),
      con Ab : b/3,
      con Bb : a/3 -> b/3,
      val bar : bool,
      val height : b/3 -> int}}
- > structure Y1 :
  {structure A :
     {datatype a = (a/3,{con Aa : a/3, con Ba : b/3 -> a/3}),
      con Aa : a/3,
      con Ba : b/3 -> a/3,
      val height : a/3 -> int},
   structure B :
     {datatype b = (b/3,{con Ab : b/3, con Bb : a/3 -> b/3}),
      con Ab : b/3,
      con Bb : a/3 -> b/3,
      val height : b/3 -> int}}
- > New type names: a/4, b/4
  structure Y2 :
  {structure A :
     {datatype a = (a/4,{con Aa : a/4, con Ba : b/4 -> a/4}),
      con Aa : a/4,
      con Ba : b/4 -> a/4,
      val height : a/4 -> int},
   structure B :
     {datatype b = (b/4,{con Ab : b/4, con Bb : a/4 -> b/4}),
      con Ab : b/4,
      con Bb : a/4 -> b/4,
      val height : b/4 -> int}}
- > val test6 = [structure ...] :
  [?a/5 b/5.
    rec ({structure A : {type a = a/5}, structure B : {type b = b/5}},
            {structure A :
               {datatype a = (a/5,{con Aa : a/5, con Ba : b/5 -> a/5}),
                con Aa : a/5,
                con Ba : b/5 -> a/5,
                val height : a/5 -> int},
             structure B :
               {datatype b = (b/5,{con Ab : b/5, con Bb : a/5 -> b/5}),
                con Ab : b/5,
                con Bb : a/5 -> b/5,
                val height : b/5 -> int}})]
- > signature S =
  /\a/5.
    rec ({type a = a/5},
            {datatype a = (a/5,{con C : a/5 -> a/5}), con C : a/5 -> a/5})
- > New type names: a/5
  structure A : {datatype a = (a/5,{con C : a/5 -> a/5}), con C : a/5 -> a/5}
- > New type names: a/6
  structure B : {datatype a = (a/6,{con C : a/6 -> a/6}), con C : a/6 -> a/6}
- > New type names: a/7
  structure C : {datatype a = (a/7,{con C : a/7 -> a/7}), con C : a/7 -> a/7}
- > signature S =
  /\a/8.
    rec ({type ('a, 'b) a = ('a, 'b) a/8},
            {datatype ('a, 'b) a =
               (('a, 'b) a/8,
                {con ('a, 'b) C : ('a, 'b) a/8 -> ('a, 'b) a/8,
                 con ('a, 'b) D : 'a -> ('a, 'b) a/8,
                 con ('a, 'b) E : 'b -> ('a, 'b) a/8}),
             con ('a, 'b) C : ('a, 'b) a/8 -> ('a, 'b) a/8,
             con ('a, 'b) D : 'a -> ('a, 'b) a/8,
             con ('a, 'b) E : 'b -> ('a, 'b) a/8})
- > New type names: a/8
  structure A :
  {datatype ('a, 'b) a =
     (('a, 'b) a/8,
      {con ('a, 'b) C : ('a, 'b) a/8 -> ('a, 'b) a/8,
       con ('a, 'b) D : 'a -> ('a, 'b) a/8,
       con ('a, 'b) E : 'b -> ('a, 'b) a/8}),
   con ('a, 'b) C : ('a, 'b) a/8 -> ('a, 'b) a/8,
   con ('a, 'b) D : 'a -> ('a, 'b) a/8,
   con ('a, 'b) E : 'b -> ('a, 'b) a/8}
- > New type names: a/9
  structure B :
  {datatype ('a, 'b) a =
     (('a, 'b) a/9,
      {con ('a, 'b) C : ('a, 'b) a/9 -> ('a, 'b) a/9,
       con ('a, 'b) D : 'a -> ('a, 'b) a/9,
       con ('a, 'b) E : 'b -> ('a, 'b) a/9}),
   con ('a, 'b) C : ('a, 'b) a/9 -> ('a, 'b) a/9,
   con ('a, 'b) D : 'a -> ('a, 'b) a/9,
   con ('a, 'b) E : 'b -> ('a, 'b) a/9}
- > New type names: a/10
  structure C :
  {datatype ('a, 'b) a =
     (('a, 'b) a/10,
      {con ('a, 'b) C : ('a, 'b) a/10 -> ('a, 'b) a/10,
       con ('a, 'b) D : 'a -> ('a, 'b) a/10,
       con ('a, 'b) E : 'b -> ('a, 'b) a/10}),
   con ('a, 'b) C : ('a, 'b) a/10 -> ('a, 'b) a/10,
   con ('a, 'b) D : 'a -> ('a, 'b) a/10,
   con ('a, 'b) E : 'b -> ('a, 'b) a/10}
- > signature S =
  /\=a/11.
    rec ({datatype ('a, 'b) a =
            (('a, 'b) a/11,
             {con ('a, 'b) C : ('a, 'b) a/11 -> ('a, 'b) a/11,
              con ('a, 'b) D : 'a -> ('a, 'b) a/11,
              con ('a, 'b) E : 'b -> ('a, 'b) a/11}),
          con ('a, 'b) C : ('a, 'b) a/11 -> ('a, 'b) a/11,
          con ('a, 'b) D : 'a -> ('a, 'b) a/11,
          con ('a, 'b) E : 'b -> ('a, 'b) a/11},
            {datatype ('a, 'b) a =
               (('a, 'b) a/11,
                {con ('a, 'b) C : ('a, 'b) a/11 -> ('a, 'b) a/11,
                 con ('a, 'b) D : 'a -> ('a, 'b) a/11,
                 con ('a, 'b) E : 'b -> ('a, 'b) a/11}),
             con ('a, 'b) C : ('a, 'b) a/11 -> ('a, 'b) a/11,
             con ('a, 'b) D : 'a -> ('a, 'b) a/11,
             con ('a, 'b) E : 'b -> ('a, 'b) a/11})
- > New type names: =a/11
  structure A :
  {datatype ('a, 'b) a =
     (('a, 'b) a/11,
      {con ('a, 'b) C : ('a, 'b) a/11 -> ('a, 'b) a/11,
       con ('a, 'b) D : 'a -> ('a, 'b) a/11,
       con ('a, 'b) E : 'b -> ('a, 'b) a/11}),
   con ('a, 'b) C : ('a, 'b) a/11 -> ('a, 'b) a/11,
   con ('a, 'b) D : 'a -> ('a, 'b) a/11,
   con ('a, 'b) E : 'b -> ('a, 'b) a/11}
- > New type names: =a/12
  structure B :
  {datatype ('a, 'b) a =
     (('a, 'b) a/12,
      {con ('a, 'b) C : ('a, 'b) a/12 -> ('a, 'b) a/12,
       con ('a, 'b) D : 'a -> ('a, 'b) a/12,
       con ('a, 'b) E : 'b -> ('a, 'b) a/12}),
   con ('a, 'b) C : ('a, 'b) a/12 -> ('a, 'b) a/12,
   con ('a, 'b) D : 'a -> ('a, 'b) a/12,
   con ('a, 'b) E : 'b -> ('a, 'b) a/12}
- > New type names: =a/13
  structure C :
  {datatype ('a, 'b) a =
     (('a, 'b) a/13,
      {con ('a, 'b) C : ('a, 'b) a/13 -> ('a, 'b) a/13,
       con ('a, 'b) D : 'a -> ('a, 'b) a/13,
       con ('a, 'b) E : 'b -> ('a, 'b) a/13}),
   con ('a, 'b) C : ('a, 'b) a/13 -> ('a, 'b) a/13,
   con ('a, 'b) D : 'a -> ('a, 'b) a/13,
   con ('a, 'b) E : 'b -> ('a, 'b) a/13}
- 
Moscow ML version 2.00 (June 2000)
Enter `quit();' to quit.
- > signature ORDERED = /\T.{type T = T, val leq : T * T -> bool}
- > signature HEAP =
  /\T Heap.
    {structure Elem : {type T = T, val leq : T * T -> bool},
     type Heap = Heap,
     val empty : Heap,
     val isEmpty : Heap -> bool,
     val insert : T * Heap -> Heap,
     val merge : Heap * Heap -> Heap,
     exn Empty : exn,
     val findMin : Heap -> T,
     val deleteMin : Heap -> Heap}
- ! Toplevel input:
! 		      fun leq (H (x, _), H (y, _))= Elem.leq (x, y)
! 		          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
! Warning: pattern matching is not exhaustive

! Toplevel input:
!         else let val (H (y, p1)) = PrimH.findMin p
!                      ^^^^^^^^^^^
! Warning: pattern matching is not exhaustive

> functor Bootstrap :
  (!T.
    {type T = T, val leq : T * T -> bool}->
        ?Heap.
         {structure Elem : {type T = T, val leq : T * T -> bool},
          type Heap = Heap,
          val empty : Heap,
          val isEmpty : Heap -> bool,
          val insert : T * Heap -> Heap,
          val merge : Heap * Heap -> Heap,
          exn Empty : exn,
          val findMin : Heap -> T,
          val deleteMin : Heap -> Heap})->
      !T.
       {type T = T, val leq : T * T -> bool}->
           ?Heap T/1.
            {structure Elem : {type T = T, val leq : T * T -> bool},
             type Heap = T/1,
             exn Empty : exn,
             val deleteMin : T/1 -> T/1,
             val empty : T/1,
             val findMin : T/1 -> T,
             val insert : T * T/1 -> T/1,
             val isEmpty : T/1 -> bool,
             val merge : T/1 * T/1 -> T/1}
- > functor PairingHeap :
  !T.
   {type T = T, val leq : T * T -> bool}->
       ?Heap.
        {structure Elem : {type T = T, val leq : T * T -> bool},
         type Heap = Heap,
         exn Empty : exn,
         val deleteMin : Heap -> Heap,
         val empty : Heap,
         val findMin : Heap -> T,
         val insert : T * Heap -> Heap,
         val isEmpty : Heap -> bool,
         val merge : Heap * Heap -> Heap}
- > structure IntElem : {type T = int, val leq : int * int -> bool}
- > New type names: Heap, T
  structure IntHeap :
  {structure Elem : {type T = int, val leq : int * int -> bool},
   type Heap = T,
   exn Empty : exn,
   val deleteMin : T -> T,
   val empty : T,
   val findMin : T -> int,
   val insert : int * T -> T,
   val isEmpty : T -> bool,
   val merge : T * T -> T}
- > val mkHeap = fn : int list -> T
- > val heap = ?{H}(1, <Heap T>) : T
- > val test1 = true : bool
- > val test2 = true : bool
- > New type names: Heap/1, T/1
  structure SkewHeap :
  {structure Elem : {type T = int, val leq : int * int -> bool},
   type Heap = T/1,
   exn Empty : exn,
   val deleteMin : T/1 -> T/1,
   val empty : T/1,
   val findMin : T/1 -> int,
   val insert : int * T/1 -> T/1,
   val isEmpty : T/1 -> bool,
   val merge : T/1 * T/1 -> T/1}
  functor SkewBinomialHeap :
  !T/2.
   {type T = T/2, val leq : T/2 * T/2 -> bool}->
       ?Tree.
        {structure Elem : {type T = T/2, val leq : T/2 * T/2 -> bool},
         type Heap = Tree list,
         exn Empty : exn,
         val deleteMin : Tree list -> Tree list,
         val empty : Tree list,
         val findMin : Tree list -> T/2,
         val insert : T/2 * Tree list -> Tree list,
         val isEmpty : Tree list -> bool,
         val merge : Tree list * Tree list -> Tree list}
- > val mkHeap = fn : int list -> T/1
- > val heap = ?{H}(1, <Heap/1 T/1>) : T/1
- > val test1 = true : bool
- > val test2 = true : bool
- 
Moscow ML version 2.00 (June 2000)
Enter `quit();' to quit.
- > New type names: =a
  datatype a = (a,{con A : a})
  con A = A : a
- > New type names: =b
  datatype b = (b,{con B : b})
  con B = B : b
- > signature G =
  /\=d.
    {datatype d = (d,{con C : a * b -> d, con D : d}),
     con C : a * b -> d,
     con D : d}
- > signature L =
  /\=d.
    {datatype d = (d,{con C : (a * b) -> d, con D : d}),
     con C : (a * b) -> d,
     con D : d}
- ! Toplevel input:
!   L:G;
!   ^^^
! Signature mismatch: the module does not match the signature ...
! Status mismatch: constructor  C
! is specified as a constructor carrying 2 fields of a tuple in the signature
!   con C : a * b -> d
! but declared as a constructor carrying a tuple with 2 fields in the module
!   con C : (a * b) -> d
! EITHER: edit the specification to match the declaration: 
! - in the signature, enclose the argument type of the constructor in parentheses:
!   change "C of  <ty_1> * <ty_2>"
!   to     "C of (<ty_1> * <ty_2>)"
! OR: edit the declaration to match the specification: 
! - in the module, re-express the argument type of the constructor as a syntactic tuple:
!   change "C of <ty>"
!   to     "C of <ty_1> * <ty_2>"
- ! Toplevel input:
!   LL:functor(L:L)->G;
!   ^^^^^^^^^^^^^^^^^^
! Signature mismatch: the module does not match the signature ...
! Status mismatch: constructor  C of the range
! is specified as a constructor carrying 2 fields of a tuple in the signature
!   con C : a * b -> d
! but declared as a constructor carrying a tuple with 2 fields in the module
!   con C : (a * b) -> d
! EITHER: edit the specification to match the declaration: 
! - in the signature, enclose the argument type of the constructor in parentheses:
!   change "C of  <ty_1> * <ty_2>"
!   to     "C of (<ty_1> * <ty_2>)"
! OR: edit the declaration to match the specification: 
! - in the module, re-express the argument type of the constructor as a syntactic tuple:
!   change "C of <ty>"
!   to     "C of <ty_1> * <ty_2>"
- ! Toplevel input:
!   GL:functor(L:L)->L;
!   ^^^^^^^^^^^^^^^^^^
! Signature mismatch: the module does not match the signature ...
! Status mismatch: constructor  C of the domain
! is specified as a constructor carrying 2 fields of a tuple in the module
!   con C : a * b -> d
! but declared as a constructor carrying a tuple with 2 fields in the signature
!   con C : (a * b) -> d
! EITHER: edit the specification to match the declaration: 
! - in the module, enclose the argument type of the constructor in parentheses:
!   change "C of  <ty_1> * <ty_2>"
!   to     "C of (<ty_1> * <ty_2>)"
! OR: edit the declaration to match the specification: 
! - in the signature, re-express the argument type of the constructor as a syntactic tuple:
!   change "C of <ty>"
!   to     "C of <ty_1> * <ty_2>"
- ! Toplevel input:
!   YL:sig structure Y: G end;
!   ^^^^^^^^^^^^^^^^^^^^^^^^^
! Signature mismatch: the module does not match the signature ...
! Status mismatch: constructor  Y.C
! is specified as a constructor carrying 2 fields of a tuple in the signature
!   con C : a * b -> d
! but declared as a constructor carrying a tuple with 2 fields in the module
!   con C : (a * b) -> d
! EITHER: edit the specification to match the declaration: 
! - in the signature, enclose the argument type of the constructor in parentheses:
!   change "C of  <ty_1> * <ty_2>"
!   to     "C of (<ty_1> * <ty_2>)"
! OR: edit the declaration to match the specification: 
! - in the module, re-express the argument type of the constructor as a syntactic tuple:
!   change "C of <ty>"
!   to     "C of <ty_1> * <ty_2>"
- ! Toplevel input:
!   L_YL:functor(L:L)->sig structure Y: G end;
!   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
! Signature mismatch: the module does not match the signature ...
! Status mismatch: constructor  Y.C of the range
! is specified as a constructor carrying 2 fields of a tuple in the signature
!   con C : a * b -> d
! but declared as a constructor carrying a tuple with 2 fields in the module
!   con C : (a * b) -> d
! EITHER: edit the specification to match the declaration: 
! - in the signature, enclose the argument type of the constructor in parentheses:
!   change "C of  <ty_1> * <ty_2>"
!   to     "C of (<ty_1> * <ty_2>)"
! OR: edit the declaration to match the specification: 
! - in the module, re-express the argument type of the constructor as a syntactic tuple:
!   change "C of <ty>"
!   to     "C of <ty_1> * <ty_2>"
- ! Toplevel input:
!   YG_L:functor(YL:sig structure Y: L end)->L;
!   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
! Signature mismatch: the module does not match the signature ...
! Status mismatch: constructor  Y.C of the domain
! is specified as a constructor carrying 2 fields of a tuple in the module
!   con C : a * b -> d
! but declared as a constructor carrying a tuple with 2 fields in the signature
!   con C : (a * b) -> d
! EITHER: edit the specification to match the declaration: 
! - in the module, enclose the argument type of the constructor in parentheses:
!   change "C of  <ty_1> * <ty_2>"
!   to     "C of (<ty_1> * <ty_2>)"
! OR: edit the declaration to match the specification: 
! - in the signature, re-express the argument type of the constructor as a syntactic tuple:
!   change "C of <ty>"
!   to     "C of <ty_1> * <ty_2>"
- ! Toplevel input:
!   L_YG_L:functor(L:L)->functor(YL:sig structure Y:L end)->L;
!   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
! Signature mismatch: the module does not match the signature ...
! Status mismatch: constructor  Y.C of the domain of the range
! is specified as a constructor carrying 2 fields of a tuple in the module
!   con C : a * b -> d
! but declared as a constructor carrying a tuple with 2 fields in the signature
!   con C : (a * b) -> d
! EITHER: edit the specification to match the declaration: 
! - in the module, enclose the argument type of the constructor in parentheses:
!   change "C of  <ty_1> * <ty_2>"
!   to     "C of (<ty_1> * <ty_2>)"
! OR: edit the declaration to match the specification: 
! - in the signature, re-express the argument type of the constructor as a syntactic tuple:
!   change "C of <ty>"
!   to     "C of <ty_1> * <ty_2>"
- ! Toplevel input:
!   FLYGL:sig functor F: functor(L:L)->functor(YL:sig structure Y:L end)->L end;
!   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
! Signature mismatch: the module does not match the signature ...
! Status mismatch: constructor  Y.C of the domain of the range of F
! is specified as a constructor carrying 2 fields of a tuple in the module
!   con C : a * b -> d
! but declared as a constructor carrying a tuple with 2 fields in the signature
!   con C : (a * b) -> d
! EITHER: edit the specification to match the declaration: 
! - in the module, enclose the argument type of the constructor in parentheses:
!   change "C of  <ty_1> * <ty_2>"
!   to     "C of (<ty_1> * <ty_2>)"
! OR: edit the declaration to match the specification: 
! - in the signature, re-express the argument type of the constructor as a syntactic tuple:
!   change "C of <ty>"
!   to     "C of <ty_1> * <ty_2>"
- > signature G =
  /\=d.
    {datatype d = (d,{con C : {a : a} -> d, con D : d}),
     con C : {a : a} -> d,
     con D : d}
- > signature L =
  /\=d.
    {datatype d = (d,{con C : ({a : a}) -> d, con D : d}),
     con C : ({a : a}) -> d,
     con D : d}
- ! Toplevel input:
!   L:G;
!   ^^^
! Signature mismatch: the module does not match the signature ...
! Status mismatch: constructor  C
! is specified as a constructor carrying one field of a record in the signature
!   con C : {a : a} -> d
! but declared as a constructor carrying a record with one field in the module
!   con C : ({a : a}) -> d
! EITHER: edit the specification to match the declaration: 
! - in the signature, enclose the argument type of the constructor in parentheses:
!   change "C of  {a : <ty_1>}"
!   to     "C of ({a : <ty_1>})"
! OR: edit the declaration to match the specification: 
! - in the module, re-express the argument type of the constructor as a syntactic record:
!   change "C of <ty>"
!   to     "C of {a : <ty_1>}"
- ! Toplevel input:
!   LL:functor(L:L)->G;
!   ^^^^^^^^^^^^^^^^^^
! Signature mismatch: the module does not match the signature ...
! Status mismatch: constructor  C of the range
! is specified as a constructor carrying one field of a record in the signature
!   con C : {a : a} -> d
! but declared as a constructor carrying a record with one field in the module
!   con C : ({a : a}) -> d
! EITHER: edit the specification to match the declaration: 
! - in the signature, enclose the argument type of the constructor in parentheses:
!   change "C of  {a : <ty_1>}"
!   to     "C of ({a : <ty_1>})"
! OR: edit the declaration to match the specification: 
! - in the module, re-express the argument type of the constructor as a syntactic record:
!   change "C of <ty>"
!   to     "C of {a : <ty_1>}"
- ! Toplevel input:
!   GL:functor(L:L)->L;
!   ^^^^^^^^^^^^^^^^^^
! Signature mismatch: the module does not match the signature ...
! Status mismatch: constructor  C of the domain
! is specified as a constructor carrying one field of a record in the module
!   con C : {a : a} -> d
! but declared as a constructor carrying a record with one field in the signature
!   con C : ({a : a}) -> d
! EITHER: edit the specification to match the declaration: 
! - in the module, enclose the argument type of the constructor in parentheses:
!   change "C of  {a : <ty_1>}"
!   to     "C of ({a : <ty_1>})"
! OR: edit the declaration to match the specification: 
! - in the signature, re-express the argument type of the constructor as a syntactic record:
!   change "C of <ty>"
!   to     "C of {a : <ty_1>}"
- ! Toplevel input:
!   YL:sig structure Y: G end;
!   ^^^^^^^^^^^^^^^^^^^^^^^^^
! Signature mismatch: the module does not match the signature ...
! Status mismatch: constructor  Y.C
! is specified as a constructor carrying one field of a record in the signature
!   con C : {a : a} -> d
! but declared as a constructor carrying a record with one field in the module
!   con C : ({a : a}) -> d
! EITHER: edit the specification to match the declaration: 
! - in the signature, enclose the argument type of the constructor in parentheses:
!   change "C of  {a : <ty_1>}"
!   to     "C of ({a : <ty_1>})"
! OR: edit the declaration to match the specification: 
! - in the module, re-express the argument type of the constructor as a syntactic record:
!   change "C of <ty>"
!   to     "C of {a : <ty_1>}"
- ! Toplevel input:
!   L_YL:functor(L:L)->sig structure Y: G end;
!   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
! Signature mismatch: the module does not match the signature ...
! Status mismatch: constructor  Y.C of the range
! is specified as a constructor carrying one field of a record in the signature
!   con C : {a : a} -> d
! but declared as a constructor carrying a record with one field in the module
!   con C : ({a : a}) -> d
! EITHER: edit the specification to match the declaration: 
! - in the signature, enclose the argument type of the constructor in parentheses:
!   change "C of  {a : <ty_1>}"
!   to     "C of ({a : <ty_1>})"
! OR: edit the declaration to match the specification: 
! - in the module, re-express the argument type of the constructor as a syntactic record:
!   change "C of <ty>"
!   to     "C of {a : <ty_1>}"
- ! Toplevel input:
!   YG_L:functor(YL:sig structure Y: L end)->L;
!   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
! Signature mismatch: the module does not match the signature ...
! Status mismatch: constructor  Y.C of the domain
! is specified as a constructor carrying one field of a record in the module
!   con C : {a : a} -> d
! but declared as a constructor carrying a record with one field in the signature
!   con C : ({a : a}) -> d
! EITHER: edit the specification to match the declaration: 
! - in the module, enclose the argument type of the constructor in parentheses:
!   change "C of  {a : <ty_1>}"
!   to     "C of ({a : <ty_1>})"
! OR: edit the declaration to match the specification: 
! - in the signature, re-express the argument type of the constructor as a syntactic record:
!   change "C of <ty>"
!   to     "C of {a : <ty_1>}"
- ! Toplevel input:
!   L_YG_L:functor(L:L)->functor(YL:sig structure Y:L end)->L;
!   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
! Signature mismatch: the module does not match the signature ...
! Status mismatch: constructor  Y.C of the domain of the range
! is specified as a constructor carrying one field of a record in the module
!   con C : {a : a} -> d
! but declared as a constructor carrying a record with one field in the signature
!   con C : ({a : a}) -> d
! EITHER: edit the specification to match the declaration: 
! - in the module, enclose the argument type of the constructor in parentheses:
!   change "C of  {a : <ty_1>}"
!   to     "C of ({a : <ty_1>})"
! OR: edit the declaration to match the specification: 
! - in the signature, re-express the argument type of the constructor as a syntactic record:
!   change "C of <ty>"
!   to     "C of {a : <ty_1>}"
- ! Toplevel input:
!   FLYGL:sig functor F: functor(L:L)->functor(YL:sig structure Y:L end)->L end;
!   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
! Signature mismatch: the module does not match the signature ...
! Status mismatch: constructor  Y.C of the domain of the range of F
! is specified as a constructor carrying one field of a record in the module
!   con C : {a : a} -> d
! but declared as a constructor carrying a record with one field in the signature
!   con C : ({a : a}) -> d
! EITHER: edit the specification to match the declaration: 
! - in the module, enclose the argument type of the constructor in parentheses:
!   change "C of  {a : <ty_1>}"
!   to     "C of ({a : <ty_1>})"
! OR: edit the declaration to match the specification: 
! - in the signature, re-express the argument type of the constructor as a syntactic record:
!   change "C of <ty>"
!   to     "C of {a : <ty_1>}"
- > signature G =
  /\=d.
    {datatype d = (d,{con C : {a : a, b : b} -> d, con D : d}),
     con C : {a : a, b : b} -> d,
     con D : d}
- > signature L =
  /\=d.
    {datatype d = (d,{con C : ({a : a, b : b}) -> d, con D : d}),
     con C : ({a : a, b : b}) -> d,
     con D : d}
- ! Toplevel input:
!   L:G;
!   ^^^
! Signature mismatch: the module does not match the signature ...
! Status mismatch: constructor  C
! is specified as a constructor carrying 2 fields of a record in the signature
!   con C : {a : a, b : b} -> d
! but declared as a constructor carrying a record with 2 fields in the module
!   con C : ({a : a, b : b}) -> d
! EITHER: edit the specification to match the declaration: 
! - in the signature, enclose the argument type of the constructor in parentheses:
!   change "C of  {a : <ty_1>, b : <ty_2>}"
!   to     "C of ({a : <ty_1>, b : <ty_2>})"
! OR: edit the declaration to match the specification: 
! - in the module, re-express the argument type of the constructor as a syntactic record:
!   change "C of <ty>"
!   to     "C of {a : <ty_1>, b : <ty_2>}"
- ! Toplevel input:
!   LL:functor(L:L)->G;
!   ^^^^^^^^^^^^^^^^^^
! Signature mismatch: the module does not match the signature ...
! Status mismatch: constructor  C of the range
! is specified as a constructor carrying 2 fields of a record in the signature
!   con C : {a : a, b : b} -> d
! but declared as a constructor carrying a record with 2 fields in the module
!   con C : ({a : a, b : b}) -> d
! EITHER: edit the specification to match the declaration: 
! - in the signature, enclose the argument type of the constructor in parentheses:
!   change "C of  {a : <ty_1>, b : <ty_2>}"
!   to     "C of ({a : <ty_1>, b : <ty_2>})"
! OR: edit the declaration to match the specification: 
! - in the module, re-express the argument type of the constructor as a syntactic record:
!   change "C of <ty>"
!   to     "C of {a : <ty_1>, b : <ty_2>}"
- ! Toplevel input:
!   GL:functor(L:L)->L;
!   ^^^^^^^^^^^^^^^^^^
! Signature mismatch: the module does not match the signature ...
! Status mismatch: constructor  C of the domain
! is specified as a constructor carrying 2 fields of a record in the module
!   con C : {a : a, b : b} -> d
! but declared as a constructor carrying a record with 2 fields in the signature
!   con C : ({a : a, b : b}) -> d
! EITHER: edit the specification to match the declaration: 
! - in the module, enclose the argument type of the constructor in parentheses:
!   change "C of  {a : <ty_1>, b : <ty_2>}"
!   to     "C of ({a : <ty_1>, b : <ty_2>})"
! OR: edit the declaration to match the specification: 
! - in the signature, re-express the argument type of the constructor as a syntactic record:
!   change "C of <ty>"
!   to     "C of {a : <ty_1>, b : <ty_2>}"
- ! Toplevel input:
!   YL:sig structure Y: G end;
!   ^^^^^^^^^^^^^^^^^^^^^^^^^
! Signature mismatch: the module does not match the signature ...
! Status mismatch: constructor  Y.C
! is specified as a constructor carrying 2 fields of a record in the signature
!   con C : {a : a, b : b} -> d
! but declared as a constructor carrying a record with 2 fields in the module
!   con C : ({a : a, b : b}) -> d
! EITHER: edit the specification to match the declaration: 
! - in the signature, enclose the argument type of the constructor in parentheses:
!   change "C of  {a : <ty_1>, b : <ty_2>}"
!   to     "C of ({a : <ty_1>, b : <ty_2>})"
! OR: edit the declaration to match the specification: 
! - in the module, re-express the argument type of the constructor as a syntactic record:
!   change "C of <ty>"
!   to     "C of {a : <ty_1>, b : <ty_2>}"
- ! Toplevel input:
!   L_YL:functor(L:L)->sig structure Y: G end;
!   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
! Signature mismatch: the module does not match the signature ...
! Status mismatch: constructor  Y.C of the range
! is specified as a constructor carrying 2 fields of a record in the signature
!   con C : {a : a, b : b} -> d
! but declared as a constructor carrying a record with 2 fields in the module
!   con C : ({a : a, b : b}) -> d
! EITHER: edit the specification to match the declaration: 
! - in the signature, enclose the argument type of the constructor in parentheses:
!   change "C of  {a : <ty_1>, b : <ty_2>}"
!   to     "C of ({a : <ty_1>, b : <ty_2>})"
! OR: edit the declaration to match the specification: 
! - in the module, re-express the argument type of the constructor as a syntactic record:
!   change "C of <ty>"
!   to     "C of {a : <ty_1>, b : <ty_2>}"
- ! Toplevel input:
!   YG_L:functor(YL:sig structure Y: L end)->L;
!   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
! Signature mismatch: the module does not match the signature ...
! Status mismatch: constructor  Y.C of the domain
! is specified as a constructor carrying 2 fields of a record in the module
!   con C : {a : a, b : b} -> d
! but declared as a constructor carrying a record with 2 fields in the signature
!   con C : ({a : a, b : b}) -> d
! EITHER: edit the specification to match the declaration: 
! - in the module, enclose the argument type of the constructor in parentheses:
!   change "C of  {a : <ty_1>, b : <ty_2>}"
!   to     "C of ({a : <ty_1>, b : <ty_2>})"
! OR: edit the declaration to match the specification: 
! - in the signature, re-express the argument type of the constructor as a syntactic record:
!   change "C of <ty>"
!   to     "C of {a : <ty_1>, b : <ty_2>}"
- ! Toplevel input:
!   L_YG_L:functor(L:L)->functor(YL:sig structure Y:L end)->L;
!   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
! Signature mismatch: the module does not match the signature ...
! Status mismatch: constructor  Y.C of the domain of the range
! is specified as a constructor carrying 2 fields of a record in the module
!   con C : {a : a, b : b} -> d
! but declared as a constructor carrying a record with 2 fields in the signature
!   con C : ({a : a, b : b}) -> d
! EITHER: edit the specification to match the declaration: 
! - in the module, enclose the argument type of the constructor in parentheses:
!   change "C of  {a : <ty_1>, b : <ty_2>}"
!   to     "C of ({a : <ty_1>, b : <ty_2>})"
! OR: edit the declaration to match the specification: 
! - in the signature, re-express the argument type of the constructor as a syntactic record:
!   change "C of <ty>"
!   to     "C of {a : <ty_1>, b : <ty_2>}"
- ! Toplevel input:
!   FLYGL:sig functor F: functor(L:L)->functor(YL:sig structure Y:L end)->L end;
!   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
! Signature mismatch: the module does not match the signature ...
! Status mismatch: constructor  Y.C of the domain of the range of F
! is specified as a constructor carrying 2 fields of a record in the module
!   con C : {a : a, b : b} -> d
! but declared as a constructor carrying a record with 2 fields in the signature
!   con C : ({a : a, b : b}) -> d
! EITHER: edit the specification to match the declaration: 
! - in the module, enclose the argument type of the constructor in parentheses:
!   change "C of  {a : <ty_1>, b : <ty_2>}"
!   to     "C of ({a : <ty_1>, b : <ty_2>})"
! OR: edit the declaration to match the specification: 
! - in the signature, re-express the argument type of the constructor as a syntactic record:
!   change "C of <ty>"
!   to     "C of {a : <ty_1>, b : <ty_2>}"
- 
Moscow ML version 2.00 (June 2000)
Enter `quit();' to quit.
- > signature S = /\t.{type t = t, type v = t}
- > New type names: t
  structure X : {type t = t, type v = t}
- > New type names: t/1
  structure Y : {type t = t/1, type v = t/1}
- > New type names: t/2
  structure Z : {type t = t/2, type v = t/2}
- > functor F :
  !t/3.{type t = t/3, type v = t/3}->?t/4.{type t = t/4, type v = t/4}
- > functor G :
  !t/3.{type t = t/3, type v = t/3}->?t/4 t/5 t/6.{type t = t/6, type v = t/6}
- > functor H :
  !t/3.{type t = t/3, type v = t/3}->?t/4.{type t = t/4, type v = t/4}
- > signature LR_TABLE =
  /\=pairlist.
    {datatype ('a, 'b) pairlist =
       (('a, 'b) pairlist,
        {con ('a, 'b) EMPTY : ('a, 'b) pairlist,
         con ('a, 'b) PAIR :
           'a * 'b * ('a, 'b) pairlist -> ('a, 'b) pairlist}),
     con ('a, 'b) EMPTY : ('a, 'b) pairlist,
     con ('a, 'b) PAIR : 'a * 'b * ('a, 'b) pairlist -> ('a, 'b) pairlist}
- > signature TOKEN =
  /\=pairlist.
    {structure LrTable :
       {datatype ('a, 'b) pairlist =
          (('a, 'b) pairlist,
           {con ('a, 'b) EMPTY : ('a, 'b) pairlist,
            con ('a, 'b) PAIR :
              'a * 'b * ('a, 'b) pairlist -> ('a, 'b) pairlist}),
        con ('a, 'b) EMPTY : ('a, 'b) pairlist,
        con ('a, 'b) PAIR : 'a * 'b * ('a, 'b) pairlist -> ('a, 'b) pairlist}}
- > signature LR_PARSER =
  /\=pairlist.
    {structure LrTable :
       {datatype ('a, 'b) pairlist =
          (('a, 'b) pairlist,
           {con ('a, 'b) EMPTY : ('a, 'b) pairlist,
            con ('a, 'b) PAIR :
              'a * 'b * ('a, 'b) pairlist -> ('a, 'b) pairlist}),
        con ('a, 'b) EMPTY : ('a, 'b) pairlist,
        con ('a, 'b) PAIR : 'a * 'b * ('a, 'b) pairlist -> ('a, 'b) pairlist},
     structure Token :
       {structure LrTable :
          {datatype ('a, 'b) pairlist =
             (('a, 'b) pairlist,
              {con ('a, 'b) EMPTY : ('a, 'b) pairlist,
               con ('a, 'b) PAIR :
                 'a * 'b * ('a, 'b) pairlist -> ('a, 'b) pairlist}),
           con ('a, 'b) EMPTY : ('a, 'b) pairlist,
           con ('a, 'b) PAIR :
             'a * 'b * ('a, 'b) pairlist -> ('a, 'b) pairlist}}}
- > signature PARSER_DATA =
  /\=pairlist.
    {structure LrTable :
       {datatype ('a, 'b) pairlist =
          (('a, 'b) pairlist,
           {con ('a, 'b) EMPTY : ('a, 'b) pairlist,
            con ('a, 'b) PAIR :
              'a * 'b * ('a, 'b) pairlist -> ('a, 'b) pairlist}),
        con ('a, 'b) EMPTY : ('a, 'b) pairlist,
        con ('a, 'b) PAIR : 'a * 'b * ('a, 'b) pairlist -> ('a, 'b) pairlist},
     structure Token :
       {structure LrTable :
          {datatype ('a, 'b) pairlist =
             (('a, 'b) pairlist,
              {con ('a, 'b) EMPTY : ('a, 'b) pairlist,
               con ('a, 'b) PAIR :
                 'a * 'b * ('a, 'b) pairlist -> ('a, 'b) pairlist}),
           con ('a, 'b) EMPTY : ('a, 'b) pairlist,
           con ('a, 'b) PAIR :
             'a * 'b * ('a, 'b) pairlist -> ('a, 'b) pairlist}}}
- > signature PARSER =
  /\=pairlist.
    {structure Token :
       {structure LrTable :
          {datatype ('a, 'b) pairlist =
             (('a, 'b) pairlist,
              {con ('a, 'b) EMPTY : ('a, 'b) pairlist,
               con ('a, 'b) PAIR :
                 'a * 'b * ('a, 'b) pairlist -> ('a, 'b) pairlist}),
           con ('a, 'b) EMPTY : ('a, 'b) pairlist,
           con ('a, 'b) PAIR :
             'a * 'b * ('a, 'b) pairlist -> ('a, 'b) pairlist}}}
- > functor Join :
  !=pairlist.
   {structure ParserData :
      {structure LrTable :
         {datatype ('a, 'b) pairlist =
            (('a, 'b) pairlist,
             {con ('a, 'b) EMPTY : ('a, 'b) pairlist,
              con ('a, 'b) PAIR :
                'a * 'b * ('a, 'b) pairlist -> ('a, 'b) pairlist}),
          con ('a, 'b) EMPTY : ('a, 'b) pairlist,
          con ('a, 'b) PAIR :
            'a * 'b * ('a, 'b) pairlist -> ('a, 'b) pairlist},
       structure Token :
         {structure LrTable :
            {datatype ('a, 'b) pairlist =
               (('a, 'b) pairlist,
                {con ('a, 'b) EMPTY : ('a, 'b) pairlist,
                 con ('a, 'b) PAIR :
                   'a * 'b * ('a, 'b) pairlist -> ('a, 'b) pairlist}),
             con ('a, 'b) EMPTY : ('a, 'b) pairlist,
             con ('a, 'b) PAIR :
               'a * 'b * ('a, 'b) pairlist -> ('a, 'b) pairlist}}},
    structure LrParser :
      {structure LrTable :
         {datatype ('a, 'b) pairlist =
            (('a, 'b) pairlist,
             {con ('a, 'b) EMPTY : ('a, 'b) pairlist,
              con ('a, 'b) PAIR :
                'a * 'b * ('a, 'b) pairlist -> ('a, 'b) pairlist}),
          con ('a, 'b) EMPTY : ('a, 'b) pairlist,
          con ('a, 'b) PAIR :
            'a * 'b * ('a, 'b) pairlist -> ('a, 'b) pairlist},
       structure Token :
         {structure LrTable :
            {datatype ('a, 'b) pairlist =
               (('a, 'b) pairlist,
                {con ('a, 'b) EMPTY : ('a, 'b) pairlist,
                 con ('a, 'b) PAIR :
                   'a * 'b * ('a, 'b) pairlist -> ('a, 'b) pairlist}),
             con ('a, 'b) EMPTY : ('a, 'b) pairlist,
             con ('a, 'b) PAIR :
               'a * 'b * ('a, 'b) pairlist -> ('a, 'b) pairlist}}}}->
       {structure Token :
          {structure LrTable :
             {datatype ('a, 'b) pairlist =
                (('a, 'b) pairlist,
                 {con ('a, 'b) EMPTY : ('a, 'b) pairlist,
                  con ('a, 'b) PAIR :
                    'a * 'b * ('a, 'b) pairlist -> ('a, 'b) pairlist}),
              con ('a, 'b) EMPTY : ('a, 'b) pairlist,
              con ('a, 'b) PAIR :
                'a * 'b * ('a, 'b) pairlist -> ('a, 'b) pairlist}}}
- > New type names: =pairlist
  structure LrTable :
  {datatype ('a, 'b) pairlist =
     (('a, 'b) pairlist,
      {con ('a, 'b) EMPTY : ('a, 'b) pairlist,
       con ('a, 'b) PAIR : 'a * 'b * ('a, 'b) pairlist -> ('a, 'b) pairlist}),
   con ('a, 'b) EMPTY : ('a, 'b) pairlist,
   con ('a, 'b) PAIR : 'a * 'b * ('a, 'b) pairlist -> ('a, 'b) pairlist}
- > New type names: =pairlist/1
  structure LrParser :
  {structure LrTable :
     {datatype ('a, 'b) pairlist =
        (('a, 'b) pairlist/1,
         {con ('a, 'b) EMPTY : ('a, 'b) pairlist/1,
          con ('a, 'b) PAIR :
            'a * 'b * ('a, 'b) pairlist/1 -> ('a, 'b) pairlist/1}),
      con ('a, 'b) EMPTY : ('a, 'b) pairlist/1,
      con ('a, 'b) PAIR :
        'a * 'b * ('a, 'b) pairlist/1 -> ('a, 'b) pairlist/1},
   structure Token :
     {structure LrTable :
        {datatype ('a, 'b) pairlist =
           (('a, 'b) pairlist/1,
            {con ('a, 'b) EMPTY : ('a, 'b) pairlist/1,
             con ('a, 'b) PAIR :
               'a * 'b * ('a, 'b) pairlist/1 -> ('a, 'b) pairlist/1}),
         con ('a, 'b) EMPTY : ('a, 'b) pairlist/1,
         con ('a, 'b) PAIR :
           'a * 'b * ('a, 'b) pairlist/1 -> ('a, 'b) pairlist/1}}}
- > signature Fol_LRVALS =
  /\=pairlist/2.
    {structure ParserData :
       {structure LrTable :
          {datatype ('a, 'b) pairlist =
             (('a, 'b) pairlist/2,
              {con ('a, 'b) EMPTY : ('a, 'b) pairlist/2,
               con ('a, 'b) PAIR :
                 'a * 'b * ('a, 'b) pairlist/2 -> ('a, 'b) pairlist/2}),
           con ('a, 'b) EMPTY : ('a, 'b) pairlist/2,
           con ('a, 'b) PAIR :
             'a * 'b * ('a, 'b) pairlist/2 -> ('a, 'b) pairlist/2},
        structure Token :
          {structure LrTable :
             {datatype ('a, 'b) pairlist =
                (('a, 'b) pairlist/2,
                 {con ('a, 'b) EMPTY : ('a, 'b) pairlist/2,
                  con ('a, 'b) PAIR :
                    'a * 'b * ('a, 'b) pairlist/2 -> ('a, 'b) pairlist/2}),
              con ('a, 'b) EMPTY : ('a, 'b) pairlist/2,
              con ('a, 'b) PAIR :
                'a * 'b * ('a, 'b) pairlist/2 -> ('a, 'b) pairlist/2}}}}
- > functor FolLrValsFun :
  !=pairlist/2.
   {structure Token :
      {structure LrTable :
         {datatype ('a, 'b) pairlist =
            (('a, 'b) pairlist/2,
             {con ('a, 'b) EMPTY : ('a, 'b) pairlist/2,
              con ('a, 'b) PAIR :
                'a * 'b * ('a, 'b) pairlist/2 -> ('a, 'b) pairlist/2}),
          con ('a, 'b) EMPTY : ('a, 'b) pairlist/2,
          con ('a, 'b) PAIR :
            'a * 'b * ('a, 'b) pairlist/2 -> ('a, 'b) pairlist/2}}}->
       {structure ParserData :
          {structure LrTable :
             {datatype ('a, 'b) pairlist =
                (('a, 'b) pairlist/2,
                 {con ('a, 'b) EMPTY : ('a, 'b) pairlist/2,
                  con ('a, 'b) PAIR :
                    'a * 'b * ('a, 'b) pairlist/2 -> ('a, 'b) pairlist/2}),
              con ('a, 'b) EMPTY : ('a, 'b) pairlist/2,
              con ('a, 'b) PAIR :
                'a * 'b * ('a, 'b) pairlist/2 -> ('a, 'b) pairlist/2},
           structure Token :
             {structure LrTable :
                {datatype ('a, 'b) pairlist =
                   (('a, 'b) pairlist/2,
                    {con ('a, 'b) EMPTY : ('a, 'b) pairlist/2,
                     con ('a, 'b) PAIR :
                       'a * 'b * ('a, 'b) pairlist/2 -> ('a, 'b) pairlist/2}),
                 con ('a, 'b) EMPTY : ('a, 'b) pairlist/2,
                 con ('a, 'b) PAIR :
                   'a * 'b * ('a, 'b) pairlist/2 -> ('a, 'b) pairlist/2}}}}
- > structure FolLrVals :
  {structure ParserData :
     {structure LrTable :
        {datatype ('a, 'b) pairlist =
           (('a, 'b) pairlist/1,
            {con ('a, 'b) EMPTY : ('a, 'b) pairlist/1,
             con ('a, 'b) PAIR :
               'a * 'b * ('a, 'b) pairlist/1 -> ('a, 'b) pairlist/1}),
         con ('a, 'b) EMPTY : ('a, 'b) pairlist/1,
         con ('a, 'b) PAIR :
           'a * 'b * ('a, 'b) pairlist/1 -> ('a, 'b) pairlist/1},
      structure Token :
        {structure LrTable :
           {datatype ('a, 'b) pairlist =
              (('a, 'b) pairlist/1,
               {con ('a, 'b) EMPTY : ('a, 'b) pairlist/1,
                con ('a, 'b) PAIR :
                  'a * 'b * ('a, 'b) pairlist/1 -> ('a, 'b) pairlist/1}),
            con ('a, 'b) EMPTY : ('a, 'b) pairlist/1,
            con ('a, 'b) PAIR :
              'a * 'b * ('a, 'b) pairlist/1 -> ('a, 'b) pairlist/1}}}}
- > structure FolParser :
  {structure Token :
     {structure LrTable :
        {datatype ('a, 'b) pairlist =
           (('a, 'b) pairlist/1,
            {con ('a, 'b) EMPTY : ('a, 'b) pairlist/1,
             con ('a, 'b) PAIR :
               'a * 'b * ('a, 'b) pairlist/1 -> ('a, 'b) pairlist/1}),
         con ('a, 'b) EMPTY : ('a, 'b) pairlist/1,
         con ('a, 'b) PAIR :
           'a * 'b * ('a, 'b) pairlist/1 -> ('a, 'b) pairlist/1}}}
- 
Moscow ML version 2.00 (June 2000)
Enter `quit();' to quit.
- > New type names: =t
  datatype t = (t,{con C : t -> t})
  con C = fn : t -> t
- > New type names: =u
  datatype 'a u = ('a u,{con 'a D : 'a -> 'a u})
  con 'a D = fn : 'a -> 'a u
- > New type names: =v
  datatype ('a, 'b) v = (('a, 'b) v,{con ('a, 'b) E : 'a * 'b -> ('a, 'b) v})
  con ('a, 'b) E = fn : 'a * 'b -> ('a, 'b) v
- > signature S =
  /\=t/1 =u/1 =v/1.
    {datatype t = (t/1,{con C : t/1 -> t/1}),
     con C : t/1 -> t/1,
     datatype 'a u = ('a u/1,{con 'a D : 'a -> 'a u/1}),
     con 'a D : 'a -> 'a u/1,
     datatype ('a, 'b) v =
       (('a, 'b) v/1,{con ('a, 'b) E : 'a * 'b -> ('a, 'b) v/1}),
     con ('a, 'b) E : 'a * 'b -> ('a, 'b) v/1}
- > signature Ok =
  {datatype t = (t,{con C : t -> t}),
   con C : t -> t,
   datatype 'a u = ('a u,{con 'a D : 'a -> 'a u}),
   con 'a D : 'a -> 'a u,
   datatype ('a, 'b) v = (('a, 'b) v,{con ('a, 'b) E : 'a * 'b -> ('a, 'b) v}),
   con ('a, 'b) E : 'a * 'b -> ('a, 'b) v}
- ! Toplevel input:
! signature FailWeirdButValidSML = S where type t = int;
!                                          ^^^^^^^^^^^^
! Illegal where constraint: the type constructor t
! is specified as a datatype
! but its constraint is not a datatype
- ! Toplevel input:
! signature Fail = S where type t = int * int;
!                          ^^^^^^^^^^^^^^^^^^
! Illegal where constraint: the type constructor t
! is specified as a datatype
! but its constraint is not a datatype
- ! Toplevel input:
! signature FailWeirdButValidSML = S where type 'a u = 'a list;
!                                          ^^^^^^^^^^^^^^^^^^^
! Illegal where constraint: the datatype constructor u
! cannot be constrained in this way because 
! the constraint's constructor environment does not match the specification's constructor environment
! Datatype mismatch: type constructor u
! is specified as the datatype
!   datatype 'a u = ('a list,{con 'a D : 'a -> 'a list})
! in the specification
! but declared as the different datatype
!   datatype 'a u =
  ('a list,{con 'a nil : 'a list, con 'a :: : 'a * 'a list -> 'a list})
! in the constraint
! The datatypes should agree on the names and the order of value constructors
- ! Toplevel input:
! signature Fail = S where type 'a u = int u;
!                          ^^^^^^^^^^^^^^^^^
! Illegal where constraint: the type constructor u
! is specified as a datatype
! but its constraint is not a datatype
- ! Toplevel input:
! signature Fail = S where type 'a u = 'a * 'a;
!                          ^^^^^^^^^^^^^^^^^^^
! Illegal where constraint: the type constructor u
! is specified as a datatype
! but its constraint is not a datatype
- > New type names: =w
  datatype ('a, 'b) w = (('a, 'b) w,{con ('a, 'b) W : ('a, 'b) w})
  con ('a, 'b) W = W : ('a, 'b) w
- > type ('a, 'b, 'c) x = ('a, 'b) w
- > type ('a, 'b) y = ('a, 'a) w
- ! Toplevel input:
! signature FailWeirdButValidSML = S where type ('a,'b) v = ('a,'b) w;
!                                          ^^^^^^^^^^^^^^^^^^^^^^^^^^
! Illegal where constraint: the datatype constructor v
! cannot be constrained in this way because 
! the constraint's constructor environment does not match the specification's constructor environment
! Datatype mismatch: type constructor v
! is specified as the datatype
!   datatype ('a, 'b) v = (('a, 'b) w,{con ('a, 'b) E : 'a * 'b -> ('a, 'b) w})
! in the specification
! but declared as the different datatype
!   datatype ('a, 'b) v = (('a, 'b) w,{con ('a, 'b) W : ('a, 'b) w})
! in the constraint
! The datatypes should agree on the names and the order of value constructors
- ! Toplevel input:
! signature FailWeirdButValidSML = S where type ('a,'b) v = ('a,'b,int) x;
!                                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
! Illegal where constraint: the datatype constructor v
! cannot be constrained in this way because 
! the constraint's constructor environment does not match the specification's constructor environment
! Datatype mismatch: type constructor v
! is specified as the datatype
!   datatype ('a, 'b) v = (('a, 'b) w,{con ('a, 'b) E : 'a * 'b -> ('a, 'b) w})
! in the specification
! but declared as the different datatype
!   datatype ('a, 'b) v = (('a, 'b) w,{con ('a, 'b) W : ('a, 'b) w})
! in the constraint
! The datatypes should agree on the names and the order of value constructors
- ! Toplevel input:
! signature Fail = S where type ('a,'b) v = ('a,'a)w;
!                          ^^^^^^^^^^^^^^^^^^^^^^^^^
! Illegal where constraint: the type constructor v
! is specified as a datatype
! but its constraint is not a datatype
- ! Toplevel input:
! signature Fail = S where type ('a,'b) v = ('a,'a)w;
!                          ^^^^^^^^^^^^^^^^^^^^^^^^^
! Illegal where constraint: the type constructor v
! is specified as a datatype
! but its constraint is not a datatype
- ! Toplevel input:
! signature Fail = S where type ('a,'b) v = ('a,'b)y;
!                          ^^^^^^^^^^^^^^^^^^^^^^^^^
! Illegal where constraint: the type constructor v
! is specified as a datatype
! but its constraint is not a datatype
- > New type names: =t/1
  datatype t = (t/1,{con C : bool -> t/1, con D : int -> t/1})
  con C = fn : bool -> t/1
  con D = fn : int -> t/1
- ! Toplevel input:
! signature Fail = sig datatype u = C of bool end where type u = t;
!                                                       ^^^^^^^^^^
! Illegal where constraint: the datatype constructor u
! cannot be constrained in this way because 
! the constraint's constructor environment does not match the specification's constructor environment
! Datatype mismatch: type constructor u
! is specified as the datatype
!   datatype u = (t/1,{con C : bool -> t/1})
! in the specification
! but declared as the different datatype
!   datatype u = (t/1,{con C : bool -> t/1, con D : int -> t/1})
! in the constraint
! The datatypes should agree on the names and the order of value constructors
- ! Toplevel input:
! signature Fail = sig datatype u = C of bool | D of bool end where type u = t;
!                                                                   ^^^^^^^^^^
! Illegal where constraint: the datatype constructor u
! cannot be constrained in this way because 
! the constraint's constructor environment does not match the specification's constructor environment
! Scheme mismatch: value identifier D
! is specified with type scheme 
!   con D : bool -> t/1
! in the specification
! but its declaration has the unrelated type scheme 
!   con D : int -> t/1
! in the constraint
! The declared type scheme should be at least as general as the specified type scheme
- ! Toplevel input:
! signature Fail = sig datatype u = C of bool | D of int end where type u = int;
!                                                                  ^^^^^^^^^^^^
! Illegal where constraint: the type constructor u
! is specified as a datatype
! but its constraint is not a datatype
- > signature OK =
  {datatype u = (t/1,{con C : bool -> t/1, con D : int -> t/1}),
   con C : bool -> t/1,
   con D : int -> t/1}
- > type s = t/1
- ! Toplevel input:
! signature Fail = sig datatype u = C of bool end where type u = s;
!                                                       ^^^^^^^^^^
! Illegal where constraint: the datatype constructor u
! cannot be constrained in this way because 
! the constraint's constructor environment does not match the specification's constructor environment
! Datatype mismatch: type constructor u
! is specified as the datatype
!   datatype u = (t/1,{con C : bool -> t/1})
! in the specification
! but declared as the different datatype
!   datatype u = (t/1,{con C : bool -> t/1, con D : int -> t/1})
! in the constraint
! The datatypes should agree on the names and the order of value constructors
- ! Toplevel input:
! signature Fail = sig datatype u = C of bool | D of bool end where type u = s;
!                                                                   ^^^^^^^^^^
! Illegal where constraint: the datatype constructor u
! cannot be constrained in this way because 
! the constraint's constructor environment does not match the specification's constructor environment
! Scheme mismatch: value identifier D
! is specified with type scheme 
!   con D : bool -> t/1
! in the specification
! but its declaration has the unrelated type scheme 
!   con D : int -> t/1
! in the constraint
! The declared type scheme should be at least as general as the specified type scheme
- > signature OK =
  {datatype u = (t/1,{con C : bool -> t/1, con D : int -> t/1}),
   con C : bool -> t/1,
   con D : int -> t/1}
- ! Toplevel input:
! signature Fail = sig datatype u = C of bool type v = u end where type v = t;
!                                                                  ^^^^^^^^^^
! Illegal where constraint: the datatype constructor v
! cannot be constrained in this way because 
! the constraint's constructor environment does not match the specification's constructor environment
! Datatype mismatch: type constructor v
! is specified as the datatype
!   datatype v = (t/1,{con C : bool -> t/1})
! in the specification
! but declared as the different datatype
!   datatype v = (t/1,{con C : bool -> t/1, con D : int -> t/1})
! in the constraint
! The datatypes should agree on the names and the order of value constructors
- ! Toplevel input:
! signature Fail = sig datatype u = C of bool | D of bool type v = u end where type v = t;
!                                                                              ^^^^^^^^^^
! Illegal where constraint: the datatype constructor v
! cannot be constrained in this way because 
! the constraint's constructor environment does not match the specification's constructor environment
! Scheme mismatch: value identifier D
! is specified with type scheme 
!   con D : bool -> t/1
! in the specification
! but its declaration has the unrelated type scheme 
!   con D : int -> t/1
! in the constraint
! The declared type scheme should be at least as general as the specified type scheme
- > signature OK =
  {datatype u = (u/1,{con C : bool -> u/1, con D : int -> u/1}),
   con C : bool -> u/1,
   con D : int -> u/1,
   type v = u/1}
- ! Toplevel input:
!       signature Fail = sig datatype u = C of bool end where type u = t;
!                                                             ^^^^^^^^^^
! Illegal where constraint: the datatype constructor u
! cannot be constrained in this way because 
! the constraint's constructor environment does not match the specification's constructor environment
! Scheme mismatch: value identifier C
! is specified with type scheme 
!   con C : bool -> t/2
! in the specification
! but its declaration has the unrelated type scheme 
!   con C : int -> t/2
! in the constraint
! The declared type scheme should be at least as general as the specified type scheme
- 
Moscow ML version 2.00 (June 2000)
Enter `quit();' to quit.
[opening file "test.sml"]
> structure Real :
  {type real = real,
   val != : real * real -> bool,
   val * : real * real -> real,
   val + : real * real -> real,
   val - : real * real -> real,
   val / : real * real -> real,
   val < : real * real -> bool,
   val <= : real * real -> bool,
   val == : real * real -> bool,
   val > : real * real -> bool,
   val >= : real * real -> bool,
   val ?= : real * real -> bool,
   exn Div : exn,
   exn Overflow : exn,
   val abs : real -> real,
   val ceil : real -> int,
   val compare : real * real -> order,
   val floor : real -> int,
   val fmt : realfmt -> real -> string,
   val fromDefault : real -> real,
   val fromInt : int -> real,
   val fromString : string -> real option,
   val max : real * real -> real,
   val min : real * real -> real,
   val round : real -> int,
   val sameSign : real * real -> bool,
   val 'a scan : ('a -> (char * 'a) option) -> 'a -> (real * 'a) option,
   val sign : real -> int,
   val toDefault : real -> real,
   val toString : real -> string,
   val trunc : real -> int,
   val ~ : real -> real}
[opening file "sample2.sml"]
> val henryV =
    {born = 1387, crowned = 1413, died = 1422, name = "Henry V",
     quote = "Bid them achieve me and then sell my bones"} :
  {born : int, crowned : int, died : int, name : string, quote : string}
> val henryVI =
    {born = 1421, crowned = 1422, died = 1471, name = "Henry VI",
     quote = "Weep, wretched man, I'll aid thee tear for tear."} :
  {born : int, crowned : int, died : int, name : string, quote : string}
> val richardIII =
    {born = 1452, crowned = 1483, died = 1485, name = "Richard III",
     quote = "Plots have I laid, inductions dangerous..."} :
  {born : int, crowned : int, died : int, name : string, quote : string}
> type king =
  {born : int, crowned : int, died : int, name : string, quote : string}
> val power = fn : real * int -> real
> val naive_fib = fn : int -> int
> val nextfib = fn : int * int -> int * int
> val fibpair = fn : int -> int * int
> val itfib = fn : int * int * int -> int
> val fib = fn : int -> int
> val findroot = fn : real * real * real -> real
> val sqroot = fn : real -> real
> val sqroot = fn : real -> real
> val pos = fn : real -> real
  val neg = fn : real -> real
> val piapprox = fn : int -> real
> structure Complex :
  {type t = real * real,
   val diff : (real * real) * (real * real) -> real * real,
   val prod : (real * real) * (real * real) -> real * real,
   val quo : (real * real) * (real * real) -> real * real,
   val recip : real * real -> real * real,
   val sum : (real * real) * (real * real) -> real * real,
   val zero : real * real}
> signature ARITH =
  /\t.
    {type t = t,
     val zero : t,
     val sum : t * t -> t,
     val diff : t * t -> t,
     val prod : t * t -> t,
     val quo : t * t -> t}
[closing file "sample2.sml"]
> val it = () : unit
[opening file "sample3.sml"]
File "sample3.sml", line 27-30, characters 4-178:
! ....change (coinvals, 0)         = []
!   | change (c::coinvals, amount) =
!       if amount<c then change(coinvals, amount)
!                   else c :: change(c::coinvals, amount-c).
! Warning: pattern matching is not exhaustive

> val change = fn : int list * int -> int list
> val gb_coins = [50, 20, 10, 5, 2, 1] : int list
  val us_coins = [25, 10, 5, 1] : int list
> val allChange = fn : int list * int list * int -> int list list
File "sample3.sml", line 46-48, characters 4-103:
! ....bincarry (0, ps) = ps
!   | bincarry (1, []) = [1]
!   | bincarry (1, p::ps) = (1-p) :: bincarry(p, ps).
! Warning: pattern matching is not exhaustive

> val bincarry = fn : int * int list -> int list
> val binsum = fn : int * int list * int list -> int list
File "sample3.sml", line 57-59, characters 4-127:
! ....binprod ([], _) = []
!   | binprod (0::ps, qs) = 0::binprod(ps,qs)
!   | binprod (1::ps, qs) = binsum(0, qs, 0::binprod(ps,qs)).
! Warning: pattern matching is not exhaustive

> val binprod = fn : int list * int list -> int list
File "sample3.sml", line 64-65, characters 4-71:
! ....headcol []    = []
!   | headcol ((x::_) :: rows) = x :: headcol rows.
! Warning: pattern matching is not exhaustive

> val 'a headcol = fn : 'a list list -> 'a list
File "sample3.sml", line 67-68, characters 4-76:
! ....tailcols []    = []
!   | tailcols ((_::xs) :: rows) = xs :: tailcols rows.
! Warning: pattern matching is not exhaustive

> val 'a tailcols = fn : 'a list list -> 'a list list
> val 'a transp = fn : 'a list list -> 'a list list
File "sample3.sml", line 77-78, characters 4-73:
! ....dotprod([], []) = 0.0
!   | dotprod(x::xs,y::ys) = x*y + dotprod(xs,ys).
! Warning: pattern matching is not exhaustive

> val dotprod = fn : real list * real list -> real
> val rowprod = fn : real list * real list list -> real list
> val rowlistprod = fn : real list list * real list list -> real list list
> val matprod = fn : real list list * real list list -> real list list
File "sample3.sml", line 94-98, characters 4-172:
! ....pivotrow [row] = row : real list
!   | pivotrow (row1::row2::rows) =
!       if abs(hd row1) >= abs(hd row2)
!       then pivotrow(row1::rows)
!       else pivotrow(row2::rows).
! Warning: pattern matching is not exhaustive

> val pivotrow = fn : real list list -> real list
> val delrow = fn : real * real list list -> real list list
> val scalarprod = fn : real * real list -> real list
File "sample3.sml", line 109-110, characters 4-93:
! ....vectorsum ([], []) = [] : real list
!   | vectorsum (x::xs,y::ys) = x+y :: vectorsum(xs,ys).
! Warning: pattern matching is not exhaustive

> val vectorsum = fn : real list * real list -> real list
File "sample3.sml", line 115-118, characters 14-159:
! ..............elimcol [] = []
!             | elimcol ((x::xs)::rows) =
!                   vectorsum(xs, scalarprod(~x/p, prow))
!                   :: elimcol rows
! Warning: pattern matching is not exhaustive

File "sample3.sml", line 114, characters 14-21:
!       let val p::prow = pivotrow rows
!               ^^^^^^^
! Warning: pattern matching is not exhaustive

> val gausselim = fn : real list list -> real list list
File "sample3.sml", line 122-125, characters 4-139:
! ....solutions [] = [~1.0]
!   | solutions((x::xs)::rows) =
!       let val solns = solutions rows
!       in ~(dotprod(solns,xs)/x) :: solns  end.
! Warning: pattern matching is not exhaustive

> val solutions = fn : real list list -> real list
> val squares = fn : int -> (int * int) list
File "sample3.sml", line 153-156, characters 14-174:
! ..............swap [x] = y::x::ys
!             | swap (x::xk::xs) =          (*x >= xk *)
!                 if xk>y then x::swap(xk::xs)
!                 else (y::xk::xs)@(x::ys)
! Warning: pattern matching is not exhaustive

File "sample3.sml", line 150-158, characters 4-409:
! ....next(xlist, y::ys) : int list =
!     if hd xlist <= y then  next(y::xlist, ys)  (*still increasing*)
!     else  (*swap y with greatest xk such that x>=xk>y *)
!       let fun swap [x] = y::x::ys
!             | swap (x::xk::xs) =          (*x >= xk *)
!                 if xk>y then x::swap(xk::xs)
!                 else (y::xk::xs)@(x::ys)
!                          (* x > y >= xk >= xs *)
!       in swap(xlist) end.
! Warning: pattern matching is not exhaustive

> val next = fn : int list * int list -> int list
File "sample3.sml", line 160, characters 4-36:
! fun nextperm (y::ys) = next([y], ys);
!     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
! Warning: pattern matching is not exhaustive

> val nextperm = fn : int list -> int list
> infix 0 mem
> val ''a mem = fn : ''a * ''a list -> bool
> val ''a newmem = fn : ''a * ''a list -> ''a list
> val ''a union = fn : ''a list * ''a list -> ''a list
> val ''a inter = fn : ''a list * ''a list -> ''a list
> val 'a powset = fn : 'a list * 'a list -> 'a list list
> val ('a, 'b) cartprod = fn : 'a list * 'b list -> ('a * 'b) list
> val (''a, 'b) nexts = fn : ''a * (''a * 'b) list -> 'b list
> val ''a depthf = fn : ''a list * (''a * ''a) list * ''a list -> ''a list
> val ''a depth = fn : ''a list * (''a * ''a) list * ''a list -> ''a list
> val ''a topsort = fn : (''a * ''a) list -> ''a list
> val ''a pathsort = fn : (''a * ''a) list -> ''a list
> val ('a, 'b) newvisit = fn : 'a * ('a list * 'b) -> 'a list * 'b
> val ''a cyclesort = fn : (''a * ''a) list -> ''a list * ''a list
> val nextrandom = fn : real -> real
  val truncto = fn : int -> real -> int
> val randlist = fn : int * real * real list -> real * real list
> val ins = fn : real * real list -> real list
> val insort = fn : real list -> real list
> val quick = fn : real list -> real list
> val merge = fn : real list * real list -> real list
> val tmergesort = fn : real list -> real list
> val tmergesort' = fn : real list -> real list
File "sample3.sml", line 317-320, characters 4-146:
! ....mergepairs([l], k) = [l]
!   | mergepairs(l1::l2::ls, k) =
!       if k mod 2 = 1 then l1::l2::ls
!       else mergepairs(merge(l1,l2)::ls, k div 2).
! Warning: pattern matching is not exhaustive

> val mergepairs = fn : real list list * int -> real list list
> val sorting = fn : real list * real list list * int -> real list
> val sort = fn : real list -> real list
> val nextrun = fn : real list * real list -> real list * real list
> val samsorting = fn : real list * real list list * int -> real list
> val samsort = fn : real list -> real list
> nonfix rem
File "sample3.sml", line 381-387, characters 6-265:
! ......quorem (ts, (n,b)::us) =
!     let fun dividing ([],        qs) = (rev qs, [])
! 	  | dividing ((m,a)::ts, qs) =
! 	      if m<n then (rev qs, (m,a)::ts)
! 	      else dividing (sum (ts, termprod ((m-n, ~a/b), us)),
! 			(m-n, a/b) :: qs)
!     in  dividing (ts, [])  end.
! Warning: pattern matching is not exhaustive

> structure Poly :
  {type t = (int * real) list,
   val gcd : (int * real) list * (int * real) list -> (int * real) list,
   val prod : (int * real) list * (int * real) list -> (int * real) list,
   val quo : (int * real) list * (int * real) list -> (int * real) list,
   val quorem :
     (int * real) list * (int * real) list ->
     (int * real) list * (int * real) list,
   val rem : (int * real) list * (int * real) list -> (int * real) list,
   val sum : (int * real) list * (int * real) list -> (int * real) list,
   val termprod : (int * real) * (int * real) list -> (int * real) list,
   val 'a zero : 'a list}
[closing file "sample3.sml"]
> val it = () : unit
[opening file "sample4.sml"]
> New type names: =person
  datatype person =
  (person,
   {con King : person,
    con Knight : string -> person,
    con Peasant : string -> person,
    con Peer : string * string * int -> person})
  con King = King : person
  con Knight = fn : string -> person
  con Peasant = fn : string -> person
  con Peer = fn : string * string * int -> person
> val title = fn : person -> string
> val sirs = fn : person list -> string list
> val superior = fn : person * person -> bool
> New type names: =degree
  datatype degree =
  (degree,
   {con Baron : degree,
    con Duke : degree,
    con Earl : degree,
    con Marquis : degree,
    con Viscount : degree})
  con Baron = Baron : degree
  con Duke = Duke : degree
  con Earl = Earl : degree
  con Marquis = Marquis : degree
  con Viscount = Viscount : degree
> val lady = fn : degree -> string
> exn Change = Change : exn
> val backChange = fn : int list * int -> int list
> New type names: =tree
  datatype 'a tree =
  ('a tree,
   {con 'a Br : 'a * 'a tree * 'a tree -> 'a tree, con 'a Lf : 'a tree})
  con 'a Br = fn : 'a * 'a tree * 'a tree -> 'a tree
  con 'a Lf = Lf : 'a tree
File "sample4.sml", line 106, characters 9-14:
! 	    val y::ys = List.drop(xs,k)
! 	        ^^^^^
! Warning: pattern matching is not exhaustive

> structure Tree :
  {val 'a balin : 'a list -> 'a tree,
   val 'a balpost : 'a list -> 'a tree,
   val 'a balpre : 'a list -> 'a tree,
   val 'a depth : 'a tree -> int,
   val 'a inord : 'a tree * 'a list -> 'a list,
   val 'a postord : 'a tree * 'a list -> 'a list,
   val 'a preord : 'a tree * 'a list -> 'a list,
   val 'a reflect : 'a tree -> 'a tree,
   val 'a size : 'a tree -> int}
> signature DICTIONARY =
  /\key t.
    {type key = key,
     type 'a t = 'a t,
     exn E : key -> exn,
     val 'a empty : 'a t,
     val 'a lookup : 'a t * key -> 'a,
     val 'a insert : 'a t * key * 'a -> 'a t,
     val 'a update : 'a t * key * 'a -> 'a t}
> structure Dict :
  {type key = string,
   type 'a t = (string * 'a) tree,
   exn E : string -> exn,
   val 'a empty : (string * 'a) tree,
   val 'a insert : (string * 'a) tree * string * 'a -> (string * 'a) tree,
   val 'a lookup : (string * 'a) tree * string -> 'a,
   val 'a update : (string * 'a) tree * string * 'a -> (string * 'a) tree}
File "sample4.sml", line 195-197, characters 6-161:
! ......lorem Lf = raise Size
!     | lorem (Br(_,Lf,Lf)) = Lf 	(*No evens, therefore no odds either*)
!     | lorem (Br(_, t1 as Br(v,_,_), t2)) = Br(v, t2, lorem t1).
! Warning: pattern matching is not exhaustive

> structure Braun :
  {val 'a delete : 'a tree * int -> 'a tree,
   val 'a loext : 'a tree * 'a -> 'a tree,
   val 'a lorem : 'a tree -> 'a tree,
   val 'a sub : 'a tree * int -> 'a,
   val 'a update : 'a tree * int * 'a -> 'a tree}
> signature FLEXARRAY =
  /\array.
    {type 'a array = 'a array,
     val 'a empty : 'a array,
     val 'a length : 'a array -> int,
     val 'a sub : 'a array * int -> 'a,
     val 'a update : 'a array * int * 'a -> 'a array,
     val 'a loext : 'a array * 'a -> 'a array,
     val 'a lorem : 'a array -> 'a array,
     val 'a hiext : 'a array * 'a -> 'a array,
     val 'a hirem : 'a array -> 'a array}
> New type names: =array
  structure Flex :
  {type 'a array = 'a array,
   val 'a empty : 'a array,
   val 'a hiext : 'a array * 'a -> 'a array,
   val 'a hirem : 'a array -> 'a array,
   val 'a length : 'a array -> int,
   val 'a loext : 'a array * 'a -> 'a array,
   val 'a lorem : 'a array -> 'a array,
   val 'a sub : 'a array * int -> 'a,
   val 'a update : 'a array * int * 'a -> 'a array}
> signature PRIORITY_QUEUE =
  /\item t.
    {type item = item,
     type t = t,
     val empty : t,
     val null : t -> bool,
     val insert : item * t -> t,
     val min : t -> item,
     val delmin : t -> t,
     val fromList : item list -> t,
     val toList : t -> item list,
     val sort : item list -> item list}
File "sample4.sml", line 276, characters 6-25:
!   fun min (Br(v,_,_)) = v;
!       ^^^^^^^^^^^^^^^^^^^
! Warning: pattern matching is not exhaustive

File "sample4.sml", line 283-286, characters 6-130:
! ......leftrem (Br(v,Lf,Lf)) = (v, Lf)
!     | leftrem (Br(v,t1,t2)) = 
!         let val (w, t) = leftrem t1
! 	in  (w, Br(v,t2,t))  end.
! Warning: pattern matching is not exhaustive

File "sample4.sml", line 288-295, characters 6-403:
! ......siftdown (w:real, Lf, Lf) = Br(w,Lf,Lf)
!     | siftdown (w, t as Br(v,Lf,Lf), Lf) =
!         if w <= v then Br(w, t, Lf)
!                   else Br(v, Br(w,Lf,Lf), Lf)
!     | siftdown (w, t1 as Br(v1,p1,q1), t2 as Br(v2,p2,q2)) =
!         if w <= v1 andalso w <= v2 then Br(w,t1,t2)
!         else if v1 <= v2 then Br(v1, siftdown(w,p1,q1), t2)
!            (* v2 < v1 *) else Br(v2, t1, siftdown(w,p2,q2)).
! Warning: pattern matching is not exhaustive

File "sample4.sml", line 303-307, characters 6-186:
! ......heapify (0, vs) = (Lf, vs)
!     | heapify (n, v::vs) =
! 	let val (t1, vs1) = heapify (n div 2, vs)
! 	    val (t2, vs2) = heapify ((n-1) div 2, vs1)
! 	in  (siftdown (v,t1,t2), vs2)  end.
! Warning: pattern matching is not exhaustive

> structure Heap :
  {type item = real,
   type t = real tree,
   val delmin : real tree -> real tree,
   val empty : real tree,
   val fromList : real list -> real tree,
   val insert : real * real tree -> real tree,
   val min : real tree -> real,
   val null : real tree -> bool,
   val sort : real list -> real list,
   val toList : real tree -> real list}
> New type names: =prop
  datatype prop =
  (prop,
   {con Atom : string -> prop,
    con Conj : prop * prop -> prop,
    con Disj : prop * prop -> prop,
    con Neg : prop -> prop})
  con Atom = fn : string -> prop
  con Conj = fn : prop * prop -> prop
  con Disj = fn : prop * prop -> prop
  con Neg = fn : prop -> prop
> val show = fn : prop -> string
> val nnf = fn : prop -> prop
> val nnfpos = fn : prop -> prop
  val nnfneg = fn : prop -> prop
> val distrib = fn : prop * prop -> prop
> val cnf = fn : prop -> prop
> exn NonCNF = NonCNF : exn
> val positives = fn : prop -> string list
> val negatives = fn : prop -> string list
> val taut = fn : prop -> bool
[closing file "sample4.sml"]
> val it = () : unit
[opening file "sample5.sml"]
> val 'a insort = fn : ('a * 'a -> bool) -> 'a list -> 'a list
> val ('a, 'b, 'c) secl = fn : 'a -> ('a * 'b -> 'c) -> 'b -> 'c
> val ('a, 'b, 'c) secr = fn : ('a * 'b -> 'c) -> 'b -> 'a -> 'c
> val summation = fn : (int -> real) -> int -> real
> val 'a takewhile = fn : ('a -> bool) -> 'a list -> 'a list
> val 'a dropwhile = fn : ('a -> bool) -> 'a list -> 'a list
> infix 0 mem
> val ''a mem = fn : ''a * ''a list -> bool
> val ('a, 'b) pair = fn : 'a -> 'b -> 'a * 'b
> val ('a, 'b) cartprod = fn : 'a list * 'b list -> ('a * 'b) list
> val 'a repeat = fn : ('a -> 'a) -> int -> 'a -> 'a
> New type names: seq
  datatype 'a seq =
  ('a seq,{con 'a Cons : 'a * (unit -> 'a seq) -> 'a seq, con 'a Nil : 'a seq})
  con 'a Cons = fn : 'a * (unit -> 'a seq) -> 'a seq
  con 'a Nil = Nil : 'a seq
> signature SEQUENCE =
  {exn Empty : exn,
   val 'a cons : 'a * 'a seq -> 'a seq,
   val 'a null : 'a seq -> bool,
   val 'a hd : 'a seq -> 'a,
   val 'a tl : 'a seq -> 'a seq,
   val 'a fromList : 'a list -> 'a seq,
   val 'a toList : 'a seq -> 'a list,
   val 'a take : 'a seq * int -> 'a list,
   val 'a drop : 'a seq * int -> 'a seq,
   val 'a @ : 'a seq * 'a seq -> 'a seq,
   val 'a interleave : 'a seq * 'a seq -> 'a seq,
   val ('a, 'b) map : ('a -> 'b) -> 'a seq -> 'b seq,
   val 'a filter : ('a -> bool) -> 'a seq -> 'a seq,
   val 'a iterates : ('a -> 'a) -> 'a -> 'a seq,
   val from : int -> int seq}
> structure Seq :
  {val 'a @ : 'a seq * 'a seq -> 'a seq,
   exn Empty : exn,
   val 'a cons : 'a * 'a seq -> 'a seq,
   val 'a drop : 'a seq * int -> 'a seq,
   val 'a filter : ('a -> bool) -> 'a seq -> 'a seq,
   val from : int -> int seq,
   val 'a fromList : 'a list -> 'a seq,
   val 'a hd : 'a seq -> 'a,
   val 'a interleave : 'a seq * 'a seq -> 'a seq,
   val 'a iterates : ('a -> 'a) -> 'a -> 'a seq,
   val ('a, 'b) map : ('a -> 'b) -> 'a seq -> 'b seq,
   val 'a null : 'a seq -> bool,
   val 'a take : 'a seq * int -> 'a list,
   val 'a tl : 'a seq -> 'a seq,
   val 'a toList : 'a seq -> 'a list}
> val seqChange = fn :
  int list * int list * int * (unit -> int list seq) -> int list seq
> val randseq = fn : int -> real seq
> val sift = fn : int -> int seq -> int seq
File "sample5.sml", line 172, characters 4-62:
! fun sieve (Cons(p,nf)) = Cons(p, fn()=> sieve (sift p (nf())));
!     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
! Warning: pattern matching is not exhaustive

> val sieve = fn : int seq -> int seq
> val primes = Cons(2, fn) : int seq
> val nextApprox = fn : real -> real -> real
File "sample5.sml", line 182, characters 14-24:
!       let val Cons(y,yf) = xf() 
!               ^^^^^^^^^^
! Warning: pattern matching is not exhaustive

File "sample5.sml", line 181-185, characters 4-151:
! ....within (eps:real) (Cons(x,xf)) =
!       let val Cons(y,yf) = xf() 
!       in  if Real.abs(x-y) < eps then y
! 	  else within eps (Cons(y,yf))
!       end.
! Warning: pattern matching is not exhaustive

> val within = fn : real -> real seq -> real
> val qroot = fn : real -> real
> val ('a, 'b) makeqq = fn : 'a seq * 'b seq -> ('a * 'b) seq seq
> val 'a takeqq = fn : 'a seq seq * (int * int) -> 'a list list
> val 'a enumerate = fn : 'a seq seq -> 'a seq
> val double = fn : int -> int
> val powof2 = fn : int -> int
> val pack_ = fn : int * int -> int
> val pairqq = Cons(Cons((1, 1), fn), fn) : (int * int) seq seq
> val nqq = Cons(Cons(1, fn), fn) : int seq seq
> val 'a depthFirst = fn : ('a -> 'a list) -> 'a -> 'a seq
> val 'a breadthFirst = fn : ('a -> 'a list) -> 'a -> 'a seq
> val nextChar = fn : char list -> char list list
> val ''a isPalin = fn : ''a list -> bool
> val show = fn : int -> char list seq -> string list
> val it = ["", "A", "B", "C", "AA", "BB", "CC", "AAA"] : string list
> val safeQueen = fn : int list -> int -> bool
> val upto = fn : int * int -> int list
> val nextQueen = fn : int -> int list -> int list list
> val 'a isFull = fn : int -> 'a list -> bool
> val depthQueen = fn : int -> int list seq
> val 'a depthIter = fn : ('a -> 'a list) -> 'a -> 'a seq
[closing file "sample5.sml"]
> val it = () : unit
[opening file "sample7.sml"]
> structure Queue1 :
  {type 'a t = 'a list,
   exn E : exn,
   val 'a deq : 'a list -> 'a list,
   val 'a empty : 'a list,
   val 'a enq : 'a list * 'a -> 'a list,
   val 'a hd : 'a list -> 'a,
   val 'a null : 'a list -> bool}
> New type names: =t
  structure Queue2 :
  {datatype 'a t =
     ('a t,{con 'a empty : 'a t, con 'a enq : 'a t * 'a -> 'a t}),
   exn E : exn,
   val 'a deq : 'a t -> 'a t,
   con 'a empty : 'a t,
   con 'a enq : 'a t * 'a -> 'a t,
   val 'a hd : 'a t -> 'a,
   val 'a null : 'a t -> bool}
> New type names: =t/1
  structure Queue3 :
  {datatype 'a t = ('a t/1,{con 'a Queue : 'a list * 'a list -> 'a t/1}),
   exn E : exn,
   con 'a Queue : 'a list * 'a list -> 'a t/1,
   val 'a deq : 'a t/1 -> 'a t/1,
   val 'a empty : 'a t/1,
   val 'a enq : 'a t/1 * 'a -> 'a t/1,
   val 'a hd : 'a t/1 -> 'a,
   val 'a norm : 'a t/1 -> 'a t/1,
   val 'a null : 'a t/1 -> bool}
> signature QUEUE =
  /\t/2.
    {type 'a t = 'a t/2,
     exn E : exn,
     val 'a empty : 'a t/2,
     val 'a enq : 'a t/2 * 'a -> 'a t/2,
     val 'a null : 'a t/2 -> bool,
     val 'a hd : 'a t/2 -> 'a,
     val 'a deq : 'a t/2 -> 'a t/2}
> New type names: t/2
  structure Queue :
  {type 'a t = 'a t/2,
   exn E : exn,
   val 'a deq : 'a t/2 -> 'a t/2,
   val 'a empty : 'a t/2,
   val 'a enq : 'a t/2 * 'a -> 'a t/2,
   val 'a hd : 'a t/2 -> 'a,
   val 'a null : 'a t/2 -> bool}
File "sample7.sml", line 147, characters 6-23:
!   fun qhd(Q1(x::q)) = x;
!       ^^^^^^^^^^^^^^^^^
! Warning: pattern matching is not exhaustive

File "sample7.sml", line 149, characters 6-26:
!   fun deq(Q1(x::q)) = Q1 q;
!       ^^^^^^^^^^^^^^^^^^^^
! Warning: pattern matching is not exhaustive

> New type names: queue1
  type 'a queue1 = 'a queue1
  val 'a empty = <queue1> : 'a queue1
  val 'a enq = fn : 'a queue1 * 'a -> 'a queue1
  val 'a qnull = fn : 'a queue1 -> bool
  val 'a qhd = fn : 'a queue1 -> 'a
  val 'a deq = fn : 'a queue1 -> 'a queue1
File "sample7.sml", line 163-164, characters 6-57:
! ......qhd (Enq(Empty,x)) = x
!     | qhd (Enq(q,x)) = qhd q.
! Warning: pattern matching is not exhaustive

File "sample7.sml", line 166-167, characters 6-69:
! ......deq (Enq(Empty,x)) = Empty
!     | deq (Enq(q,x)) = Enq(deq q, x).
! Warning: pattern matching is not exhaustive

> New type names: queue2
  type 'a queue2 = 'a queue2
  val 'a empty = <queue2> : 'a queue2
  val 'a enq = fn : 'a queue2 * 'a -> 'a queue2
  val 'a qnull = fn : 'a queue2 -> bool
  val 'a qhd = fn : 'a queue2 -> 'a
  val 'a deq = fn : 'a queue2 -> 'a queue2
> functor TestQueue :
  !t/3.
   {type 'a t = 'a t/3,
    exn E : exn,
    val 'a empty : 'a t/3,
    val 'a enq : 'a t/3 * 'a -> 'a t/3,
    val 'a null : 'a t/3 -> bool,
    val 'a hd : 'a t/3 -> 'a,
    val 'a deq : 'a t/3 -> 'a t/3}->
       {val 'a fromList : 'a list -> 'a t/3, val 'a toList : 'a t/3 -> 'a list}
> functor BreadthFirst :
  !t/3.
   {type 'a t = 'a t/3,
    exn E : exn,
    val 'a empty : 'a t/3,
    val 'a enq : 'a t/3 * 'a -> 'a t/3,
    val 'a null : 'a t/3 -> bool,
    val 'a hd : 'a t/3 -> 'a,
    val 'a deq : 'a t/3 -> 'a t/3}->
       {val 'a enqlist : 'a t/3 -> 'a list -> 'a t/3,
        val 'a search : ('a -> 'a list) -> 'a -> 'a seq}
> structure Breadth :
  {val 'a enqlist : 'a t/2 -> 'a list -> 'a t/2,
   val 'a search : ('a -> 'a list) -> 'a -> 'a seq}
> val brQueen = fn : int -> int list seq
> structure Breadth1 :
  {val 'a enqlist : 'a list -> 'a list -> 'a list,
   val 'a search : ('a -> 'a list) -> 'a -> 'a seq}
> val brQueen1 = fn : int -> int list seq
> signature ZSP =
  /\t/3.
    {type t = t/3,
     val zero : t/3,
     val sum : t/3 * t/3 -> t/3,
     val prod : t/3 * t/3 -> t/3}
> functor MatrixZSP :
  !t/3.
   {type t = t/3,
    val zero : t/3,
    val sum : t/3 * t/3 -> t/3,
    val prod : t/3 * t/3 -> t/3}->
       {type t = t/3 list list,
        val prod : t/3 list list * t/3 list list -> t/3 list list,
        val sum : t/3 list list * t/3 list list -> t/3 list list,
        val zero : t/3 list list}
> structure IntZSP :
  {type t = int,
   val prod : int * int -> int,
   val sum : int * int -> int,
   val zero : int}
> structure BoolZSP :
  {type t = bool,
   val prod : bool * bool -> bool,
   val sum : bool * bool -> bool,
   val zero : bool}
File "sample7.sml", line 265, characters 6-15:
!   val SOME zero = Int.maxInt;
!       ^^^^^^^^^
! Warning: pattern matching is not exhaustive

> structure PathZSP :
  {type t = int,
   val prod : int * int -> int,
   val sum : int * int -> int,
   val zero : int}
> structure PathMatrix :
  {type t = int list list,
   val prod : int list list * int list list -> int list list,
   val sum : int list list * int list list -> int list list,
   val zero : int list list}
> val fast_paths = fn : int list list -> int list list
> val zz = 1073741823 : int
> val mat =
    [[0, 3, 8, 1073741823, ~4], [1073741823, 0, 1073741823, 1, 7],
     [1073741823, 4, 0, 1073741823, 1073741823],
     [2, 1073741823, ~5, 0, 1073741823],
     [1073741823, 1073741823, 1073741823, 6, 0]] : int list list
> signature ORDER = /\t/3.{type t = t/3, val compare : t/3 * t/3 -> order}
> structure StringOrder :
  {type t = string, val compare : string * string -> order}
> functor Dictionary :
  !t/3.
   {type t = t/3, val compare : t/3 * t/3 -> order}->
       ?t/4.
        {type key = t/3,
         type 'a t = 'a t/4,
         exn E : t/3 -> exn,
         val 'a empty : 'a t/4,
         val 'a insert : 'a t/4 * t/3 * 'a -> 'a t/4,
         val 'a lookup : 'a t/4 * t/3 -> 'a,
         val 'a update : 'a t/4 * t/3 * 'a -> 'a t/4}
> New type names: t/3
  structure StringDict :
  {type key = string,
   type 'a t = 'a t/3,
   exn E : string -> exn,
   val 'a empty : 'a t/3,
   val 'a insert : 'a t/3 * string * 'a -> 'a t/3,
   val 'a lookup : 'a t/3 * string -> 'a,
   val 'a update : 'a t/3 * string * 'a -> 'a t/3}
> signature PRIORITY_QUEUE =
  /\t/4 t/5.
    {structure Item : {type t = t/4, val compare : t/4 * t/4 -> order},
     type t = t/5,
     val empty : t/5,
     val null : t/5 -> bool,
     val insert : t/4 * t/5 -> t/5,
     val min : t/5 -> t/4,
     val delmin : t/5 -> t/5,
     val fromList : t/4 list -> t/5,
     val toList : t/5 -> t/4 list,
     val sort : t/4 list -> t/4 list}
> functor AssocList :
  !=key.
   {type key = key}->
       {type key = key,
        type 'a t = (key * 'a) list,
        exn E : key -> exn,
        val 'a empty : (key * 'a) list,
        val 'a insert : (key * 'a) list * key * 'a -> (key * 'a) list,
        val 'a lookup : (key * 'a) list * key -> 'a,
        val 'a update : (key * 'a) list * key * 'a -> (key * 'a) list}
> signature TREE =
  /\=tree/1.
    {datatype 'a tree =
       ('a tree/1,
        {con 'a Br : 'a * 'a tree/1 * 'a tree/1 -> 'a tree/1,
         con 'a Lf : 'a tree/1}),
     con 'a Br : 'a * 'a tree/1 * 'a tree/1 -> 'a tree/1,
     con 'a Lf : 'a tree/1,
     val 'a size : 'a tree/1 -> int,
     val 'a depth : 'a tree/1 -> int,
     val 'a reflect : 'a tree/1 -> 'a tree/1}
> signature BRAUN =
  /\=tree/1.
    {structure Tree :
       {datatype 'a tree =
          ('a tree/1,
           {con 'a Br : 'a * 'a tree/1 * 'a tree/1 -> 'a tree/1,
            con 'a Lf : 'a tree/1}),
        con 'a Br : 'a * 'a tree/1 * 'a tree/1 -> 'a tree/1,
        con 'a Lf : 'a tree/1,
        val 'a size : 'a tree/1 -> int,
        val 'a depth : 'a tree/1 -> int,
        val 'a reflect : 'a tree/1 -> 'a tree/1},
     val 'a sub : 'a tree/1 * int -> 'a,
     val 'a update : 'a tree/1 * int * 'a -> 'a tree/1,
     val 'a delete : 'a tree/1 * int -> 'a tree/1,
     val 'a loext : 'a tree/1 * 'a -> 'a tree/1,
     val 'a lorem : 'a tree/1 -> 'a tree/1}
File "sample7.sml", line 425, characters 10-33:
!       fun min (PQ(Br(v,_,_))) = v;
!           ^^^^^^^^^^^^^^^^^^^^^^^
! Warning: pattern matching is not exhaustive

File "sample7.sml", line 434-437, characters 10-131:
! ..........leftrem (Br(v,Lf,_)) = (v, Lf)
! 	| leftrem (Br(v,t1,t2)) = 
! 	    let val (w, t) = leftrem t1
! 	    in  (w, Br(v,t2,t))  end.
! Warning: pattern matching is not exhaustive

File "sample7.sml", line 454-458, characters 10-192:
! ..........heapify (0, vs) = (Lf, vs)
! 	| heapify (n, v::vs) =
! 	    let val (t1, vs1) = heapify (n div 2, vs)
! 		val (t2, vs2) = heapify ((n-1) div 2, vs1)
! 	    in  (siftdown (v,t1,t2), vs2)  end.
! Warning: pattern matching is not exhaustive

> functor PriorityQueue :
  !t/4 =tree/1.
   {structure Item : {type t = t/4, val compare : t/4 * t/4 -> order},
    structure Tree :
      {datatype 'a tree =
         ('a tree/1,
          {con 'a Br : 'a * 'a tree/1 * 'a tree/1 -> 'a tree/1,
           con 'a Lf : 'a tree/1}),
       con 'a Br : 'a * 'a tree/1 * 'a tree/1 -> 'a tree/1,
       con 'a Lf : 'a tree/1,
       val 'a size : 'a tree/1 -> int,
       val 'a depth : 'a tree/1 -> int,
       val 'a reflect : 'a tree/1 -> 'a tree/1}}->
       ?t/5.
        {structure Item : {type t = t/4, val compare : t/4 * t/4 -> order},
         type t = t/5,
         val delmin : t/5 -> t/5,
         val empty : t/5,
         val fromList : t/4 list -> t/5,
         val insert : t/4 * t/5 -> t/5,
         val min : t/5 -> t/4,
         val null : t/5 -> bool,
         val sort : t/4 list -> t/4 list,
         val toList : t/5 -> t/4 list}
> functor FlexArray :
  !=tree/1.
   {structure Tree :
      {datatype 'a tree =
         ('a tree/1,
          {con 'a Br : 'a * 'a tree/1 * 'a tree/1 -> 'a tree/1,
           con 'a Lf : 'a tree/1}),
       con 'a Br : 'a * 'a tree/1 * 'a tree/1 -> 'a tree/1,
       con 'a Lf : 'a tree/1,
       val 'a size : 'a tree/1 -> int,
       val 'a depth : 'a tree/1 -> int,
       val 'a reflect : 'a tree/1 -> 'a tree/1},
    val 'a sub : 'a tree/1 * int -> 'a,
    val 'a update : 'a tree/1 * int * 'a -> 'a tree/1,
    val 'a delete : 'a tree/1 * int -> 'a tree/1,
    val 'a loext : 'a tree/1 * 'a -> 'a tree/1,
    val 'a lorem : 'a tree/1 -> 'a tree/1}->
       ?=array/1.
        {type 'a array = 'a array/1,
         val 'a empty : 'a array/1,
         val 'a hiext : 'a array/1 * 'a -> 'a array/1,
         val 'a hirem : 'a array/1 -> 'a array/1,
         val 'a length : 'a array/1 -> int,
         val 'a loext : 'a array/1 * 'a -> 'a array/1,
         val 'a lorem : 'a array/1 -> 'a array/1,
         val 'a sub : 'a array/1 * int -> 'a,
         val 'a update : 'a array/1 * int * 'a -> 'a array/1}
> functor BraunFunctor :
  !=tree/1.
   {datatype 'a tree =
      ('a tree/1,
       {con 'a Br : 'a * 'a tree/1 * 'a tree/1 -> 'a tree/1,
        con 'a Lf : 'a tree/1}),
    con 'a Br : 'a * 'a tree/1 * 'a tree/1 -> 'a tree/1,
    con 'a Lf : 'a tree/1,
    val 'a size : 'a tree/1 -> int,
    val 'a depth : 'a tree/1 -> int,
    val 'a reflect : 'a tree/1 -> 'a tree/1}->
       {structure Tree :
          {datatype 'a tree =
             ('a tree/1,
              {con 'a Br : 'a * 'a tree/1 * 'a tree/1 -> 'a tree/1,
               con 'a Lf : 'a tree/1}),
           con 'a Br : 'a * 'a tree/1 * 'a tree/1 -> 'a tree/1,
           con 'a Lf : 'a tree/1,
           val 'a depth : 'a tree/1 -> int,
           val 'a reflect : 'a tree/1 -> 'a tree/1,
           val 'a size : 'a tree/1 -> int},
        val 'a delete : 'a tree/1 * int -> 'a tree/1,
        val 'a loext : 'a tree/1 * 'a -> 'a tree/1,
        val 'a lorem : 'a tree/1 -> 'a tree/1,
        val 'a sub : 'a tree/1 * int -> 'a,
        val 'a update : 'a tree/1 * int * 'a -> 'a tree/1}
File "sample7.sml", line 577, characters 9-14:
! 	    val y::ys = List.drop(xs,k)
! 	        ^^^^^
! Warning: pattern matching is not exhaustive

> functor TreeFunctor :
  {}->
      ?=tree/1.
       {datatype 'a tree =
          ('a tree/1,
           {con 'a Br : 'a * 'a tree/1 * 'a tree/1 -> 'a tree/1,
            con 'a Lf : 'a tree/1}),
        con 'a Br : 'a * 'a tree/1 * 'a tree/1 -> 'a tree/1,
        con 'a Lf : 'a tree/1,
        val 'a depth : 'a tree/1 -> int,
        val 'a reflect : 'a tree/1 -> 'a tree/1,
        val 'a size : 'a tree/1 -> int}
> New type names: =tree/1
  structure Tree :
  {datatype 'a tree =
     ('a tree/1,
      {con 'a Br : 'a * 'a tree/1 * 'a tree/1 -> 'a tree/1,
       con 'a Lf : 'a tree/1}),
   con 'a Br : 'a * 'a tree/1 * 'a tree/1 -> 'a tree/1,
   con 'a Lf : 'a tree/1,
   val 'a depth : 'a tree/1 -> int,
   val 'a reflect : 'a tree/1 -> 'a tree/1,
   val 'a size : 'a tree/1 -> int}
> structure Braun :
  {structure Tree :
     {datatype 'a tree =
        ('a tree/1,
         {con 'a Br : 'a * 'a tree/1 * 'a tree/1 -> 'a tree/1,
          con 'a Lf : 'a tree/1}),
      con 'a Br : 'a * 'a tree/1 * 'a tree/1 -> 'a tree/1,
      con 'a Lf : 'a tree/1,
      val 'a depth : 'a tree/1 -> int,
      val 'a reflect : 'a tree/1 -> 'a tree/1,
      val 'a size : 'a tree/1 -> int},
   val 'a delete : 'a tree/1 * int -> 'a tree/1,
   val 'a loext : 'a tree/1 * 'a -> 'a tree/1,
   val 'a lorem : 'a tree/1 -> 'a tree/1,
   val 'a sub : 'a tree/1 * int -> 'a,
   val 'a update : 'a tree/1 * int * 'a -> 'a tree/1}
> New type names: =array/1
  structure Flex :
  {type 'a array = 'a array/1,
   val 'a empty : 'a array/1,
   val 'a hiext : 'a array/1 * 'a -> 'a array/1,
   val 'a hirem : 'a array/1 -> 'a array/1,
   val 'a length : 'a array/1 -> int,
   val 'a loext : 'a array/1 * 'a -> 'a array/1,
   val 'a lorem : 'a array/1 -> 'a array/1,
   val 'a sub : 'a array/1 * int -> 'a,
   val 'a update : 'a array/1 * int * 'a -> 'a array/1}
> New type names: t/4
  structure StringPQueue :
  {structure Item : {type t = string, val compare : string * string -> order},
   type t = t/4,
   val delmin : t/4 -> t/4,
   val empty : t/4,
   val fromList : string list -> t/4,
   val insert : string * t/4 -> t/4,
   val min : t/4 -> string,
   val null : t/4 -> bool,
   val sort : string list -> string list,
   val toList : t/4 -> string list}
[closing file "sample7.sml"]
> val it = () : unit
[opening file "sample8.sml"]
> val impFact = fn : int -> int
> val pFact = fn : int * int ref -> unit
> val 'a irev = fn : 'a list -> 'a list
> signature IMP_SEQUENCE =
  /\t/5.
    {type 'a t = 'a t/5,
     exn Empty : exn,
     val 'a empty : 'a t/5,
     val 'a cons : 'a * (unit -> 'a t/5) -> 'a t/5,
     val 'a null : 'a t/5 -> bool,
     val 'a hd : 'a t/5 -> 'a,
     val 'a tl : 'a t/5 -> 'a t/5,
     val 'a take : 'a t/5 * int -> 'a list,
     val 'a toList : 'a t/5 -> 'a list,
     val 'a fromList : 'a list -> 'a t/5,
     val 'a @ : 'a t/5 * 'a t/5 -> 'a t/5,
     val 'a interleave : 'a t/5 * 'a t/5 -> 'a t/5,
     val 'a concat : 'a t/5 t/5 -> 'a t/5,
     val ('a, 'b) map : ('a -> 'b) -> 'a t/5 -> 'b t/5,
     val 'a filter : ('a -> bool) -> 'a t/5 -> 'a t/5,
     val 'a cycle : ((unit -> 'a t/5) -> 'a t/5) -> 'a t/5}
File "sample8.sml", line 102-103, characters 6-49:
! ......null Nil = true
!     | null (Cons _) = false.
! Warning: pattern matching is not exhaustive

File "sample8.sml", line 105-106, characters 6-51:
! ......hd Nil = raise Empty
!     | hd (Cons(x,_)) = x.
! Warning: pattern matching is not exhaustive

File "sample8.sml", line 108-109, characters 6-59:
! ......tl Nil = raise Empty
!     | tl (Cons(_,xp)) = force xp.
! Warning: pattern matching is not exhaustive

File "sample8.sml", line 111-113, characters 6-103:
! ......take (xq, 0) = []
!     | take (Nil, n) = []
!     | take (Cons(x,xp), n) = x :: take (force xp, n-1).
! Warning: pattern matching is not exhaustive

File "sample8.sml", line 115-116, characters 6-72:
! ......toList Nil = []
!     | toList (Cons(x,xp)) = x :: toList (force xp).
! Warning: pattern matching is not exhaustive

File "sample8.sml", line 121-123, characters 6-87:
! ......Nil @ yq = yq
!     | (Cons(x,xp)) @ yq =
! 	  Cons(x, delay(fn()=> (force xp) @ yq)).
! Warning: pattern matching is not exhaustive

File "sample8.sml", line 125-127, characters 6-123:
! ......interleave (Nil,    yq) = yq
!     | interleave (Cons(x,xp), yq) = 
! 	  Cons(x, delay (fn()=> interleave(yq, force xp))).
! Warning: pattern matching is not exhaustive

File "sample8.sml", line 137-139, characters 6-102:
! ......map f Nil  = Nil
!     | map f (Cons(x,xp)) = 
!           Cons(f x, delay(fn()=> map f (force xp))).
! Warning: pattern matching is not exhaustive

File "sample8.sml", line 141-145, characters 6-166:
! ......filter pred Nil = Nil
!     | filter pred (Cons(x,xp)) =
! 	  if pred x 
!           then Cons(x, delay(fn()=> filter pred (force xp)))
! 	  else filter pred (force xp).
! Warning: pattern matching is not exhaustive

> New type names: t/5
  structure ImpSeq :
  {type 'a t = 'a t/5,
   val 'a @ : 'a t/5 * 'a t/5 -> 'a t/5,
   exn Empty : exn,
   val 'a concat : 'a t/5 t/5 -> 'a t/5,
   val 'a cons : 'a * (unit -> 'a t/5) -> 'a t/5,
   val 'a cycle : ((unit -> 'a t/5) -> 'a t/5) -> 'a t/5,
   val 'a empty : 'a t/5,
   val 'a filter : ('a -> bool) -> 'a t/5 -> 'a t/5,
   val 'a fromList : 'a list -> 'a t/5,
   val 'a hd : 'a t/5 -> 'a,
   val 'a interleave : 'a t/5 * 'a t/5 -> 'a t/5,
   val ('a, 'b) map : ('a -> 'b) -> 'a t/5 -> 'b t/5,
   val 'a null : 'a t/5 -> bool,
   val 'a take : 'a t/5 * int -> 'a list,
   val 'a tl : 'a t/5 -> 'a t/5,
   val 'a toList : 'a t/5 -> 'a list}
> val ('a, 'b) pairs = fn : 'a t/5 * 'b t/5 -> ('a * 'b) t/5
> val add = fn : int t/5 * int t/5 -> int t/5
> val fib = <t> : int t/5
> val it =
    [1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987, 1597, 2584,
     4181, 6765, 10946, 17711, 28657, 46368, 75025, 121393, 196418, 317811,
     514229, 832040, 1346269, 2178309, 3524578, 5702887, 9227465, 14930352,
     24157817, 39088169, 63245986, 102334155] : int list
> signature RINGBUF =
  /\=t/6.
    {type 'a t = 'a t/6,
     exn Empty : exn,
     val 'a empty : unit -> 'a t/6,
     val 'a null : 'a t/6 -> bool,
     val 'a label : 'a t/6 -> 'a,
     val 'a moveLeft : 'a t/6 -> unit,
     val 'a moveRight : 'a t/6 -> unit,
     val 'a insert : 'a t/6 * 'a -> unit,
     val 'a delete : 'a t/6 -> 'a}
> New type names: =t/6
  structure RingBuf :
  {type 'a t = 'a t/6,
   exn Empty : exn,
   val 'a delete : 'a t/6 -> 'a,
   val 'a empty : unit -> 'a t/6,
   val 'a insert : 'a t/6 * 'a -> unit,
   val 'a label : 'a t/6 -> 'a,
   val 'a moveLeft : 'a t/6 -> unit,
   val 'a moveRight : 'a t/6 -> unit,
   val 'a null : 'a t/6 -> bool}
> signature VARRAY =
  /\t/7.
    {type 'a t = 'a t/7,
     val 'a array : int * 'a -> 'a t/7,
     val 'a reroot : 'a t/7 -> 'a t/7,
     val 'a sub : 'a t/7 * int -> 'a,
     val 'a justUpdate : 'a t/7 * int * 'a -> 'a t/7,
     val 'a update : 'a t/7 * int * 'a -> 'a t/7}
File "sample8.sml", line 280, characters 12-20:
! 	       val Main ary = !bnext
! 	           ^^^^^^^^
! Warning: pattern matching is not exhaustive

File "sample8.sml", line 278, characters 12-57:
! 	   let val Modif{index=bindex,elem=belem,next=bnext,...} =
! 	           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
! Warning: pattern matching is not exhaustive

File "sample8.sml", line 274-287, characters 6-417:
! ......reroot (va as Modif{index, elem, next,...}) =
!       case !next of
! 	 Main _ => va  (*have reached root*)
!        | Modif _ => 
! ..........
! 	       next := !bnext;
! 	       bnext := va;
! 	       va
! 	   end.
! Warning: pattern matching is not exhaustive

File "sample8.sml", line 290-294, characters 6-168:
! ......sub (Modif{index,elem,next,...}, i) =
!        case !next of
! 	  Main ary => Array.sub(ary,i)
! 	| Modif _ =>    if !index = i then !elem  
! 				      else sub(!next,i).
! Warning: pattern matching is not exhaustive

File "sample8.sml", line 297-301, characters 6-169:
! ......justUpdate(va as Modif{limit,...}, i, x) = 
! 	if  0<=i andalso i<limit  
! 	then Modif{limit=limit, index= ref i, 
! 		   elem=ref x, next=ref va}
! 	else raise Subscript.
! Warning: pattern matching is not exhaustive

> New type names: t/7
  structure Varray :
  {type 'a t = 'a t/7,
   val 'a array : int * 'a -> 'a t/7,
   val 'a justUpdate : 'a t/7 * int * 'a -> 'a t/7,
   val 'a reroot : 'a t/7 -> 'a t/7,
   val 'a sub : 'a t/7 * int -> 'a,
   val 'a update : 'a t/7 * int * 'a -> 'a t/7}
> val months =
    ["JAN", "FEB", "MAR", "APR", "MAY", "JUN", "JUL", "AUG", "SEP", "OCT",
     "NOV", "DEC"] : string list
File "sample8.sml", line 322, characters 10-19:
!       val SOME year = Int.fromString syear
!           ^^^^^^^^^
! Warning: pattern matching is not exhaustive

File "sample8.sml", line 320, characters 10-18:
!       val SOME day = Int.fromString sday
!           ^^^^^^^^
! Warning: pattern matching is not exhaustive

File "sample8.sml", line 319, characters 10-30:
!   let val sday::smon::syear::_ = String.tokens (fn c => c = #"-") s
!           ^^^^^^^^^^^^^^^^^^^^
! Warning: pattern matching is not exhaustive

> val dateFromString = fn : string -> (int * string * int) option
> val firstChar = fn : string -> char
> val initials = fn : string -> string
> val it = "Mritfawt" : string
> val batchInitials = fn : instream * outstream -> unit
> val promptInitials = fn : instream * outstream -> unit
> val firstLine = fn : string -> string
> val htmlCvt = fn : string -> unit
> signature PRETTY =
  /\t/8.
    {type t = t/8,
     val blo : int * t/8 list -> t/8,
     val str : string -> t/8,
     val brk : int -> t/8,
     val pr : outstream * t/8 * int -> unit}
> New type names: =t/8
  structure Pretty :
  {type t = t/8,
   val blo : int * t/8 list -> t/8,
   val brk : int -> t/8,
   val pr : outstream * t/8 * int -> unit,
   val str : string -> t/8}
> val prettyshow = fn : prop -> t/8
[closing file "sample8.sml"]
> val it = () : unit
[opening file "sample9.sml"]
> signature KEYWORD = {val alphas : string list, val symbols : string list}
> signature LEXICAL =
  /\=token.
    {datatype token =
       (token,{con Id : string -> token, con Key : string -> token}),
     con Id : string -> token,
     con Key : string -> token,
     val scan : string -> token list}
> functor Lexical :
  {val alphas : string list, val symbols : string list}->
      ?=token.
       {datatype token =
          (token,{con Id : string -> token, con Key : string -> token}),
        con Id : string -> token,
        con Key : string -> token,
        val scan : string -> token list}
> infix 6 $--
> infix 5 --
> infix 3 >>
> infix 0 ||
> signature PARSE =
  /\token.
    {exn SyntaxErr : string -> exn,
     type token = token,
     val id : token list -> string * token list,
     val $ : string -> token list -> string * token list,
     val ('b, 'a) empty : 'a -> 'b list * 'a,
     val ('a, 'b) || : ('a -> 'b) * ('a -> 'b) -> 'a -> 'b,
     val ('a, 'b, 'c) !! : ('a -> 'b * 'c) -> 'a -> 'b * 'c,
     val ('c, 'a, 'b, 'd, 'e) -- :
       ('a -> 'b * 'c) * ('c -> 'd * 'e) -> 'a -> ('b * 'd) * 'e,
     val ('a, 'b) $-- :
       string * (token list -> 'a * 'b) -> token list -> 'a * 'b,
     val ('b, 'a, 'd, 'c) >> : ('a -> 'b * 'c) * ('b -> 'd) -> 'a -> 'd * 'c,
     val ('b, 'a) repeat : ('a -> 'b * 'a) -> 'a -> 'b list * 'a,
     val 'a infixes :
       (token list -> 'a * token list) * (string -> int) *
       (string -> 'a -> 'a -> 'a) -> token list -> 'a * token list,
     val ('b, 'a) reader : (token list -> 'a * 'b list) -> string -> 'a}
> functor Parsing :
  !=token.
   {datatype token =
      (token,{con Id : string -> token, con Key : string -> token}),
    con Id : string -> token,
    con Key : string -> token,
    val scan : string -> token list}->
       {type token = token,
        val ('a, 'b, 'c) !! : ('a -> 'b * 'c) -> 'a -> 'b * 'c,
        val $ : string -> token list -> string * token list,
        val ('a, 'b) $-- :
          string * (token list -> 'a * 'b) -> token list -> 'a * 'b,
        val ('c, 'a, 'b, 'd, 'e) -- :
          ('a -> 'b * 'c) * ('c -> 'd * 'e) -> 'a -> ('b * 'd) * 'e,
        val ('b, 'a, 'd, 'c) >> :
          ('a -> 'b * 'c) * ('b -> 'd) -> 'a -> 'd * 'c,
        exn SyntaxErr : string -> exn,
        val ('b, 'a) empty : 'a -> 'b list * 'a,
        val id : token list -> string * token list,
        val 'a infixes :
          (token list -> 'a * token list) * (string -> int) *
          (string -> 'a -> 'a -> 'a) -> token list -> 'a * token list,
        val ('b, 'a) reader : (token list -> 'a * 'b list) -> string -> 'a,
        val ('b, 'a) repeat : ('a -> 'b * 'a) -> 'a -> 'b list * 'a,
        val ('a, 'b) || : ('a -> 'b) * ('a -> 'b) -> 'a -> 'b}
> signature TYPE =
  /\=t/9.
    {datatype t =
       (t/9,{con Con : string * t/9 list -> t/9, con Var : string -> t/9}),
     con Con : string * t/9 list -> t/9,
     con Var : string -> t/9,
     val pr : t/9 -> unit,
     val read : string -> t/9}
> structure LamKey : {val 'a alphas : 'a list, val symbols : string list}
> New type names: =token
  structure LamLex :
  {datatype token =
     (token,{con Id : string -> token, con Key : string -> token}),
   con Id : string -> token,
   con Key : string -> token,
   val scan : string -> token list}
> structure LamParsing :
  {type token = token,
   val ('a, 'b, 'c) !! : ('a -> 'b * 'c) -> 'a -> 'b * 'c,
   val $ : string -> token list -> string * token list,
   val ('a, 'b) $-- :
     string * (token list -> 'a * 'b) -> token list -> 'a * 'b,
   val ('c, 'a, 'b, 'd, 'e) -- :
     ('a -> 'b * 'c) * ('c -> 'd * 'e) -> 'a -> ('b * 'd) * 'e,
   val ('b, 'a, 'd, 'c) >> : ('a -> 'b * 'c) * ('b -> 'd) -> 'a -> 'd * 'c,
   exn SyntaxErr : string -> exn,
   val ('b, 'a) empty : 'a -> 'b list * 'a,
   val id : token list -> string * token list,
   val 'a infixes :
     (token list -> 'a * token list) * (string -> int) *
     (string -> 'a -> 'a -> 'a) -> token list -> 'a * token list,
   val ('b, 'a) reader : (token list -> 'a * 'b list) -> string -> 'a,
   val ('b, 'a) repeat : ('a -> 'b * 'a) -> 'a -> 'b list * 'a,
   val ('a, 'b) || : ('a -> 'b) * ('a -> 'b) -> 'a -> 'b}
File "sample9.sml", line 212-216, characters 8-161:
! ........typ (Var a) = Pretty.str a
!       | typ (Con("->",[ty1,ty2])) = Pretty.blo(0, [atom ty1, 
! 						 Pretty.str " ->", 
! 						 Pretty.brk 1, 
! 						 typ ty2])
! Warning: pattern matching is not exhaustive

> New type names: =t/9
  structure Type :
  {datatype t =
     (t/9,{con Con : string * t/9 list -> t/9, con Var : string -> t/9}),
   con Con : string * t/9 list -> t/9,
   con Var : string -> t/9,
   val pr : t/9 -> unit,
   val read : string -> t/9}
> signature LAMBDA =
  /\=t/10.
    {datatype t =
       (t/10,
        {con Abs : string * t/10 -> t/10,
         con Apply : t/10 * t/10 -> t/10,
         con Bound : int -> t/10,
         con Free : string -> t/10}),
     con Abs : string * t/10 -> t/10,
     con Apply : t/10 * t/10 -> t/10,
     con Bound : int -> t/10,
     con Free : string -> t/10,
     val abstract : int -> string -> t/10 -> t/10,
     val absList : string list * t/10 -> t/10,
     val applyList : t/10 * t/10 list -> t/10,
     val subst : int -> t/10 -> t/10 -> t/10,
     val inst : t/10 t/3 -> t/10 -> t/10}
> New type names: =t/10
  structure Lambda :
  {datatype t =
     (t/10,
      {con Abs : string * t/10 -> t/10,
       con Apply : t/10 * t/10 -> t/10,
       con Bound : int -> t/10,
       con Free : string -> t/10}),
   con Abs : string * t/10 -> t/10,
   con Apply : t/10 * t/10 -> t/10,
   con Bound : int -> t/10,
   con Free : string -> t/10,
   val absList : string list * t/10 -> t/10,
   val abstract : int -> string -> t/10 -> t/10,
   val applyList : t/10 * t/10 list -> t/10,
   val inst : t/10 t/3 -> t/10 -> t/10,
   val subst : int -> t/10 -> t/10 -> t/10}
> signature PARSE_TERM = {val read : string -> t/10}
> structure ParseTerm : {val read : string -> t/10}
> signature DISPLAY_TERM =
  {val rename : string list * string -> string,
   val stripAbs : t/10 -> string list * t/10,
   val pr : t/10 -> unit}
File "sample9.sml", line 352, characters 11-20:
! 	  let val (b::bs,u) = stripAbs t
! 	          ^^^^^^^^^
! Warning: pattern matching is not exhaustive

> structure DisplayTerm :
  {val pr : t/10 -> unit,
   val rename : string list * string -> string,
   val stripAbs : t/10 -> string list * t/10}
> signature REDUCE =
  {val eval : t/10 -> t/10,
   val byValue : t/10 -> t/10,
   val headNF : t/10 -> t/10,
   val byName : t/10 -> t/10}
> structure Reduce :
  {val byName : t/10 -> t/10,
   val byValue : t/10 -> t/10,
   val eval : t/10 -> t/10,
   val headNF : t/10 -> t/10}
> val insertEnv = fn : (string * string) * t/10 t/3 -> t/10 t/3
> val stdEnv = <t> : t/10 t/3
> val stdRead = fn : string -> t/10
> val try = fn : (t/10 -> t/10) -> string -> unit
[closing file "sample9.sml"]
> val it = () : unit
[opening file "sample10.sml"]
> signature FOL =
  /\=term =form.
    {datatype term =
       (term,
        {con Bound : int -> term,
         con Fun : string * term list -> term,
         con Param : string * string list -> term,
         con Var : string -> term}),
     con Bound : int -> term,
     con Fun : string * term list -> term,
     con Param : string * string list -> term,
     con Var : string -> term,
     datatype form =
       (form,
        {con Conn : string * form list -> form,
         con Pred : string * term list -> form,
         con Quant : string * string * form -> form}),
     con Conn : string * form list -> form,
     con Pred : string * term list -> form,
     con Quant : string * string * form -> form,
     type goal = form list * form list,
     val precOf : string -> int,
     val abstract : int -> term -> form -> form,
     val subst : int -> term -> form -> form,
     val termVars : term * string list -> string list,
     val goalVars : (form list * form list) * string list -> string list,
     val termParams :
       term * (string * string list) list -> (string * string list) list,
     val goalParams :
       (form list * form list) * (string * string list) list ->
       (string * string list) list}
> New type names: =term, =form
  structure Fol :
  {datatype term =
     (term,
      {con Bound : int -> term,
       con Fun : string * term list -> term,
       con Param : string * string list -> term,
       con Var : string -> term}),
   datatype form =
     (form,
      {con Conn : string * form list -> form,
       con Pred : string * term list -> form,
       con Quant : string * string * form -> form}),
   type goal = form list * form list,
   con Bound : int -> term,
   con Conn : string * form list -> form,
   con Fun : string * term list -> term,
   con Param : string * string list -> term,
   con Pred : string * term list -> form,
   con Quant : string * string * form -> form,
   con Var : string -> term,
   val abstract : int -> term -> form -> form,
   val goalParams :
     (form list * form list) * (string * string list) list ->
     (string * string list) list,
   val goalVars : (form list * form list) * string list -> string list,
   val precOf : string -> int,
   val subst : int -> term -> form -> form,
   val termParams :
     term * (string * string list) list -> (string * string list) list,
   val termVars : term * string list -> string list}
> structure FolKey : {val alphas : string list, val symbols : string list}
> New type names: =token/1
  structure FolLex :
  {datatype token =
     (token/1,{con Id : string -> token/1, con Key : string -> token/1}),
   con Id : string -> token/1,
   con Key : string -> token/1,
   val scan : string -> token/1 list}
> structure FolParsing :
  {type token = token/1,
   val ('a, 'b, 'c) !! : ('a -> 'b * 'c) -> 'a -> 'b * 'c,
   val $ : string -> token/1 list -> string * token/1 list,
   val ('a, 'b) $-- :
     string * (token/1 list -> 'a * 'b) -> token/1 list -> 'a * 'b,
   val ('c, 'a, 'b, 'd, 'e) -- :
     ('a -> 'b * 'c) * ('c -> 'd * 'e) -> 'a -> ('b * 'd) * 'e,
   val ('b, 'a, 'd, 'c) >> : ('a -> 'b * 'c) * ('b -> 'd) -> 'a -> 'd * 'c,
   exn SyntaxErr : string -> exn,
   val ('b, 'a) empty : 'a -> 'b list * 'a,
   val id : token/1 list -> string * token/1 list,
   val 'a infixes :
     (token/1 list -> 'a * token/1 list) * (string -> int) *
     (string -> 'a -> 'a -> 'a) -> token/1 list -> 'a * token/1 list,
   val ('b, 'a) reader : (token/1 list -> 'a * 'b list) -> string -> 'a,
   val ('b, 'a) repeat : ('a -> 'b * 'a) -> 'a -> 'b list * 'a,
   val ('a, 'b) || : ('a -> 'b) * ('a -> 'b) -> 'a -> 'b}
> signature PARSE_FOL = {val read : string -> form}
> structure ParseFol : {val read : string -> form}
> signature DISPLAY_FOL =
  {val form : form -> unit, val goal : int -> form list * form list -> unit}
File "sample10.sml", line 192, characters 6-62:
!   fun list (sexp::sexps) = Pretty.blo(0, sexp :: commas sexps);  
!       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
! Warning: pattern matching is not exhaustive

> structure DisplayFol :
  {val form : form -> unit, val goal : int -> form list * form list -> unit}
> signature UNIFY =
  {exn Failed : exn,
   val atoms : form * form -> term t/3,
   val instTerm : term t/3 -> term -> term,
   val instForm : term t/3 -> form -> form,
   val instGoal : term t/3 -> form list * form list -> form list * form list}
> structure Unify :
  {exn Failed : exn,
   val atoms : form * form -> term t/3,
   val instForm : term t/3 -> form -> form,
   val instGoal : term t/3 -> form list * form list -> form list * form list,
   val instTerm : term t/3 -> term -> term}
> signature RULE =
  /\state.
    {type state = state,
     type tactic = state -> state t/5,
     val main : state -> form,
     val subgoals : state -> (form list * form list) list,
     val initial : form -> state,
     val final : state -> bool,
     val basic : int -> state -> state t/5,
     val unify : int -> state -> state t/5,
     val conjL : int -> state -> state t/5,
     val conjR : int -> state -> state t/5,
     val disjL : int -> state -> state t/5,
     val disjR : int -> state -> state t/5,
     val impL : int -> state -> state t/5,
     val impR : int -> state -> state t/5,
     val negL : int -> state -> state t/5,
     val negR : int -> state -> state t/5,
     val iffL : int -> state -> state t/5,
     val iffR : int -> state -> state t/5,
     val allL : int -> state -> state t/5,
     val allR : int -> state -> state t/5,
     val exL : int -> state -> state t/5,
     val exR : int -> state -> state t/5}
File "sample10.sml", line 409, characters 25-69:
!   val conjL = propL "&" (fn (([p1,p2], ps), qs) => [(p1::p2::ps, qs)]);
!                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
! Warning: pattern matching is not exhaustive

File "sample10.sml", line 412, characters 7-62:
!       (fn (ps, ([q1,q2], qs)) => [(ps, q1::qs),  (ps, q2::qs)]);
!        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
! Warning: pattern matching is not exhaustive

File "sample10.sml", line 415, characters 7-62:
!       (fn (([p1,p2], ps), qs) => [(p1::ps, qs),  (p2::ps, qs)]);
!        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
! Warning: pattern matching is not exhaustive

File "sample10.sml", line 417, characters 25-69:
!   val disjR = propR "|" (fn (ps, ([q1,q2], qs)) => [(ps, q1::q2::qs)]);
!                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
! Warning: pattern matching is not exhaustive

File "sample10.sml", line 420, characters 7-62:
!       (fn (([p1,p2], ps), qs) => [(p2::ps, qs),  (ps, p1::qs)]);
!        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
! Warning: pattern matching is not exhaustive

File "sample10.sml", line 422, characters 26-70:
!   val impR = propR "-->" (fn (ps, ([q1,q2], qs)) => [(q1::ps, q2::qs)]);
!                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
! Warning: pattern matching is not exhaustive

File "sample10.sml", line 424, characters 24-59:
!   val negL = propL "~" (fn (([p], ps), qs) => [(ps, p::qs)]);
!                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
! Warning: pattern matching is not exhaustive

File "sample10.sml", line 426, characters 24-59:
!   val negR = propR "~" (fn (ps, ([q], qs)) => [(q::ps, qs)]);
!                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
! Warning: pattern matching is not exhaustive

File "sample10.sml", line 429, characters 7-70:
!       (fn (([p1,p2], ps), qs) => [(p1::p2::ps, qs),  (ps, p1::p2::qs)]);
!        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
! Warning: pattern matching is not exhaustive

File "sample10.sml", line 432, characters 7-70:
!       (fn (ps, ([q1,q2], qs)) => [(q1::ps, q2::qs),  (q2::ps, q1::qs)]);
!        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
! Warning: pattern matching is not exhaustive

File "sample10.sml", line 461, characters 14-48:
!       let val (qntForm as Fol.Quant(_,_,p), ps') = splitQuant "ALL" ps
!               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
! Warning: pattern matching is not exhaustive

File "sample10.sml", line 466, characters 14-37:
!       let val (Fol.Quant(_,_,q), qs') = splitQuant "ALL" qs
!               ^^^^^^^^^^^^^^^^^^^^^^^
! Warning: pattern matching is not exhaustive

File "sample10.sml", line 472, characters 14-37:
!       let val (Fol.Quant(_,_,p), ps') = splitQuant "EX" ps
!               ^^^^^^^^^^^^^^^^^^^^^^^
! Warning: pattern matching is not exhaustive

File "sample10.sml", line 478, characters 14-48:
!       let val (qntForm as Fol.Quant(_,_,q), qs') = splitQuant "EX" qs
!               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
! Warning: pattern matching is not exhaustive

> New type names: state
  structure Rule :
  {type state = state,
   type tactic = state -> state t/5,
   val allL : int -> state -> state t/5,
   val allR : int -> state -> state t/5,
   val basic : int -> state -> state t/5,
   val conjL : int -> state -> state t/5,
   val conjR : int -> state -> state t/5,
   val disjL : int -> state -> state t/5,
   val disjR : int -> state -> state t/5,
   val exL : int -> state -> state t/5,
   val exR : int -> state -> state t/5,
   val final : state -> bool,
   val iffL : int -> state -> state t/5,
   val iffR : int -> state -> state t/5,
   val impL : int -> state -> state t/5,
   val impR : int -> state -> state t/5,
   val initial : form -> state,
   val main : state -> form,
   val negL : int -> state -> state t/5,
   val negR : int -> state -> state t/5,
   val subgoals : state -> (form list * form list) list,
   val unify : int -> state -> state t/5}
> signature COMMAND =
  {val goal : string -> unit,
   val by : (state -> state t/5) -> unit,
   val pr : state -> unit,
   val getState : unit -> state}
> structure Command :
  {val by : (state -> state t/5) -> unit,
   val getState : unit -> state,
   val goal : string -> unit,
   val pr : state -> unit}
> infix 0 |@|
> signature TACTICAL =
  /\multifun.
    {type ('a, 'b) multifun = ('a, 'b) multifun,
     val ('b, 'a, 'c) -- :
       ('a, 'b) multifun * ('b, 'c) multifun -> ('a, 'c) multifun,
     val ('a, 'b) || :
       ('a, 'b) multifun * ('a, 'b) multifun -> ('a, 'b) multifun,
     val ('a, 'b) |@| :
       ('a, 'b) multifun * ('a, 'b) multifun -> ('a, 'b) multifun,
     val 'a all : ('a, 'a) multifun,
     val ('a, 'b) no : ('a, 'b) multifun,
     val 'a try : ('a, 'a) multifun -> ('a, 'a) multifun,
     val 'a repeat : ('a, 'a) multifun -> ('a, 'a) multifun,
     val 'a repeatDeterm : ('a, 'a) multifun -> ('a, 'a) multifun,
     val 'a depthFirst :
       ('a -> bool) -> ('a, 'a) multifun -> ('a, 'a) multifun,
     val 'a depthIter :
       ('a -> bool) * int -> ('a, 'a) multifun -> ('a, 'a) multifun,
     val ('a, 'b, 'c) firstF :
       ('a -> ('b, 'c) multifun) list -> 'a -> ('b, 'c) multifun}
> structure Tactical :
  {type ('a, 'b) multifun = 'a -> 'b t/5,
   val ('b, 'a, 'c) -- : ('a -> 'b t/5) * ('b -> 'c t/5) -> 'a -> 'c t/5,
   val 'a all : 'a -> 'a t/5,
   val 'a depthFirst : ('a -> bool) -> ('a -> 'a t/5) -> 'a -> 'a t/5,
   val 'a depthIter : ('a -> bool) * int -> ('a -> 'a t/5) -> 'a -> 'a t/5,
   val ('a, 'b, 'c) firstF : ('a -> 'b -> 'c t/5) list -> 'a -> 'b -> 'c t/5,
   val ('a, 'b) no : 'a -> 'b t/5,
   val 'a repeat : ('a -> 'a t/5) -> 'a -> 'a t/5,
   val 'a repeatDeterm : ('a -> 'a t/5) -> 'a -> 'a t/5,
   val 'a try : ('a -> 'a t/5) -> 'a -> 'a t/5,
   val ('a, 'b) |@| : ('a -> 'b t/5) * ('a -> 'b t/5) -> 'a -> 'b t/5,
   val ('a, 'b) || : ('a -> 'b t/5) * ('a -> 'b t/5) -> 'a -> 'b t/5}
> signature TAC =
  {val safeSteps : int -> state -> state t/5,
   val quant : int -> state -> state t/5,
   val step : int -> state -> state t/5,
   val depth : state -> state t/5,
   val depthIt : int -> state -> state t/5}
> structure Tac :
  {val depth : state -> state t/5,
   val depthIt : int -> state -> state t/5,
   val quant : int -> state -> state t/5,
   val safeSteps : int -> state -> state t/5,
   val step : int -> state -> state t/5}
[closing file "sample10.sml"]
> val it = () : unit
[opening file "test10.sml"]
> val by = fn : (state -> state t/5) -> unit
  val getState = fn : unit -> state
  val goal = fn : string -> unit
  val pr = fn : state -> unit
> type ('a, 'b) multifun = 'a -> 'b t/5
  val ('b, 'a, 'c) -- = fn : ('a -> 'b t/5) * ('b -> 'c t/5) -> 'a -> 'c t/5
  val 'a all = fn : 'a -> 'a t/5
  val 'a depthFirst = fn : ('a -> bool) -> ('a -> 'a t/5) -> 'a -> 'a t/5
  val 'a depthIter = fn : ('a -> bool) * int -> ('a -> 'a t/5) -> 'a -> 'a t/5
  val ('a, 'b, 'c) firstF = fn :
  ('a -> 'b -> 'c t/5) list -> 'a -> 'b -> 'c t/5
  val ('a, 'b) no = fn : 'a -> 'b t/5
  val 'a repeat = fn : ('a -> 'a t/5) -> 'a -> 'a t/5
  val 'a repeatDeterm = fn : ('a -> 'a t/5) -> 'a -> 'a t/5
  val 'a try = fn : ('a -> 'a t/5) -> 'a -> 'a t/5
  val ('a, 'b) |@| = fn : ('a -> 'b t/5) * ('a -> 'b t/5) -> 'a -> 'b t/5
  val ('a, 'b) || = fn : ('a -> 'b t/5) * ('a -> 'b t/5) -> 'a -> 'b t/5
> val showResult = fn : unit -> unit
> val checkFailed = fn : unit -> string
P & Q --> Q & P
 1. empty  |-  P & Q --> Q & P
> val it = () : unit
P & Q --> Q & P
 1. P & Q  |-  Q & P
> val it = () : unit
P & Q --> Q & P
 1. P, Q  |-  Q & P
> val it = () : unit
P & Q --> Q & P
 1. P, Q  |-  Q
 2. P, Q  |-  P
> val it = () : unit
P & Q --> Q & P
 1. P, Q  |-  Q
> val it = () : unit
P & Q --> Q & P
No subgoals left!
> val it = () : unit
P & Q --> Q & P
> val it = () : unit
(ALL x. P(x)) --> (ALL x. P(x) | Q(x))
 1. empty
    |-  (ALL x. P(x)) --> (ALL x. P(x) | Q(x))
> val it = () : unit
(ALL x. P(x)) --> (ALL x. P(x) | Q(x))
 1. ALL x. P(x)  |-  ALL x. P(x) | Q(x)
> val it = () : unit
(ALL x. P(x)) --> (ALL x. P(x) | Q(x))
 1. ALL x. P(x)  |-  P(_a) | Q(_a)
> val it = () : unit
(ALL x. P(x)) --> (ALL x. P(x) | Q(x))
 1. ALL x. P(x)  |-  P(_a), Q(_a)
> val it = () : unit
(ALL x. P(x)) --> (ALL x. P(x) | Q(x))
 1. P(?_b), ALL x. P(x)  |-  P(_a), Q(_a)
> val it = () : unit
(ALL x. P(x)) --> (ALL x. P(x) | Q(x))
No subgoals left!
> val it = () : unit
(ALL x. P(x)) --> (ALL x. P(x) | Q(x))
> val it = () : unit
EX z. P(z) --> (ALL x. P(x))
 1. empty  |-  EX z. P(z) --> (ALL x. P(x))
> val it = () : unit
EX z. P(z) --> (ALL x. P(x))
 1. empty
    |-  P(?_a) --> (ALL x. P(x)),
        EX z. P(z) --> (ALL x. P(x))
> val it = () : unit
EX z. P(z) --> (ALL x. P(x))
 1. P(?_a)
    |-  ALL x. P(x), EX z. P(z) --> (ALL x. P(x))
> val it = () : unit
EX z. P(z) --> (ALL x. P(x))
 1. P(?_a)
    |-  P(_b), EX z. P(z) --> (ALL x. P(x))
_b not in  ?_a
> val it = () : unit
** Tactic FAILED! **
> val it = () : unit
EX z. P(z) --> (ALL x. P(x))
 1. P(?_a)
    |-  P(?_c) --> (ALL x. P(x)), P(_b),
        EX z. P(z) --> (ALL x. P(x))
_b not in  ?_a
> val it = () : unit
EX z. P(z) --> (ALL x. P(x))
 1. P(?_c), P(?_a)
    |-  ALL x. P(x), P(_b),
        EX z. P(z) --> (ALL x. P(x))
_b not in  ?_a
> val it = () : unit
EX z. P(z) --> (ALL x. P(x))
No subgoals left!
> val it = () : unit
EX z. P(z) --> (ALL x. P(x))
> val it = () : unit
(P & Q) & R --> P & (Q & R)
 1. empty  |-  (P & Q) & R --> P & (Q & R)
> val it = () : unit
(P & Q) & R --> P & (Q & R)
 1. (P & Q) & R  |-  P & (Q & R)
> val it = () : unit
(P & Q) & R --> P & (Q & R)
 1. P & Q, R  |-  P & (Q & R)
> val it = () : unit
(P & Q) & R --> P & (Q & R)
 1. P, Q, R  |-  P & (Q & R)
> val it = () : unit
(P & Q) & R --> P & (Q & R)
 1. P, Q, R  |-  P
 2. P, Q, R  |-  Q & R
> val it = () : unit
(P & Q) & R --> P & (Q & R)
 1. P, Q, R  |-  P
 2. P, Q, R  |-  Q
 3. P, Q, R  |-  R
> val it = () : unit
(P & Q) & R --> P & (Q & R)
 1. P, Q, R  |-  Q
 2. P, Q, R  |-  R
> val it = () : unit
(P & Q) & R --> P & (Q & R)
 1. P, Q, R  |-  R
> val it = () : unit
(P & Q) & R --> P & (Q & R)
No subgoals left!
> val it = () : unit
(P & Q) & R --> P & (Q & R)
> val it = () : unit
(P & Q) & R --> P & (Q & R)
 1. empty  |-  (P & Q) & R --> P & (Q & R)
> val it = () : unit
(P & Q) & R --> P & (Q & R)
 1. P, Q, R  |-  P & (Q & R)
> val it = () : unit
(P & Q) & R --> P & (Q & R)
No subgoals left!
> val it = () : unit
(P & Q) & R --> P & (Q & R)
> val it = () : unit
EX z. P(z) --> (ALL x. P(x))
 1. empty  |-  EX z. P(z) --> (ALL x. P(x))
> val it = () : unit
EX z. P(z) --> (ALL x. P(x))
No subgoals left!
> val it = () : unit
EX z. P(z) --> (ALL x. P(x))
> val it = () : unit
P & Q | R --> (P | R) & (Q | R)
 1. empty  |-  P & Q | R --> (P | R) & (Q | R)
> val it = () : unit
P & Q | R --> (P | R) & (Q | R)
 1. P & Q | R  |-  (P | R) & (Q | R)
> val it = () : unit
P & Q | R --> (P | R) & (Q | R)
 1. P & Q  |-  (P | R) & (Q | R)
 2. R  |-  (P | R) & (Q | R)
> val it = () : unit
P & Q | R --> (P | R) & (Q | R)
 1. P, Q  |-  (P | R) & (Q | R)
 2. R  |-  (P | R) & (Q | R)
> val it = () : unit
P & Q | R --> (P | R) & (Q | R)
 1. P, Q  |-  P | R
 2. P, Q  |-  Q | R
 3. R  |-  (P | R) & (Q | R)
> val it = () : unit
P & Q | R --> (P | R) & (Q | R)
 1. P, Q  |-  P, R
 2. P, Q  |-  Q | R
 3. R  |-  (P | R) & (Q | R)
> val it = () : unit
P & Q | R --> (P | R) & (Q | R)
 1. P, Q  |-  P, R
 2. P, Q  |-  Q, R
 3. R  |-  (P | R) & (Q | R)
> val it = () : unit
P & Q | R --> (P | R) & (Q | R)
 1. P, Q  |-  P, R
 2. P, Q  |-  Q, R
 3. R  |-  P | R
 4. R  |-  Q | R
> val it = () : unit
P & Q | R --> (P | R) & (Q | R)
 1. P, Q  |-  P, R
 2. P, Q  |-  Q, R
 3. R  |-  P, R
 4. R  |-  Q | R
> val it = () : unit
P & Q | R --> (P | R) & (Q | R)
 1. P, Q  |-  P, R
 2. P, Q  |-  Q, R
 3. R  |-  P, R
 4. R  |-  Q, R
> val it = () : unit
P & Q | R --> (P | R) & (Q | R)
 1. P, Q  |-  Q, R
 2. R  |-  P, R
 3. R  |-  Q, R
> val it = () : unit
P & Q | R --> (P | R) & (Q | R)
 1. R  |-  P, R
 2. R  |-  Q, R
> val it = () : unit
P & Q | R --> (P | R) & (Q | R)
 1. R  |-  Q, R
> val it = () : unit
P & Q | R --> (P | R) & (Q | R)
No subgoals left!
> val it = () : unit
P & Q | R --> (P | R) & (Q | R)
> val it = () : unit
(ALL x. P(x) & Q(x)) <->
(ALL x. P(x)) & (ALL x. Q(x))
 1. empty
    |-  (ALL x. P(x) & Q(x)) <->
        (ALL x. P(x)) & (ALL x. Q(x))
> val it = () : unit
(ALL x. P(x) & Q(x)) <->
(ALL x. P(x)) & (ALL x. Q(x))
 1. ALL x. P(x) & Q(x)
    |-  (ALL x. P(x)) & (ALL x. Q(x))
 2. (ALL x. P(x)) & (ALL x. Q(x))
    |-  ALL x. P(x) & Q(x)
> val it = () : unit
(ALL x. P(x) & Q(x)) <->
(ALL x. P(x)) & (ALL x. Q(x))
 1. ALL x. P(x) & Q(x)  |-  ALL x. P(x)
 2. ALL x. P(x) & Q(x)  |-  ALL x. Q(x)
 3. (ALL x. P(x)) & (ALL x. Q(x))
    |-  ALL x. P(x) & Q(x)
> val it = () : unit
(ALL x. P(x) & Q(x)) <->
(ALL x. P(x)) & (ALL x. Q(x))
 1. ALL x. P(x) & Q(x)  |-  P(_a)
 2. ALL x. P(x) & Q(x)  |-  ALL x. Q(x)
 3. (ALL x. P(x)) & (ALL x. Q(x))
    |-  ALL x. P(x) & Q(x)
> val it = () : unit
(ALL x. P(x) & Q(x)) <->
(ALL x. P(x)) & (ALL x. Q(x))
 1. P(?_b) & Q(?_b), ALL x. P(x) & Q(x)  |-  P(_a)
 2. ALL x. P(x) & Q(x)  |-  ALL x. Q(x)
 3. (ALL x. P(x)) & (ALL x. Q(x))
    |-  ALL x. P(x) & Q(x)
> val it = () : unit
(ALL x. P(x) & Q(x)) <->
(ALL x. P(x)) & (ALL x. Q(x))
 1. P(?_b), Q(?_b), ALL x. P(x) & Q(x)  |-  P(_a)
 2. ALL x. P(x) & Q(x)  |-  ALL x. Q(x)
 3. (ALL x. P(x)) & (ALL x. Q(x))
    |-  ALL x. P(x) & Q(x)
> val it = () : unit
(ALL x. P(x) & Q(x)) <->
(ALL x. P(x)) & (ALL x. Q(x))
 1. ALL x. P(x) & Q(x)  |-  ALL x. Q(x)
 2. (ALL x. P(x)) & (ALL x. Q(x))
    |-  ALL x. P(x) & Q(x)
> val it = () : unit
(ALL x. P(x) & Q(x)) <->
(ALL x. P(x)) & (ALL x. Q(x))
 1. ALL x. P(x) & Q(x)  |-  Q(_c)
 2. (ALL x. P(x)) & (ALL x. Q(x))
    |-  ALL x. P(x) & Q(x)
> val it = () : unit
(ALL x. P(x) & Q(x)) <->
(ALL x. P(x)) & (ALL x. Q(x))
 1. P(?_d) & Q(?_d), ALL x. P(x) & Q(x)  |-  Q(_c)
 2. (ALL x. P(x)) & (ALL x. Q(x))
    |-  ALL x. P(x) & Q(x)
> val it = () : unit
(ALL x. P(x) & Q(x)) <->
(ALL x. P(x)) & (ALL x. Q(x))
 1. P(?_d), Q(?_d), ALL x. P(x) & Q(x)  |-  Q(_c)
 2. (ALL x. P(x)) & (ALL x. Q(x))
    |-  ALL x. P(x) & Q(x)
> val it = () : unit
(ALL x. P(x) & Q(x)) <->
(ALL x. P(x)) & (ALL x. Q(x))
 1. (ALL x. P(x)) & (ALL x. Q(x))
    |-  ALL x. P(x) & Q(x)
> val it = () : unit
(ALL x. P(x) & Q(x)) <->
(ALL x. P(x)) & (ALL x. Q(x))
 1. (ALL x. P(x)) & (ALL x. Q(x))
    |-  P(_e) & Q(_e)
> val it = () : unit
(ALL x. P(x) & Q(x)) <->
(ALL x. P(x)) & (ALL x. Q(x))
 1. ALL x. P(x), ALL x. Q(x)  |-  P(_e) & Q(_e)
> val it = () : unit
(ALL x. P(x) & Q(x)) <->
(ALL x. P(x)) & (ALL x. Q(x))
 1. P(?_f), ALL x. Q(x), ALL x. P(x)
    |-  P(_e) & Q(_e)
> val it = () : unit
(ALL x. P(x) & Q(x)) <->
(ALL x. P(x)) & (ALL x. Q(x))
 1. Q(?_g), P(?_f), ALL x. P(x), ALL x. Q(x)
    |-  P(_e) & Q(_e)
> val it = () : unit
(ALL x. P(x) & Q(x)) <->
(ALL x. P(x)) & (ALL x. Q(x))
 1. Q(?_g), P(?_f), ALL x. P(x), ALL x. Q(x)
    |-  P(_e)
 2. Q(?_g), P(?_f), ALL x. P(x), ALL x. Q(x)
    |-  Q(_e)
> val it = () : unit
(ALL x. P(x) & Q(x)) <->
(ALL x. P(x)) & (ALL x. Q(x))
 1. Q(?_g), P(_e), ALL x. P(x), ALL x. Q(x)
    |-  Q(_e)
> val it = () : unit
(ALL x. P(x) & Q(x)) <->
(ALL x. P(x)) & (ALL x. Q(x))
No subgoals left!
> val it = () : unit
(ALL x. P(x) & Q(x)) <->
(ALL x. P(x)) & (ALL x. Q(x))
> val it = () : unit
(ALL x. P(x) & Q(x)) <->
(ALL x. P(x)) & (ALL x. Q(x))
 1. empty
    |-  (ALL x. P(x) & Q(x)) <->
        (ALL x. P(x)) & (ALL x. Q(x))
> val it = () : unit
(ALL x. P(x) & Q(x)) <->
(ALL x. P(x)) & (ALL x. Q(x))
No subgoals left!
> val it = () : unit
(ALL x. P(x) & Q(x)) <->
(ALL x. P(x)) & (ALL x. Q(x))
> val it = () : unit
(EX y. ALL x. Q(x, y)) --> (ALL x. EX y. Q(x, y))
 1. empty
    |-  (EX y. ALL x. Q(x, y)) -->
        (ALL x. EX y. Q(x, y))
> val it = () : unit
(EX y. ALL x. Q(x, y)) --> (ALL x. EX y. Q(x, y))
 1. EX y. ALL x. Q(x, y)  |-  ALL x. EX y. Q(x, y)
> val it = () : unit
(EX y. ALL x. Q(x, y)) --> (ALL x. EX y. Q(x, y))
 1. ALL x. Q(x, _a)  |-  ALL x. EX y. Q(x, y)
> val it = () : unit
(EX y. ALL x. Q(x, y)) --> (ALL x. EX y. Q(x, y))
 1. ALL x. Q(x, _a)  |-  EX y. Q(_b, y)
> val it = () : unit
(EX y. ALL x. Q(x, y)) --> (ALL x. EX y. Q(x, y))
 1. Q(?_c, _a), ALL x. Q(x, _a)
    |-  EX y. Q(_b, y)
> val it = () : unit
(EX y. ALL x. Q(x, y)) --> (ALL x. EX y. Q(x, y))
 1. Q(?_c, _a), ALL x. Q(x, _a)
    |-  Q(_b, ?_d), EX y. Q(_b, y)
> val it = () : unit
(EX y. ALL x. Q(x, y)) --> (ALL x. EX y. Q(x, y))
No subgoals left!
> val it = () : unit
(EX y. ALL x. Q(x, y)) --> (ALL x. EX y. Q(x, y))
> val it = () : unit
(ALL x. EX y. Q(x, y)) --> (EX y. ALL x. Q(x, y))
 1. empty
    |-  (ALL x. EX y. Q(x, y)) -->
        (EX y. ALL x. Q(x, y))
> val it = () : unit
(ALL x. EX y. Q(x, y)) --> (EX y. ALL x. Q(x, y))
 1. ALL x. EX y. Q(x, y)  |-  EX y. ALL x. Q(x, y)
> val it = () : unit
(ALL x. EX y. Q(x, y)) --> (EX y. ALL x. Q(x, y))
 1. EX y. Q(?_a, y), ALL x. EX y. Q(x, y)
    |-  EX y. ALL x. Q(x, y)
> val it = () : unit
(ALL x. EX y. Q(x, y)) --> (EX y. ALL x. Q(x, y))
 1. Q(?_a, _b), ALL x. EX y. Q(x, y)
    |-  EX y. ALL x. Q(x, y)
_b not in  ?_a
> val it = () : unit
(ALL x. EX y. Q(x, y)) --> (EX y. ALL x. Q(x, y))
 1. Q(?_a, _b), ALL x. EX y. Q(x, y)
    |-  ALL x. Q(x, ?_c), EX y. ALL x. Q(x, y)
_b not in  ?_a
> val it = () : unit
(ALL x. EX y. Q(x, y)) --> (EX y. ALL x. Q(x, y))
 1. Q(?_a, _b), ALL x. EX y. Q(x, y)
    |-  Q(_d, ?_c), EX y. ALL x. Q(x, y)
_b not in  ?_a
_d not in  ?_a ?_c
> val it = () : unit
** Tactic FAILED! **
> val it = () : unit
> val it = "Failed, as expected..." : string
(EX x. P(x) --> Q) <-> ((ALL x. P(x)) --> Q)
 1. empty
    |-  (EX x. P(x) --> Q) <->
        ((ALL x. P(x)) --> Q)
> val it = () : unit
(EX x. P(x) --> Q) <-> ((ALL x. P(x)) --> Q)
 1. EX x. P(x) --> Q  |-  (ALL x. P(x)) --> Q
 2. (ALL x. P(x)) --> Q  |-  EX x. P(x) --> Q
> val it = () : unit
(EX x. P(x) --> Q) <-> ((ALL x. P(x)) --> Q)
 1. ALL x. P(x), EX x. P(x) --> Q  |-  Q
 2. (ALL x. P(x)) --> Q  |-  EX x. P(x) --> Q
> val it = () : unit
(EX x. P(x) --> Q) <-> ((ALL x. P(x)) --> Q)
 1. P(_a) --> Q, ALL x. P(x)  |-  Q
 2. (ALL x. P(x)) --> Q  |-  EX x. P(x) --> Q
> val it = () : unit
(EX x. P(x) --> Q) <-> ((ALL x. P(x)) --> Q)
 1. P(?_b), P(_a) --> Q, ALL x. P(x)  |-  Q
 2. (ALL x. P(x)) --> Q  |-  EX x. P(x) --> Q
> val it = () : unit
(EX x. P(x) --> Q) <-> ((ALL x. P(x)) --> Q)
 1. Q, P(?_b), ALL x. P(x)  |-  Q
 2. P(?_b), ALL x. P(x)  |-  P(_a), Q
 3. (ALL x. P(x)) --> Q  |-  EX x. P(x) --> Q
> val it = () : unit
(EX x. P(x) --> Q) <-> ((ALL x. P(x)) --> Q)
 1. P(?_b), ALL x. P(x)  |-  P(_a), Q
 2. (ALL x. P(x)) --> Q  |-  EX x. P(x) --> Q
> val it = () : unit
(EX x. P(x) --> Q) <-> ((ALL x. P(x)) --> Q)
 1. (ALL x. P(x)) --> Q  |-  EX x. P(x) --> Q
> val it = () : unit
(EX x. P(x) --> Q) <-> ((ALL x. P(x)) --> Q)
 1. Q  |-  EX x. P(x) --> Q
 2. empty  |-  ALL x. P(x), EX x. P(x) --> Q
> val it = () : unit
(EX x. P(x) --> Q) <-> ((ALL x. P(x)) --> Q)
 1. Q  |-  P(?_c) --> Q, EX x. P(x) --> Q
 2. empty  |-  ALL x. P(x), EX x. P(x) --> Q
> val it = () : unit
(EX x. P(x) --> Q) <-> ((ALL x. P(x)) --> Q)
 1. P(?_c), Q  |-  Q, EX x. P(x) --> Q
 2. empty  |-  ALL x. P(x), EX x. P(x) --> Q
> val it = () : unit
(EX x. P(x) --> Q) <-> ((ALL x. P(x)) --> Q)
 1. empty  |-  ALL x. P(x), EX x. P(x) --> Q
> val it = () : unit
(EX x. P(x) --> Q) <-> ((ALL x. P(x)) --> Q)
 1. empty  |-  P(_d), EX x. P(x) --> Q
> val it = () : unit
(EX x. P(x) --> Q) <-> ((ALL x. P(x)) --> Q)
 1. empty
    |-  P(?_e) --> Q, P(_d), EX x. P(x) --> Q
> val it = () : unit
(EX x. P(x) --> Q) <-> ((ALL x. P(x)) --> Q)
 1. P(?_e)  |-  Q, P(_d), EX x. P(x) --> Q
> val it = () : unit
(EX x. P(x) --> Q) <-> ((ALL x. P(x)) --> Q)
No subgoals left!
> val it = () : unit
(EX x. P(x) --> Q) <-> ((ALL x. P(x)) --> Q)
> val it = () : unit
commutative laws of & and | 
> val it = () : unit
P & Q --> Q & P
 1. empty  |-  P & Q --> Q & P
> val it = () : unit
P & Q --> Q & P
No subgoals left!
> val it = () : unit
P & Q --> Q & P
> val it = () : unit
P | Q --> Q | P
 1. empty  |-  P | Q --> Q | P
> val it = () : unit
P | Q --> Q | P
No subgoals left!
> val it = () : unit
P | Q --> Q | P
> val it = () : unit
associative laws of & and | 
> val it = () : unit
(P & Q) & R --> P & (Q & R)
 1. empty  |-  (P & Q) & R --> P & (Q & R)
> val it = () : unit
(P & Q) & R --> P & (Q & R)
No subgoals left!
> val it = () : unit
(P & Q) & R --> P & (Q & R)
> val it = () : unit
(P | Q) | R --> P | (Q | R)
 1. empty  |-  (P | Q) | R --> P | (Q | R)
> val it = () : unit
(P | Q) | R --> P | (Q | R)
No subgoals left!
> val it = () : unit
(P | Q) | R --> P | (Q | R)
> val it = () : unit
distributive laws of & and | 
> val it = () : unit
P & Q | R --> (P | R) & (Q | R)
 1. empty  |-  P & Q | R --> (P | R) & (Q | R)
> val it = () : unit
P & Q | R --> (P | R) & (Q | R)
No subgoals left!
> val it = () : unit
P & Q | R --> (P | R) & (Q | R)
> val it = () : unit
(P | R) & (Q | R) --> P & Q | R
 1. empty  |-  (P | R) & (Q | R) --> P & Q | R
> val it = () : unit
(P | R) & (Q | R) --> P & Q | R
No subgoals left!
> val it = () : unit
(P | R) & (Q | R) --> P & Q | R
> val it = () : unit
(P | Q) & R --> P & R | Q & R
 1. empty  |-  (P | Q) & R --> P & R | Q & R
> val it = () : unit
(P | Q) & R --> P & R | Q & R
No subgoals left!
> val it = () : unit
(P | Q) & R --> P & R | Q & R
> val it = () : unit
P & R | Q & R --> (P | Q) & R
 1. empty  |-  P & R | Q & R --> (P | Q) & R
> val it = () : unit
P & R | Q & R --> (P | Q) & R
No subgoals left!
> val it = () : unit
P & R | Q & R --> (P | Q) & R
> val it = () : unit
Laws involving implication
> val it = () : unit
(P --> R) & (Q --> R) <-> (P | Q --> R)
 1. empty
    |-  (P --> R) & (Q --> R) <-> (P | Q --> R)
> val it = () : unit
(P --> R) & (Q --> R) <-> (P | Q --> R)
No subgoals left!
> val it = () : unit
(P --> R) & (Q --> R) <-> (P | Q --> R)
> val it = () : unit
(P & Q --> R) <-> (P --> (Q --> R))
 1. empty  |-  (P & Q --> R) <-> (P --> (Q --> R))
> val it = () : unit
(P & Q --> R) <-> (P --> (Q --> R))
No subgoals left!
> val it = () : unit
(P & Q --> R) <-> (P --> (Q --> R))
> val it = () : unit
((P --> R) --> R) -->
(((Q --> R) --> R) --> ((P & Q --> R) --> R))
 1. empty
    |-  ((P --> R) --> R) -->
        (((Q --> R) --> R) -->
         ((P & Q --> R) --> R))
> val it = () : unit
((P --> R) --> R) -->
(((Q --> R) --> R) --> ((P & Q --> R) --> R))
No subgoals left!
> val it = () : unit
((P --> R) --> R) -->
(((Q --> R) --> R) --> ((P & Q --> R) --> R))
> val it = () : unit
~(P --> R) --> (~(Q --> R) --> ~((P & Q) --> R))
 1. empty
    |-  ~(P --> R) -->
        (~(Q --> R) --> ~((P & Q) --> R))
> val it = () : unit
~(P --> R) --> (~(Q --> R) --> ~((P & Q) --> R))
No subgoals left!
> val it = () : unit
~(P --> R) --> (~(Q --> R) --> ~((P & Q) --> R))
> val it = () : unit
(P --> Q & R) <-> (P --> Q) & (P --> R)
 1. empty
    |-  (P --> Q & R) <-> (P --> Q) & (P --> R)
> val it = () : unit
(P --> Q & R) <-> (P --> Q) & (P --> R)
No subgoals left!
> val it = () : unit
(P --> Q & R) <-> (P --> Q) & (P --> R)
> val it = () : unit
Propositions-as-types
> val it = () : unit
P --> (Q --> P)
 1. empty  |-  P --> (Q --> P)
> val it = () : unit
P --> (Q --> P)
No subgoals left!
> val it = () : unit
P --> (Q --> P)
> val it = () : unit
(P --> (Q --> R)) --> ((P --> Q) --> (P --> R))
 1. empty
    |-  (P --> (Q --> R)) -->
        ((P --> Q) --> (P --> R))
> val it = () : unit
(P --> (Q --> R)) --> ((P --> Q) --> (P --> R))
No subgoals left!
> val it = () : unit
(P --> (Q --> R)) --> ((P --> Q) --> (P --> R))
> val it = () : unit
(P --> Q) | (P --> R) --> (P --> Q | R)
 1. empty
    |-  (P --> Q) | (P --> R) --> (P --> Q | R)
> val it = () : unit
(P --> Q) | (P --> R) --> (P --> Q | R)
No subgoals left!
> val it = () : unit
(P --> Q) | (P --> R) --> (P --> Q | R)
> val it = () : unit
(P --> Q) --> (~Q --> ~P)
 1. empty  |-  (P --> Q) --> (~Q --> ~P)
> val it = () : unit
(P --> Q) --> (~Q --> ~P)
No subgoals left!
> val it = () : unit
(P --> Q) --> (~Q --> ~P)
> val it = () : unit
Classical examples
> val it = () : unit
(P --> Q | R) --> (P --> Q) | (P --> R)
 1. empty
    |-  (P --> Q | R) --> (P --> Q) | (P --> R)
> val it = () : unit
(P --> Q | R) --> (P --> Q) | (P --> R)
No subgoals left!
> val it = () : unit
(P --> Q | R) --> (P --> Q) | (P --> R)
> val it = () : unit
(P <-> Q) <-> (Q <-> P)
 1. empty  |-  (P <-> Q) <-> (Q <-> P)
> val it = () : unit
(P <-> Q) <-> (Q <-> P)
No subgoals left!
> val it = () : unit
(P <-> Q) <-> (Q <-> P)
> val it = () : unit
~(P <-> ~P)
 1. empty  |-  ~(P <-> ~P)
> val it = () : unit
~(P <-> ~P)
No subgoals left!
> val it = () : unit
~(P <-> ~P)
> val it = () : unit
*** Quantifier examples ***
> val it = () : unit
(ALL x. ALL y. P(x, y)) -->
(ALL y. ALL x. P(x, y))
 1. empty
    |-  (ALL x. ALL y. P(x, y)) -->
        (ALL y. ALL x. P(x, y))
> val it = () : unit
(ALL x. ALL y. P(x, y)) -->
(ALL y. ALL x. P(x, y))
No subgoals left!
> val it = () : unit
(ALL x. ALL y. P(x, y)) -->
(ALL y. ALL x. P(x, y))
> val it = () : unit
(EX x. EX y. P(x, y)) --> (EX y. EX x. P(x, y))
 1. empty
    |-  (EX x. EX y. P(x, y)) -->
        (EX y. EX x. P(x, y))
> val it = () : unit
(EX x. EX y. P(x, y)) --> (EX y. EX x. P(x, y))
No subgoals left!
> val it = () : unit
(EX x. EX y. P(x, y)) --> (EX y. EX x. P(x, y))
> val it = () : unit
(ALL x. P(x)) | (ALL x. Q(x)) -->
(ALL x. P(x) | Q(x))
 1. empty
    |-  (ALL x. P(x)) | (ALL x. Q(x)) -->
        (ALL x. P(x) | Q(x))
> val it = () : unit
(ALL x. P(x)) | (ALL x. Q(x)) -->
(ALL x. P(x) | Q(x))
No subgoals left!
> val it = () : unit
(ALL x. P(x)) | (ALL x. Q(x)) -->
(ALL x. P(x) | Q(x))
> val it = () : unit
(ALL x. P --> Q(x)) <-> (P --> (ALL x. Q(x)))
 1. empty
    |-  (ALL x. P --> Q(x)) <->
        (P --> (ALL x. Q(x)))
> val it = () : unit
(ALL x. P --> Q(x)) <-> (P --> (ALL x. Q(x)))
No subgoals left!
> val it = () : unit
(ALL x. P --> Q(x)) <-> (P --> (ALL x. Q(x)))
> val it = () : unit
(ALL x. P(x) --> Q) <-> ((EX x. P(x)) --> Q)
 1. empty
    |-  (ALL x. P(x) --> Q) <->
        ((EX x. P(x)) --> Q)
> val it = () : unit
(ALL x. P(x) --> Q) <-> ((EX x. P(x)) --> Q)
No subgoals left!
> val it = () : unit
(ALL x. P(x) --> Q) <-> ((EX x. P(x)) --> Q)
> val it = () : unit
Some harder ones
> val it = () : unit
(EX x. P(x) | Q(x)) <->
(EX x. P(x)) | (EX x. Q(x))
 1. empty
    |-  (EX x. P(x) | Q(x)) <->
        (EX x. P(x)) | (EX x. Q(x))
> val it = () : unit
(EX x. P(x) | Q(x)) <->
(EX x. P(x)) | (EX x. Q(x))
No subgoals left!
> val it = () : unit
(EX x. P(x) | Q(x)) <->
(EX x. P(x)) | (EX x. Q(x))
> val it = () : unit
(EX x. P(x) & Q(x)) -->
(EX x. P(x)) & (EX x. Q(x))
 1. empty
    |-  (EX x. P(x) & Q(x)) -->
        (EX x. P(x)) & (EX x. Q(x))
> val it = () : unit
(EX x. P(x) & Q(x)) -->
(EX x. P(x)) & (EX x. Q(x))
No subgoals left!
> val it = () : unit
(EX x. P(x) & Q(x)) -->
(EX x. P(x)) & (EX x. Q(x))
> val it = () : unit
Basic test of quantifier reasoning
> val it = () : unit
(EX y. ALL x. Q(x, y)) --> (ALL x. EX y. Q(x, y))
 1. empty
    |-  (EX y. ALL x. Q(x, y)) -->
        (ALL x. EX y. Q(x, y))
> val it = () : unit
(EX y. ALL x. Q(x, y)) --> (ALL x. EX y. Q(x, y))
No subgoals left!
> val it = () : unit
(EX y. ALL x. Q(x, y)) --> (ALL x. EX y. Q(x, y))
> val it = () : unit
(ALL x. Q(x)) --> (EX x. Q(x))
 1. empty  |-  (ALL x. Q(x)) --> (EX x. Q(x))
> val it = () : unit
(ALL x. Q(x)) --> (EX x. Q(x))
No subgoals left!
> val it = () : unit
(ALL x. Q(x)) --> (EX x. Q(x))
> val it = () : unit
The following should fail, as they are false!
> val it = () : unit
(EX x. Q(x)) --> (ALL x. Q(x))
 1. empty  |-  (EX x. Q(x)) --> (ALL x. Q(x))
> val it = () : unit
** Tactic FAILED! **
> val it = () : unit
> val it = "Failed, as expected..." : string
P(?a) --> (ALL x. P(x))
 1. empty  |-  P(?a) --> (ALL x. P(x))
> val it = () : unit
** Tactic FAILED! **
> val it = () : unit
> val it = "Failed, as expected..." : string
(P(?a) --> (ALL x. Q(x))) -->
(ALL x. P(x) --> Q(x))
 1. empty
    |-  (P(?a) --> (ALL x. Q(x))) -->
        (ALL x. P(x) --> Q(x))
> val it = () : unit
** Tactic FAILED! **
> val it = () : unit
> val it = "Failed, as expected..." : string
Back to things that are provable...
> val it = () : unit
(ALL x. P(x) --> Q(x)) & (EX x. P(x)) -->
(EX x. Q(x))
 1. empty
    |-  (ALL x. P(x) --> Q(x)) & (EX x. P(x)) -->
        (EX x. Q(x))
> val it = () : unit
(ALL x. P(x) --> Q(x)) & (EX x. P(x)) -->
(EX x. Q(x))
No subgoals left!
> val it = () : unit
(ALL x. P(x) --> Q(x)) & (EX x. P(x)) -->
(EX x. Q(x))
> val it = () : unit
(P --> (EX x. Q(x))) & P --> (EX x. Q(x))
 1. empty
    |-  (P --> (EX x. Q(x))) & P --> (EX x. Q(x))
> val it = () : unit
(P --> (EX x. Q(x))) & P --> (EX x. Q(x))
No subgoals left!
> val it = () : unit
(P --> (EX x. Q(x))) & P --> (EX x. Q(x))
> val it = () : unit
(ALL x. P(x) --> Q(f(x))) &
((ALL x. Q(x) --> R(g(x))) & P(d)) --> R(?a)
 1. empty
    |-  (ALL x. P(x) --> Q(f(x))) &
        ((ALL x. Q(x) --> R(g(x))) & P(d)) -->
        R(?a)
> val it = () : unit
(ALL x. P(x) --> Q(f(x))) &
((ALL x. Q(x) --> R(g(x))) & P(d)) --> R(g(f(d)))
No subgoals left!
> val it = () : unit
(ALL x. P(x) --> Q(f(x))) &
((ALL x. Q(x) --> R(g(x))) & P(d)) --> R(g(f(d)))
> val it = () : unit
(ALL x. Q(x)) --> (EX x. Q(x))
 1. empty  |-  (ALL x. Q(x)) --> (EX x. Q(x))
> val it = () : unit
(ALL x. Q(x)) --> (EX x. Q(x))
No subgoals left!
> val it = () : unit
(ALL x. Q(x)) --> (EX x. Q(x))
> val it = () : unit
Classical Logic: examples with quantifiers.
> val it = () : unit
(ALL x. P(x) & Q(x)) <->
(ALL x. P(x)) & (ALL x. Q(x))
 1. empty
    |-  (ALL x. P(x) & Q(x)) <->
        (ALL x. P(x)) & (ALL x. Q(x))
> val it = () : unit
(ALL x. P(x) & Q(x)) <->
(ALL x. P(x)) & (ALL x. Q(x))
No subgoals left!
> val it = () : unit
(ALL x. P(x) & Q(x)) <->
(ALL x. P(x)) & (ALL x. Q(x))
> val it = () : unit
(EX x. P --> Q(x)) <-> (P --> (EX x. Q(x)))
 1. empty
    |-  (EX x. P --> Q(x)) <->
        (P --> (EX x. Q(x)))
> val it = () : unit
(EX x. P --> Q(x)) <-> (P --> (EX x. Q(x)))
No subgoals left!
> val it = () : unit
(EX x. P --> Q(x)) <-> (P --> (EX x. Q(x)))
> val it = () : unit
(EX x. P(x) --> Q) <-> ((ALL x. P(x)) --> Q)
 1. empty
    |-  (EX x. P(x) --> Q) <->
        ((ALL x. P(x)) --> Q)
> val it = () : unit
(EX x. P(x) --> Q) <-> ((ALL x. P(x)) --> Q)
No subgoals left!
> val it = () : unit
(EX x. P(x) --> Q) <-> ((ALL x. P(x)) --> Q)
> val it = () : unit
(ALL x. P(x)) | Q <-> (ALL x. P(x) | Q)
 1. empty
    |-  (ALL x. P(x)) | Q <-> (ALL x. P(x) | Q)
> val it = () : unit
(ALL x. P(x)) | Q <-> (ALL x. P(x) | Q)
No subgoals left!
> val it = () : unit
(ALL x. P(x)) | Q <-> (ALL x. P(x) | Q)
> val it = () : unit
Harder proofs 
> val it = () : unit
(ALL x. P(x) --> P(f(x))) & P(d) --> P(f(f(f(d))))
 1. empty
    |-  (ALL x. P(x) --> P(f(x))) & P(d) -->
        P(f(f(f(d))))
> val it = () : unit
(ALL x. P(x) --> P(f(x))) & P(d) --> P(f(f(f(d))))
No subgoals left!
> val it = () : unit
(ALL x. P(x) --> P(f(x))) & P(d) --> P(f(f(f(d))))
> val it = () : unit
EX x. P(x) --> P(a) & P(b)
 1. empty  |-  EX x. P(x) --> P(a) & P(b)
> val it = () : unit
EX x. P(x) --> P(a) & P(b)
No subgoals left!
> val it = () : unit
EX x. P(x) --> P(a) & P(b)
> val it = () : unit
EX z. P(z) --> (ALL x. P(x))
 1. empty  |-  EX z. P(z) --> (ALL x. P(x))
> val it = () : unit
EX z. P(z) --> (ALL x. P(x))
No subgoals left!
> val it = () : unit
EX z. P(z) --> (ALL x. P(x))
> val it = () : unit
Some slow ones
> val it = () : unit
(ALL x. ALL y. P(x) --> Q(y)) <->
((EX x. P(x)) --> (ALL y. Q(y)))
 1. empty
    |-  (ALL x. ALL y. P(x) --> Q(y)) <->
        ((EX x. P(x)) --> (ALL y. Q(y)))
> val it = () : unit
(ALL x. ALL y. P(x) --> Q(y)) <->
((EX x. P(x)) --> (ALL y. Q(y)))
No subgoals left!
> val it = () : unit
(ALL x. ALL y. P(x) --> Q(y)) <->
((EX x. P(x)) --> (ALL y. Q(y)))
> val it = () : unit
(EX x. EX y. P(x) & Q(x, y)) <->
(EX x. P(x) & (EX y. Q(x, y)))
 1. empty
    |-  (EX x. EX y. P(x) & Q(x, y)) <->
        (EX x. P(x) & (EX y. Q(x, y)))
> val it = () : unit
(EX x. EX y. P(x) & Q(x, y)) <->
(EX x. P(x) & (EX y. Q(x, y)))
No subgoals left!
> val it = () : unit
(EX x. EX y. P(x) & Q(x, y)) <->
(EX x. P(x) & (EX y. Q(x, y)))
> val it = () : unit
(EX y. ALL x. P(x) --> Q(x, y)) -->
(ALL x. P(x) --> (EX y. Q(x, y)))
 1. empty
    |-  (EX y. ALL x. P(x) --> Q(x, y)) -->
        (ALL x. P(x) --> (EX y. Q(x, y)))
> val it = () : unit
(EX y. ALL x. P(x) --> Q(x, y)) -->
(ALL x. P(x) --> (EX y. Q(x, y)))
No subgoals left!
> val it = () : unit
(EX y. ALL x. P(x) --> Q(x, y)) -->
(ALL x. P(x) --> (EX y. Q(x, y)))
> val it = () : unit
(EX z. P(z)) & (EX w. Q(w)) -->
((ALL z. P(z) --> R(z)) &
 (ALL w. Q(w) --> S(w)) <->
 (ALL z. ALL w. P(z) & Q(w) --> R(z) & S(w)))
 1. empty
    |-  (EX z. P(z)) & (EX w. Q(w)) -->
        ((ALL z. P(z) --> R(z)) &
         (ALL w. Q(w) --> S(w)) <->
         (ALL z.
            ALL w. P(z) & Q(w) --> R(z) & S(w)))
> val it = () : unit
(EX z. P(z)) & (EX w. Q(w)) -->
((ALL z. P(z) --> R(z)) &
 (ALL w. Q(w) --> S(w)) <->
 (ALL z. ALL w. P(z) & Q(w) --> R(z) & S(w)))
No subgoals left!
> val it = () : unit
(EX z. P(z)) & (EX w. Q(w)) -->
((ALL z. P(z) --> R(z)) &
 (ALL w. Q(w) --> S(w)) <->
 (ALL z. ALL w. P(z) & Q(w) --> R(z) & S(w)))
> val it = () : unit
EX x.
  EX X.
    ALL y.
      EX z.
        EX Z.
          (~P(y, y) | (P(x, x) | ~S(z, x))) &
          ((S(x, y) | (~S(y, z) | Q(Z, Z))) &
           (Q(X, y) | (~Q(y, Z) | S(X, X))))
 1. empty
    |-  EX x.
          EX X.
            ALL y.
              EX z.
                EX Z.
                  (~P(y, y) |
                   (P(x, x) | ~S(z, x))) &
                  ((S(x, y) |
                    (~S(y, z) | Q(Z, Z))) &
                   (Q(X, y) |
                    (~Q(y, Z) | S(X, X))))
> val it = () : unit
Pelletier's examples
> val it = () : unit
(P --> Q) <-> (~Q --> ~P)
 1. empty  |-  (P --> Q) <-> (~Q --> ~P)
> val it = () : unit
(P --> Q) <-> (~Q --> ~P)
No subgoals left!
> val it = () : unit
(P --> Q) <-> (~Q --> ~P)
> val it = () : unit
~~P <-> P
 1. empty  |-  ~~P <-> P
> val it = () : unit
~~P <-> P
No subgoals left!
> val it = () : unit
~~P <-> P
> val it = () : unit
~(P --> Q) --> (Q --> P)
 1. empty  |-  ~(P --> Q) --> (Q --> P)
> val it = () : unit
~(P --> Q) --> (Q --> P)
No subgoals left!
> val it = () : unit
~(P --> Q) --> (Q --> P)
> val it = () : unit
(~P --> Q) <-> (~Q --> P)
 1. empty  |-  (~P --> Q) <-> (~Q --> P)
> val it = () : unit
(~P --> Q) <-> (~Q --> P)
No subgoals left!
> val it = () : unit
(~P --> Q) <-> (~Q --> P)
> val it = () : unit
(P | Q --> P | R) --> P | (Q --> R)
 1. empty  |-  (P | Q --> P | R) --> P | (Q --> R)
> val it = () : unit
(P | Q --> P | R) --> P | (Q --> R)
No subgoals left!
> val it = () : unit
(P | Q --> P | R) --> P | (Q --> R)
> val it = () : unit
P | ~P
 1. empty  |-  P | ~P
> val it = () : unit
P | ~P
No subgoals left!
> val it = () : unit
P | ~P
> val it = () : unit
P | ~~~P
 1. empty  |-  P | ~~~P
> val it = () : unit
P | ~~~P
No subgoals left!
> val it = () : unit
P | ~~~P
> val it = () : unit
((P --> Q) --> P) --> P
 1. empty  |-  ((P --> Q) --> P) --> P
> val it = () : unit
((P --> Q) --> P) --> P
No subgoals left!
> val it = () : unit
((P --> Q) --> P) --> P
> val it = () : unit
(P | Q) & ((~P | Q) & (P | ~Q)) --> ~(~P | ~Q)
 1. empty
    |-  (P | Q) & ((~P | Q) & (P | ~Q)) -->
        ~(~P | ~Q)
> val it = () : unit
(P | Q) & ((~P | Q) & (P | ~Q)) --> ~(~P | ~Q)
No subgoals left!
> val it = () : unit
(P | Q) & ((~P | Q) & (P | ~Q)) --> ~(~P | ~Q)
> val it = () : unit
(Q --> R) &
((R --> (P & Q)) & (P --> (Q | R))) --> (P <-> Q)
 1. empty
    |-  (Q --> R) &
        ((R --> (P & Q)) & (P --> (Q | R))) -->
        (P <-> Q)
> val it = () : unit
(Q --> R) &
((R --> (P & Q)) & (P --> (Q | R))) --> (P <-> Q)
No subgoals left!
> val it = () : unit
(Q --> R) &
((R --> (P & Q)) & (P --> (Q | R))) --> (P <-> Q)
> val it = () : unit
P <-> P
 1. empty  |-  P <-> P
> val it = () : unit
P <-> P
No subgoals left!
> val it = () : unit
P <-> P
> val it = () : unit
((P <-> Q) <-> R) <-> (P <-> (Q <-> R))
 1. empty
    |-  ((P <-> Q) <-> R) <-> (P <-> (Q <-> R))
> val it = () : unit
((P <-> Q) <-> R) <-> (P <-> (Q <-> R))
No subgoals left!
> val it = () : unit
((P <-> Q) <-> R) <-> (P <-> (Q <-> R))
> val it = () : unit
P | Q & R <-> (P | Q) & (P | R)
 1. empty  |-  P | Q & R <-> (P | Q) & (P | R)
> val it = () : unit
P | Q & R <-> (P | Q) & (P | R)
No subgoals left!
> val it = () : unit
P | Q & R <-> (P | Q) & (P | R)
> val it = () : unit
(P <-> Q) <-> (Q | ~P) & (~Q | P)
 1. empty  |-  (P <-> Q) <-> (Q | ~P) & (~Q | P)
> val it = () : unit
(P <-> Q) <-> (Q | ~P) & (~Q | P)
No subgoals left!
> val it = () : unit
(P <-> Q) <-> (Q | ~P) & (~Q | P)
> val it = () : unit
(P --> Q) <-> ~P | Q
 1. empty  |-  (P --> Q) <-> ~P | Q
> val it = () : unit
(P --> Q) <-> ~P | Q
No subgoals left!
> val it = () : unit
(P --> Q) <-> ~P | Q
> val it = () : unit
(P --> Q) | (Q --> P)
 1. empty  |-  (P --> Q) | (Q --> P)
> val it = () : unit
(P --> Q) | (Q --> P)
No subgoals left!
> val it = () : unit
(P --> Q) | (Q --> P)
> val it = () : unit
(P & (Q --> R) --> S) <->
(~P | (Q | S)) & (~P | (~R | S))
 1. empty
    |-  (P & (Q --> R) --> S) <->
        (~P | (Q | S)) & (~P | (~R | S))
> val it = () : unit
(P & (Q --> R) --> S) <->
(~P | (Q | S)) & (~P | (~R | S))
No subgoals left!
> val it = () : unit
(P & (Q --> R) --> S) <->
(~P | (Q | S)) & (~P | (~R | S))
> val it = () : unit
Problem 18. 
> val it = () : unit
EX y. ALL x. P(y) --> P(x)
 1. empty  |-  EX y. ALL x. P(y) --> P(x)
> val it = () : unit
EX y. ALL x. P(y) --> P(x)
No subgoals left!
> val it = () : unit
EX y. ALL x. P(y) --> P(x)
> val it = () : unit
Problem 19. 
> val it = () : unit
EX x.
  ALL y.
    ALL z. (P(y) --> Q(z)) --> (P(x) --> Q(x))
 1. empty
    |-  EX x.
          ALL y.
            ALL z.
              (P(y) --> Q(z)) --> (P(x) --> Q(x))
> val it = () : unit
EX x.
  ALL y.
    ALL z. (P(y) --> Q(z)) --> (P(x) --> Q(x))
No subgoals left!
> val it = () : unit
EX x.
  ALL y.
    ALL z. (P(y) --> Q(z)) --> (P(x) --> Q(x))
> val it = () : unit
Problem 20. 
> val it = () : unit
(ALL x.
   ALL y.
     EX z. ALL w. P(x) & Q(y) --> R(z) & S(w)) -->
((EX x. EX y. P(x) & Q(y)) --> (EX z. R(z)))
 1. empty
    |-  (ALL x.
           ALL y.
             EX z.
               ALL w.
                 P(x) & Q(y) --> R(z) & S(w)) -->
        ((EX x. EX y. P(x) & Q(y)) -->
         (EX z. R(z)))
> val it = () : unit
(ALL x.
   ALL y.
     EX z. ALL w. P(x) & Q(y) --> R(z) & S(w)) -->
((EX x. EX y. P(x) & Q(y)) --> (EX z. R(z)))
No subgoals left!
> val it = () : unit
(ALL x.
   ALL y.
     EX z. ALL w. P(x) & Q(y) --> R(z) & S(w)) -->
((EX x. EX y. P(x) & Q(y)) --> (EX z. R(z)))
> val it = () : unit
Problem 21.  
> val it = () : unit
(EX x. P --> Q(x)) & (EX x. Q(x) --> P) -->
(EX x. P <-> Q(x))
 1. empty
    |-  (EX x. P --> Q(x)) &
        (EX x. Q(x) --> P) --> (EX x. P <-> Q(x))
> val it = () : unit
(EX x. P --> Q(x)) & (EX x. Q(x) --> P) -->
(EX x. P <-> Q(x))
No subgoals left!
> val it = () : unit
(EX x. P --> Q(x)) & (EX x. Q(x) --> P) -->
(EX x. P <-> Q(x))
> val it = () : unit
Problem 22
> val it = () : unit
(ALL x. P <-> Q(x)) --> (P <-> (ALL x. Q(x)))
 1. empty
    |-  (ALL x. P <-> Q(x)) -->
        (P <-> (ALL x. Q(x)))
> val it = () : unit
(ALL x. P <-> Q(x)) --> (P <-> (ALL x. Q(x)))
No subgoals left!
> val it = () : unit
(ALL x. P <-> Q(x)) --> (P <-> (ALL x. Q(x)))
> val it = () : unit
Problem 23
> val it = () : unit
(ALL x. P | Q(x)) <-> P | (ALL x. Q(x))
 1. empty
    |-  (ALL x. P | Q(x)) <-> P | (ALL x. Q(x))
> val it = () : unit
(ALL x. P | Q(x)) <-> P | (ALL x. Q(x))
No subgoals left!
> val it = () : unit
(ALL x. P | Q(x)) <-> P | (ALL x. Q(x))
> val it = () : unit
Problem 24
> val it = () : unit
~(EX x. S(x) & Q(x)) &
((ALL x. P(x) --> Q(x) | R(x)) &
 ((~(EX x. P(x)) --> (EX x. Q(x))) &
  (ALL x. Q(x) | R(x) --> S(x)))) -->
(EX x. P(x) & R(x))
 1. empty
    |-  ~(EX x. S(x) & Q(x)) &
        ((ALL x. P(x) --> Q(x) | R(x)) &
         ((~(EX x. P(x)) --> (EX x. Q(x))) &
          (ALL x. Q(x) | R(x) --> S(x)))) -->
        (EX x. P(x) & R(x))
> val it = () : unit
~(EX x. S(x) & Q(x)) &
((ALL x. P(x) --> Q(x) | R(x)) &
 ((~(EX x. P(x)) --> (EX x. Q(x))) &
  (ALL x. Q(x) | R(x) --> S(x)))) -->
(EX x. P(x) & R(x))
No subgoals left!
> val it = () : unit
~(EX x. S(x) & Q(x)) &
((ALL x. P(x) --> Q(x) | R(x)) &
 ((~(EX x. P(x)) --> (EX x. Q(x))) &
  (ALL x. Q(x) | R(x) --> S(x)))) -->
(EX x. P(x) & R(x))
> val it = () : unit
Problem 25
> val it = () : unit
(EX x. P(x)) &
((ALL x. L(x) --> ~(M(x) & R(x))) &
 ((ALL x. P(x) --> M(x) & L(x)) &
  ((ALL x. P(x) --> Q(x)) |
   (EX x. P(x) & R(x))))) --> (EX x. Q(x) & P(x))
 1. empty
    |-  (EX x. P(x)) &
        ((ALL x. L(x) --> ~(M(x) & R(x))) &
         ((ALL x. P(x) --> M(x) & L(x)) &
          ((ALL x. P(x) --> Q(x)) |
           (EX x. P(x) & R(x))))) -->
        (EX x. Q(x) & P(x))
> val it = () : unit
(EX x. P(x)) &
((ALL x. L(x) --> ~(M(x) & R(x))) &
 ((ALL x. P(x) --> M(x) & L(x)) &
  ((ALL x. P(x) --> Q(x)) |
   (EX x. P(x) & R(x))))) --> (EX x. Q(x) & P(x))
No subgoals left!
> val it = () : unit
(EX x. P(x)) &
((ALL x. L(x) --> ~(M(x) & R(x))) &
 ((ALL x. P(x) --> M(x) & L(x)) &
  ((ALL x. P(x) --> Q(x)) |
   (EX x. P(x) & R(x))))) --> (EX x. Q(x) & P(x))
> val it = () : unit
Problem 26
> val it = () : unit
((EX x. p(x)) <-> (EX x. q(x))) &
(ALL x.
   ALL y. p(x) & q(y) --> (r(x) <-> s(y))) -->
((ALL x. p(x) --> r(x)) <->
 (ALL x. q(x) --> s(x)))
 1. empty
    |-  ((EX x. p(x)) <-> (EX x. q(x))) &
        (ALL x.
           ALL y.
             p(x) & q(y) --> (r(x) <-> s(y))) -->
        ((ALL x. p(x) --> r(x)) <->
         (ALL x. q(x) --> s(x)))
> val it = () : unit
((EX x. p(x)) <-> (EX x. q(x))) &
(ALL x.
   ALL y. p(x) & q(y) --> (r(x) <-> s(y))) -->
((ALL x. p(x) --> r(x)) <->
 (ALL x. q(x) --> s(x)))
No subgoals left!
> val it = () : unit
((EX x. p(x)) <-> (EX x. q(x))) &
(ALL x.
   ALL y. p(x) & q(y) --> (r(x) <-> s(y))) -->
((ALL x. p(x) --> r(x)) <->
 (ALL x. q(x) --> s(x)))
> val it = () : unit
Problem 27
> val it = () : unit
(EX x. P(x) & ~Q(x)) &
((ALL x. P(x) --> R(x)) &
 ((ALL x. M(x) & L(x) --> P(x)) &
  ((EX x. R(x) & ~Q(x)) -->
   (ALL x. L(x) --> ~R(x))))) -->
(ALL x. M(x) --> ~L(x))
 1. empty
    |-  (EX x. P(x) & ~Q(x)) &
        ((ALL x. P(x) --> R(x)) &
         ((ALL x. M(x) & L(x) --> P(x)) &
          ((EX x. R(x) & ~Q(x)) -->
           (ALL x. L(x) --> ~R(x))))) -->
        (ALL x. M(x) --> ~L(x))
> val it = () : unit
(EX x. P(x) & ~Q(x)) &
((ALL x. P(x) --> R(x)) &
 ((ALL x. M(x) & L(x) --> P(x)) &
  ((EX x. R(x) & ~Q(x)) -->
   (ALL x. L(x) --> ~R(x))))) -->
(ALL x. M(x) --> ~L(x))
No subgoals left!
> val it = () : unit
(EX x. P(x) & ~Q(x)) &
((ALL x. P(x) --> R(x)) &
 ((ALL x. M(x) & L(x) --> P(x)) &
  ((EX x. R(x) & ~Q(x)) -->
   (ALL x. L(x) --> ~R(x))))) -->
(ALL x. M(x) --> ~L(x))
> val it = () : unit
Problem 28.  AMENDED
> val it = () : unit
(ALL x. P(x) --> (ALL x. Q(x))) &
(((ALL x. Q(x) | R(x)) --> (EX x. Q(x) & S(x))) &
 ((EX x. S(x)) --> (ALL x. L(x) --> M(x)))) -->
(ALL x. P(x) & L(x) --> M(x))
 1. empty
    |-  (ALL x. P(x) --> (ALL x. Q(x))) &
        (((ALL x. Q(x) | R(x)) -->
          (EX x. Q(x) & S(x))) &
         ((EX x. S(x)) -->
          (ALL x. L(x) --> M(x)))) -->
        (ALL x. P(x) & L(x) --> M(x))
> val it = () : unit
(ALL x. P(x) --> (ALL x. Q(x))) &
(((ALL x. Q(x) | R(x)) --> (EX x. Q(x) & S(x))) &
 ((EX x. S(x)) --> (ALL x. L(x) --> M(x)))) -->
(ALL x. P(x) & L(x) --> M(x))
No subgoals left!
> val it = () : unit
(ALL x. P(x) --> (ALL x. Q(x))) &
(((ALL x. Q(x) | R(x)) --> (EX x. Q(x) & S(x))) &
 ((EX x. S(x)) --> (ALL x. L(x) --> M(x)))) -->
(ALL x. P(x) & L(x) --> M(x))
> val it = () : unit
Problem 29.  Essentially the same as Principia Mathematica *11.71
> val it = () : unit
(EX x. P(x)) & (EX y. Q(y)) -->
((ALL x. P(x) --> R(x)) &
 (ALL y. Q(y) --> S(y)) <->
 (ALL x. ALL y. P(x) & Q(y) --> R(x) & S(y)))
 1. empty
    |-  (EX x. P(x)) & (EX y. Q(y)) -->
        ((ALL x. P(x) --> R(x)) &
         (ALL y. Q(y) --> S(y)) <->
         (ALL x.
            ALL y. P(x) & Q(y) --> R(x) & S(y)))
> val it = () : unit
(EX x. P(x)) & (EX y. Q(y)) -->
((ALL x. P(x) --> R(x)) &
 (ALL y. Q(y) --> S(y)) <->
 (ALL x. ALL y. P(x) & Q(y) --> R(x) & S(y)))
No subgoals left!
> val it = () : unit
(EX x. P(x)) & (EX y. Q(y)) -->
((ALL x. P(x) --> R(x)) &
 (ALL y. Q(y) --> S(y)) <->
 (ALL x. ALL y. P(x) & Q(y) --> R(x) & S(y)))
> val it = () : unit
Problem 30
> val it = () : unit
(ALL x. P(x) | Q(x) --> ~R(x)) &
(ALL x. (Q(x) --> ~S(x)) --> P(x) & R(x)) -->
(ALL x. S(x))
 1. empty
    |-  (ALL x. P(x) | Q(x) --> ~R(x)) &
        (ALL x.
           (Q(x) --> ~S(x)) --> P(x) & R(x)) -->
        (ALL x. S(x))
> val it = () : unit
(ALL x. P(x) | Q(x) --> ~R(x)) &
(ALL x. (Q(x) --> ~S(x)) --> P(x) & R(x)) -->
(ALL x. S(x))
No subgoals left!
> val it = () : unit
(ALL x. P(x) | Q(x) --> ~R(x)) &
(ALL x. (Q(x) --> ~S(x)) --> P(x) & R(x)) -->
(ALL x. S(x))
> val it = () : unit
Problem 31.  
> val it = () : unit
~(EX x. P(x) & (Q(x) | R(x))) &
((EX x. L(x) & P(x)) &
 (ALL x. ~R(x) --> M(x))) --> (EX x. L(x) & M(x))
 1. empty
    |-  ~(EX x. P(x) & (Q(x) | R(x))) &
        ((EX x. L(x) & P(x)) &
         (ALL x. ~R(x) --> M(x))) -->
        (EX x. L(x) & M(x))
> val it = () : unit
~(EX x. P(x) & (Q(x) | R(x))) &
((EX x. L(x) & P(x)) &
 (ALL x. ~R(x) --> M(x))) --> (EX x. L(x) & M(x))
No subgoals left!
> val it = () : unit
~(EX x. P(x) & (Q(x) | R(x))) &
((EX x. L(x) & P(x)) &
 (ALL x. ~R(x) --> M(x))) --> (EX x. L(x) & M(x))
> val it = () : unit
Problem 32.  
> val it = () : unit
(ALL x. P(x) & (Q(x) | R(x)) --> S(x)) &
((ALL x. S(x) & R(x) --> L(x)) &
 (ALL x. M(x) --> R(x))) -->
(ALL x. P(x) & M(x) --> L(x))
 1. empty
    |-  (ALL x. P(x) & (Q(x) | R(x)) --> S(x)) &
        ((ALL x. S(x) & R(x) --> L(x)) &
         (ALL x. M(x) --> R(x))) -->
        (ALL x. P(x) & M(x) --> L(x))
> val it = () : unit
(ALL x. P(x) & (Q(x) | R(x)) --> S(x)) &
((ALL x. S(x) & R(x) --> L(x)) &
 (ALL x. M(x) --> R(x))) -->
(ALL x. P(x) & M(x) --> L(x))
No subgoals left!
> val it = () : unit
(ALL x. P(x) & (Q(x) | R(x)) --> S(x)) &
((ALL x. S(x) & R(x) --> L(x)) &
 (ALL x. M(x) --> R(x))) -->
(ALL x. P(x) & M(x) --> L(x))
> val it = () : unit
Problem 33
> val it = () : unit
(ALL x. P(a) & (P(x) --> P(b)) --> P(c)) <->
(ALL x.
   (~P(a) | (P(x) | P(c))) &
   (~P(a) | (~P(b) | P(c))))
 1. empty
    |-  (ALL x.
           P(a) & (P(x) --> P(b)) --> P(c)) <->
        (ALL x.
           (~P(a) | (P(x) | P(c))) &
           (~P(a) | (~P(b) | P(c))))
> val it = () : unit
(ALL x. P(a) & (P(x) --> P(b)) --> P(c)) <->
(ALL x.
   (~P(a) | (P(x) | P(c))) &
   (~P(a) | (~P(b) | P(c))))
No subgoals left!
> val it = () : unit
(ALL x. P(a) & (P(x) --> P(b)) --> P(c)) <->
(ALL x.
   (~P(a) | (P(x) | P(c))) &
   (~P(a) | (~P(b) | P(c))))
> val it = () : unit
Problem 34  AMENDED (TWICE!!)
> val it = () : unit
((EX x. ALL y. p(x) <-> p(y)) <->
 ((EX x. q(x)) <-> (ALL y. p(y)))) <->
((EX x. ALL y. q(x) <-> q(y)) <->
 ((EX x. p(x)) <-> (ALL y. q(y))))
 1. empty
    |-  ((EX x. ALL y. p(x) <-> p(y)) <->
         ((EX x. q(x)) <-> (ALL y. p(y)))) <->
        ((EX x. ALL y. q(x) <-> q(y)) <->
         ((EX x. p(x)) <-> (ALL y. q(y))))
> val it = () : unit
((EX x. ALL y. p(x) <-> p(y)) <->
 ((EX x. q(x)) <-> (ALL y. p(y)))) <->
((EX x. ALL y. q(x) <-> q(y)) <->
 ((EX x. p(x)) <-> (ALL y. q(y))))
No subgoals left!
> val it = () : unit
((EX x. ALL y. p(x) <-> p(y)) <->
 ((EX x. q(x)) <-> (ALL y. p(y)))) <->
((EX x. ALL y. q(x) <-> q(y)) <->
 ((EX x. p(x)) <-> (ALL y. q(y))))
> val it = () : unit
Problem 35.  
> val it = () : unit
EX x. EX y. P(x, y) --> (ALL u. ALL v. P(u, v))
 1. empty
    |-  EX x.
          EX y.
            P(x, y) --> (ALL u. ALL v. P(u, v))
> val it = () : unit
EX x. EX y. P(x, y) --> (ALL u. ALL v. P(u, v))
No subgoals left!
> val it = () : unit
EX x. EX y. P(x, y) --> (ALL u. ALL v. P(u, v))
> val it = () : unit
Problem 36. 
> val it = () : unit
(ALL x. EX y. J(x, y)) &
((ALL x. EX y. G(x, y)) &
 (ALL x.
    ALL y.
      J(x, y) | G(x, y) -->
      (ALL z. J(y, z) | G(y, z) --> H(x, z)))) -->
(ALL x. EX y. H(x, y))
 1. empty
    |-  (ALL x. EX y. J(x, y)) &
        ((ALL x. EX y. G(x, y)) &
         (ALL x.
            ALL y.
              J(x, y) | G(x, y) -->
              (ALL z.
                 J(y, z) | G(y, z) -->
                 H(x, z)))) -->
        (ALL x. EX y. H(x, y))
> val it = () : unit
(ALL x. EX y. J(x, y)) &
((ALL x. EX y. G(x, y)) &
 (ALL x.
    ALL y.
      J(x, y) | G(x, y) -->
      (ALL z. J(y, z) | G(y, z) --> H(x, z)))) -->
(ALL x. EX y. H(x, y))
No subgoals left!
> val it = () : unit
(ALL x. EX y. J(x, y)) &
((ALL x. EX y. G(x, y)) &
 (ALL x.
    ALL y.
      J(x, y) | G(x, y) -->
      (ALL z. J(y, z) | G(y, z) --> H(x, z)))) -->
(ALL x. EX y. H(x, y))
> val it = () : unit
Problem 37
> val it = () : unit
(ALL z.
   EX w.
     ALL x.
       EX y.
         (P(x, z) --> P(y, w)) &
         (P(y, z) &
          (P(y, w) --> (EX u. Q(u, w))))) &
((ALL x. ALL z. ~P(x, z) --> (EX y. Q(y, z))) &
 ((EX x. EX y. Q(x, y)) --> (ALL x. R(x, x)))) -->
(ALL x. EX y. R(x, y))
 1. empty
    |-  (ALL z.
           EX w.
             ALL x.
               EX y.
                 (P(x, z) --> P(y, w)) &
                 (P(y, z) &
                  (P(y, w) -->
                   (EX u. Q(u, w))))) &
        ((ALL x.
            ALL z. ~P(x, z) --> (EX y. Q(y, z))) &
         ((EX x. EX y. Q(x, y)) -->
          (ALL x. R(x, x)))) -->
        (ALL x. EX y. R(x, y))
> val it = () : unit
(ALL z.
   EX w.
     ALL x.
       EX y.
         (P(x, z) --> P(y, w)) &
         (P(y, z) &
          (P(y, w) --> (EX u. Q(u, w))))) &
((ALL x. ALL z. ~P(x, z) --> (EX y. Q(y, z))) &
 ((EX x. EX y. Q(x, y)) --> (ALL x. R(x, x)))) -->
(ALL x. EX y. R(x, y))
No subgoals left!
> val it = () : unit
(ALL z.
   EX w.
     ALL x.
       EX y.
         (P(x, z) --> P(y, w)) &
         (P(y, z) &
          (P(y, w) --> (EX u. Q(u, w))))) &
((ALL x. ALL z. ~P(x, z) --> (EX y. Q(y, z))) &
 ((EX x. EX y. Q(x, y)) --> (ALL x. R(x, x)))) -->
(ALL x. EX y. R(x, y))
> val it = () : unit
Problem 38. NOT PROVED
> val it = () : unit
(ALL x.
   p(a) & (p(x) --> (EX y. p(y) & r(x, y))) -->
   (EX z. EX w. p(z) & (r(x, w) & r(w, z)))) <->
(ALL x.
   (~p(a) |
    (p(x) |
     (EX z. EX w. p(z) & (r(x, w) & r(w, z))))) &
   (~p(a) |
    (~(EX y. p(y) & r(x, y)) |
     (EX z. EX w. p(z) & (r(x, w) & r(w, z))))))
 1. empty
    |-  (ALL x.
           p(a) &
           (p(x) --> (EX y. p(y) & r(x, y))) -->
           (EX z.
              EX w.
                p(z) & (r(x, w) & r(w, z)))) <->
        (ALL x.
           (~p(a) |
            (p(x) |
             (EX z.
                EX w.
                  p(z) & (r(x, w) & r(w, z))))) &
           (~p(a) |
            (~(EX y. p(y) & r(x, y)) |
             (EX z.
                EX w.
                  p(z) & (r(x, w) & r(w, z))))))
> val it = () : unit
Problem 39
> val it = () : unit
~(EX x. ALL y. J(x, y) <-> ~J(y, y))
 1. empty
    |-  ~(EX x. ALL y. J(x, y) <-> ~J(y, y))
> val it = () : unit
~(EX x. ALL y. J(x, y) <-> ~J(y, y))
No subgoals left!
> val it = () : unit
~(EX x. ALL y. J(x, y) <-> ~J(y, y))
> val it = () : unit
Problem 40. AMENDED
> val it = () : unit
(EX y. ALL x. J(y, x) <-> ~J(x, x)) -->
~(ALL x. EX y. ALL z. J(z, y) <-> ~J(z, x))
 1. empty
    |-  (EX y. ALL x. J(y, x) <-> ~J(x, x)) -->
        ~(ALL x.
            EX y. ALL z. J(z, y) <-> ~J(z, x))
> val it = () : unit
(EX y. ALL x. J(y, x) <-> ~J(x, x)) -->
~(ALL x. EX y. ALL z. J(z, y) <-> ~J(z, x))
No subgoals left!
> val it = () : unit
(EX y. ALL x. J(y, x) <-> ~J(x, x)) -->
~(ALL x. EX y. ALL z. J(z, y) <-> ~J(z, x))
> val it = () : unit
Problem 41
> val it = () : unit
(ALL z.
   EX y.
     ALL x. f(x, y) <-> f(x, z) & ~f(x, x)) -->
~(EX z. ALL x. f(x, z))
 1. empty
    |-  (ALL z.
           EX y.
             ALL x.
               f(x, y) <-> f(x, z) & ~f(x, x)) -->
        ~(EX z. ALL x. f(x, z))
> val it = () : unit
(ALL z.
   EX y.
     ALL x. f(x, y) <-> f(x, z) & ~f(x, x)) -->
~(EX z. ALL x. f(x, z))
No subgoals left!
> val it = () : unit
(ALL z.
   EX y.
     ALL x. f(x, y) <-> f(x, z) & ~f(x, x)) -->
~(EX z. ALL x. f(x, z))
> val it = () : unit
Problem 42
> val it = () : unit
~(EX y.
    ALL x. p(x, y) <-> ~(EX z. p(x, z) & p(z, x)))
 1. empty
    |-  ~(EX y.
            ALL x.
              p(x, y) <->
              ~(EX z. p(x, z) & p(z, x)))
> val it = () : unit
~(EX y.
    ALL x. p(x, y) <-> ~(EX z. p(x, z) & p(z, x)))
No subgoals left!
> val it = () : unit
~(EX y.
    ALL x. p(x, y) <-> ~(EX z. p(x, z) & p(z, x)))
> val it = () : unit
Problem 43 NOT PROVED
> val it = () : unit
(ALL x.
   ALL y.
     q(x, y) <-> (ALL z. p(z, x) <-> p(z, y))) -->
(ALL x. ALL y. q(x, y) <-> q(y, x))
 1. empty
    |-  (ALL x.
           ALL y.
             q(x, y) <->
             (ALL z. p(z, x) <-> p(z, y))) -->
        (ALL x. ALL y. q(x, y) <-> q(y, x))
> val it = () : unit
Problem 44
> val it = () : unit
(ALL x.
   f(x) -->
   (EX y.
      g(y) &
      (h(x, y) & (EX y. g(y) & ~h(x, y))))) &
(EX x. j(x) & (ALL y. g(y) --> h(x, y))) -->
(EX x. j(x) & ~f(x))
 1. empty
    |-  (ALL x.
           f(x) -->
           (EX y.
              g(y) &
              (h(x, y) &
               (EX y. g(y) & ~h(x, y))))) &
        (EX x.
           j(x) & (ALL y. g(y) --> h(x, y))) -->
        (EX x. j(x) & ~f(x))
> val it = () : unit
(ALL x.
   f(x) -->
   (EX y.
      g(y) &
      (h(x, y) & (EX y. g(y) & ~h(x, y))))) &
(EX x. j(x) & (ALL y. g(y) --> h(x, y))) -->
(EX x. j(x) & ~f(x))
No subgoals left!
> val it = () : unit
(ALL x.
   f(x) -->
   (EX y.
      g(y) &
      (h(x, y) & (EX y. g(y) & ~h(x, y))))) &
(EX x. j(x) & (ALL y. g(y) --> h(x, y))) -->
(EX x. j(x) & ~f(x))
> val it = () : unit
Problem 45
> val it = () : unit
(ALL x.
   f(x) & (ALL y. g(y) & h(x, y) --> j(x, y)) -->
   (ALL y. g(y) & h(x, y) --> k(y))) &
(~(EX y. l(y) & k(y)) &
 (EX x.
    f(x) &
    ((ALL y. h(x, y) --> l(y)) &
     (ALL y. g(y) & h(x, y) --> j(x, y))))) -->
(EX x. f(x) & ~(EX y. g(y) & h(x, y)))
 1. empty
    |-  (ALL x.
           f(x) &
           (ALL y. g(y) & h(x, y) --> j(x, y)) -->
           (ALL y. g(y) & h(x, y) --> k(y))) &
        (~(EX y. l(y) & k(y)) &
         (EX x.
            f(x) &
            ((ALL y. h(x, y) --> l(y)) &
             (ALL y.
                g(y) & h(x, y) --> j(x, y))))) -->
        (EX x. f(x) & ~(EX y. g(y) & h(x, y)))
> val it = () : unit
(ALL x.
   f(x) & (ALL y. g(y) & h(x, y) --> j(x, y)) -->
   (ALL y. g(y) & h(x, y) --> k(y))) &
(~(EX y. l(y) & k(y)) &
 (EX x.
    f(x) &
    ((ALL y. h(x, y) --> l(y)) &
     (ALL y. g(y) & h(x, y) --> j(x, y))))) -->
(EX x. f(x) & ~(EX y. g(y) & h(x, y)))
No subgoals left!
> val it = () : unit
(ALL x.
   f(x) & (ALL y. g(y) & h(x, y) --> j(x, y)) -->
   (ALL y. g(y) & h(x, y) --> k(y))) &
(~(EX y. l(y) & k(y)) &
 (EX x.
    f(x) &
    ((ALL y. h(x, y) --> l(y)) &
     (ALL y. g(y) & h(x, y) --> j(x, y))))) -->
(EX x. f(x) & ~(EX y. g(y) & h(x, y)))
> val it = () : unit
Problem 46
> val it = () : unit
(ALL x.
   f(x) & (ALL y. f(y) & h(y, x) --> g(y)) -->
   g(x)) &
(((EX x. f(x) & ~g(x)) -->
  (EX x.
     f(x) &
     (~g(x) &
      (ALL y. f(y) & ~g(y) --> j(x, y))))) &
 (ALL x.
    ALL y.
      f(x) & (f(y) & h(x, y)) --> ~j(y, x))) -->
(ALL x. f(x) --> g(x))
 1. empty
    |-  (ALL x.
           f(x) &
           (ALL y. f(y) & h(y, x) --> g(y)) -->
           g(x)) &
        (((EX x. f(x) & ~g(x)) -->
          (EX x.
             f(x) &
             (~g(x) &
              (ALL y.
                 f(y) & ~g(y) --> j(x, y))))) &
         (ALL x.
            ALL y.
              f(x) & (f(y) & h(x, y)) -->
              ~j(y, x))) -->
        (ALL x. f(x) --> g(x))
> val it = () : unit
(ALL x.
   f(x) & (ALL y. f(y) & h(y, x) --> g(y)) -->
   g(x)) &
(((EX x. f(x) & ~g(x)) -->
  (EX x.
     f(x) &
     (~g(x) &
      (ALL y. f(y) & ~g(y) --> j(x, y))))) &
 (ALL x.
    ALL y.
      f(x) & (f(y) & h(x, y)) --> ~j(y, x))) -->
(ALL x. f(x) --> g(x))
No subgoals left!
> val it = () : unit
(ALL x.
   f(x) & (ALL y. f(y) & h(y, x) --> g(y)) -->
   g(x)) &
(((EX x. f(x) & ~g(x)) -->
  (EX x.
     f(x) &
     (~g(x) &
      (ALL y. f(y) & ~g(y) --> j(x, y))))) &
 (ALL x.
    ALL y.
      f(x) & (f(y) & h(x, y)) --> ~j(y, x))) -->
(ALL x. f(x) --> g(x))
> val it = () : unit
(ALL x.
   ALL y.
     ALL z. P(x, y) --> (P(y, z) --> P(x, z))) -->
((ALL x.
    ALL y.
      ALL z.
        Q(x, y) --> (Q(y, z) --> Q(x, z))) -->
 ((ALL x. ALL y. Q(x, y) --> Q(y, x)) -->
  ((ALL x. ALL y. P(x, y) | Q(x, y)) -->
   (ALL x. ALL y. P(x, y)) |
   (ALL x. ALL y. Q(x, y)))))
 1. empty
    |-  (ALL x.
           ALL y.
             ALL z.
               P(x, y) -->
               (P(y, z) --> P(x, z))) -->
        ((ALL x.
            ALL y.
              ALL z.
                Q(x, y) -->
                (Q(y, z) --> Q(x, z))) -->
         ((ALL x. ALL y. Q(x, y) --> Q(y, x)) -->
          ((ALL x. ALL y. P(x, y) | Q(x, y)) -->
           (ALL x. ALL y. P(x, y)) |
           (ALL x. ALL y. Q(x, y)))))
> val it = () : unit
Problem 47  Schubert's Steamroller
> val it = () : unit
(ALL x. P1(x) --> P0(x)) &
((EX x. P1(x)) &
 ((ALL x. P2(x) --> P0(x)) &
  ((EX x. P2(x)) &
   ((ALL x. P3(x) --> P0(x)) &
    ((EX x. P3(x)) &
     ((ALL x. P4(x) --> P0(x)) &
      ((EX x. P4(x)) &
       ((ALL x. P5(x) --> P0(x)) &
        ((EX x. P5(x)) &
         ((ALL x. Q1(x) --> Q0(x)) &
          ((EX x. Q1(x)) &
           ((ALL x.
               P0(x) -->
               (ALL y. Q0(y) --> R(x, y)) |
               (ALL y.
                  P0(y) &
                  (S(y, x) &
                   (EX z. Q0(z) & R(y, z))) -->
                  R(x, y))) &
            ((ALL x.
                ALL y.
                  P3(y) & (P5(x) | P4(x)) -->
                  S(x, y)) &
             ((ALL x.
                 ALL y.
                   P3(x) & P2(y) --> S(x, y)) &
              ((ALL x.
                  ALL y.
                    P2(x) & P1(y) --> S(x, y)) &
               ((ALL x.
                   ALL y.
                     P1(x) & (P2(y) | Q1(y)) -->
                     ~R(x, y)) &
                ((ALL x.
                    ALL y.
                      P3(x) & P4(y) --> R(x, y)) &
                 ((ALL x.
                     ALL y.
                       P3(x) & P5(y) -->
                       ~R(x, y)) &
                  (ALL x.
                     P4(x) | P5(x) -->
                     (EX y.
                        Q0(y) &
                        R(x,
                          y))))))))))))))))))))) -->
(EX x.
   EX y.
     P0(x) &
     (P0(y) &
      (EX z. Q1(z) & (R(y, z) & R(x, y)))))
 1. empty
    |-  (ALL x. P1(x) --> P0(x)) &
        ((EX x. P1(x)) &
         ((ALL x. P2(x) --> P0(x)) &
          ((EX x. P2(x)) &
           ((ALL x. P3(x) --> P0(x)) &
            ((EX x. P3(x)) &
             ((ALL x. P4(x) --> P0(x)) &
              ((EX x. P4(x)) &
               ((ALL x. P5(x) --> P0(x)) &
                ((EX x. P5(x)) &
                 ((ALL x. Q1(x) --> Q0(x)) &
                  ((EX x. Q1(x)) &
                   ((ALL x.
                       P0(x) -->
                       (ALL y.
                          Q0(y) --> R(x, y)) |
                       (ALL y.
                          P0(y) &
                          (S(y, x) &
                           (EX z.
                              Q0(z) &
                              R(y, z))) -->
                          R(x, y))) &
                    ((ALL x.
                        ALL y.
                          P3(y) &
                          (P5(x) | P4(x)) -->
                          S(x, y)) &
                     ((ALL x.
                         ALL y.
                           P3(x) & P2(y) -->
                           S(x, y)) &
                      ((ALL x.
                          ALL y.
                            P2(x) & P1(y) -->
                            S(x, y)) &
                       ((ALL x.
                           ALL y.
                             P1(x) &
                             (P2(y) | Q1(y)) -->
                             ~R(x, y)) &
                        ((ALL x.
                            ALL y.
                              P3(x) & P4(y) -->
                              R(x, y)) &
                         ((ALL x.
                             ALL y.
                               P3(x) & P5(y) -->
                               ~R(x, y)) &
                          (ALL x.
                             P4(x) | P5(x) -->
                             (EX y.
                                Q0(y) &
                                R(x,
                                  y))))))))))))))))))))) -->
        (EX x.
           EX y.
             P0(x) &
             (P0(y) &
              (EX z.
                 Q1(z) & (R(y, z) & R(x, y)))))
> val it = () : unit
Reached end of file.
> val it = () : unit
[closing file "test10.sml"]
> val it = () : unit
