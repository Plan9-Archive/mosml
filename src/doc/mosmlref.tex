% mosmlref.tex v. 2.00.0 Copyright (C) Peter Sestoft 1994, 2000-06-28
%
% You may edit for lay-out, or leave out irrelevant sections (if
% such omissions are marked somehow), but you may not redistribute the
% sources.  The authors' names and the Moscow ML URL must be left in place.

\documentclass[fleqn,a4paper]{article}

\def\allttcdots{\ensuremath{\cdots}}

% this is a hack to get the bullets to hyperlink to a comment: there must be a simpler way
\newcounter{extension}
\renewcommand{\theextension}{$\bullet$}
\newcommand{\x}[1][]{\ref{extension}{#1}}

%\newcommand{\x}[1][]{\ref{extension}{\bf{*}#1}}

\nonstopmode
\usepackage{alltt}

\usepackage{isolatin1,mosml,pslatex}
\usepackage[T1]{fontenc}
\usepackage{geometry}

% \documentstyle[A4,fleqn,notesart]{article}

\newcommand{\la}{$\langle$}
\newcommand{\ra}{$\rangle$}
\newcommand{\opop}{\la{\tt op}\ra}

\newcommand{\op}{{\tt op}}
\newcommand{\longmodid}{{\it longmodid}}

% True if running pdflatex
\newif\ifpdf
\ifx\pdfoutput\undefined
    \pdffalse
\else
    \pdftrue
\fi

% hyperref should be the *last* package loaded
\ifpdf
   \pdfcompresslevel=9
   % For interactive color output devices (i.e. computer displays):
   \usepackage[pdfpagemode=None,colorlinks,urlcolor=blue]{hyperref}
\else
   % For passive black and white output devices (i.e. printers):
   \usepackage{hyperref}
\fi

\begin{document}

\begin{center}

  \vspace*{0cm}

{\huge\bf Moscow ML Language Overview}\\[0.5cm]

{Version 2.00 of June 2000}\\[1cm]

Sergei Romanenko, Russian Academy of Sciences, Moscow, Russia\\
Claudio Russo, Cambridge University, Cambridge, United Kingdom\\
Peter Sestoft, Royal Veterinary and Agricultural University, 
Copenhagen, Denmark
\end{center}

\noindent This is a compact reference to the language implemented by
Moscow ML, a superset of Standard ML\@.  For reference material on
Standard ML, see Milner, Tofte, Harper and MacQueen: {\em The
  Definition of Standard ML\/}, The MIT Press 1997.  For a guide to
the practical use of Moscow ML, see the \emph{Moscow ML Owner's
  Manual}.  For a detailed description of all Moscow ML library
modules, see the \emph{Moscow ML Library Documentation}.


% {\bf Acknowledgements:} The present document owes a lot to the {\em
%   Definition\/}.Thanks to Don Sannella at LFCS, Division of
%   Informatics, University of Edinburgh for funding C. Russo under
%   EPSRC grant GR/K63795 .

\tableofcontents

\vfill

\begin{center}
\begin{tabular}{|c|}\hline
\rule[-0.4cm]{0cm}{1cm}The Moscow ML home page is\ \
    \url{http://www.dina.kvl.dk/~sestoft/mosml.html}\\\hline
\end{tabular}
\end{center}

\newpage 

\section{Moscow ML's relation to Standard ML}\label{sec-SMLcompliance}

Moscow ML implements a proper extension of Standard ML, 
as  defined in the 1997 {\em Definition of Standard ML\/}.
This document describes the language implemented by Moscow ML, not Standard ML 
\emph{per se}: users seeking an orthodox Standard ML reference should look elsewhere.
Having said that, Moscow ML is specifically designed to be backwards compatible with Standard ML. Thus every valid Standard ML program should be a valid
Moscow ML program, and Moscow ML may be used as if it were simply
a Standard ML compiler. Any deviation from this behaviour should be reported
as a bug.

% To facilitate the production of code that complies with Standard ML,
% both the batch compiler {\tt mosmlc} and the interactive system {\tt
%   mosml} accept the command line options {\tt -orthodox}, {\tt
%   -conservative} and {\tt -liberal}, which cause the compiler and
% interactive system to respectively reject, deprecate with a warning,
% or silently accept any Moscow ML specific extensions of Standard ML.
% The default compliance level is {\tt -conservative}. In the
% interactive system, the compliance level may be set interactively
% using the functions {\tt orthodox}, {\tt conservative} and {\tt
%   liberal} of type {\tt unit -> unit}.

\section{Reserved words}
\label{sec-reserved-words}

% {\small\begin{verbatim} 
%       abstype  and  andalso  as  case  do  datatype  else  end  exception  fn  fun  
%       handle  if  in  infix  infixr  let  local  nonfix  of  op  open  orelse  raise  rec  
%       sig  signature  struct  structure  then  type  val  with  withtype  while  
%       (  )  [  ]  {  }  ,  :  :>  ;  ...    _  |  =  =>  ->  #
% \end{verbatim}}

{\small\begin{alltt} 
abstype  and  andalso  as  case  do  datatype  else  end eqtype exception  fn  fun  functor 
handle  if  in  include  infix  infixr  let  local  nonfix  of  op  open  orelse  raise  rec  
sharing  sig  signature  struct  structure  then  type  val  where  with  withtype  while  
(  )  [  ]  \{  \}  ,  :  :>  ;  ...    _  |  =  =>  ->  #
\end{alltt}}


\section{Comments}
\label{sec-comments}

A comment is any character sequence within comment brackets \verb#(*#
and \verb#*)# in which comment brackets are properly nested.


\section{Special constants}
\label{sec-special-constants}


\subsubsection*{Integer constants}

\begin{quot}
\begin{tabular}{@{}lcllllllll}
Examples:   & &  \verb#0# & \verb#~0# & \verb#4# & \verb#~04# &
\verb#999999# & \verb#0xFFFF# & \verb#~0x1ff#\\
Non-examples: & & \verb#0.0# & \verb#~0.0# & \verb#4.0# & \verb#1E0# &
\verb#-317# & \verb#0XFFFF# & \verb#-0x1ff#\\
\end{tabular}
\end{quot}


\subsubsection*{Real constants}

\begin{quot}
\begin{tabular}{@{}lcllllllll}
Examples:   & &  \verb#0.7# & \verb#~0.7# & \verb#3.32E5# & \verb#3E~7#
 & \verb#~3E~7#  & \verb#3e~7# & \verb#~3e~7#\\
Non-examples: & & \verb#23# & \verb#.3# & \verb#4.E5# & \verb#1E2.0# & 
  \verb#1E+7# & \verb#1E-7#
\end{tabular}
\end{quot}


\subsubsection*{Word constants}

\begin{quot}
\begin{tabular}{@{}lcllllllll}
Examples:   & &  \verb#0w0# & \verb#0w4# & \verb#0w999999# &
\verb#0wxFFFF#  & \verb#0wx1ff#\\
Non-examples: & & \verb#0w0.0# & \verb#~0w4# & \verb#-0w4# & \verb#0w1E0# &
\verb#0wXFFFF# & \verb#0WxFFFF#\\
\end{tabular}
\end{quot}


\subsubsection*{String constants}

A string constant is a sequence, between quotes (\verb#"#), of zero or
more printable characters, spaces, or escape sequences.  An escape
sequence starts with the escape character \verb#\# and stands for a
character sequence:

\begin{quot}
\begin{tabular}{@{}lp{5in}}
  \verb#\a# & A single character interpreted by the system as
  alert (BEL, ASCII 7). \\ 

  \verb#\b# & Backspace (BS, ASCII 8).\\ 

  \verb#\t# & Horisontal tab (HT, ASCII 9).\\ 

  \verb#\n# & Linefeed, also known as newline (LF, ASCII 10). \\ 

  \verb#\v# & Vertical tab (VT, ASCII 11).\\ 

  \verb#\f# & Form feed (FF, ASCII 12).\\ 
 
 \verb#\r# & Carriage return (CR, ASCII 13).\\ 

  \verb#\^#{\it c\/} & The control character {\it c\/}, where {\it
    c\/} may be any character with ASCII code 64--95 (\verb#@# to
  \verb#_#).  The ASCII code of \verb#\^#{\it c\/} is 64 less than
  that of {\it c\/}.\\ 

  \verb#\#{\it ddd\/} & The character with code {\it ddd\/} (3 decimal
  digits denoting an integer 0--255).\\ 

  \verb#\u#{\it xxxx\/} & The character with code {\it xxxx\/} (4 hexadecimal
  digits denoting an integer 0--255).\\ 

\verb#\"# & The double-quote character ({\tt "})\\

\verb#\\# & The backslash character (\verb#\#)\\

\verb#\#$f\cdot\cdot f$\verb#\# & This sequence is ignored, where
$f\cdot\cdot f$ stands for a sequence of one or more formatting
characters (such as space, tab, newline, form-feed).
\end{tabular}
\end{quot}


\subsubsection*{Character constants}

A character constant consists of the symbol \verb$#$ immediately
followed by a string constant of length one.

\begin{quot}
\begin{tabular}{@{}lclllll}
Examples:   & &  \verb$#"a"    $ & \verb$#"\n"   $ & \verb$#"\^Z"  $ &
\verb$#"\255" $ & \verb$#"\""$\\
Non-examples: & & \verb$# "a"$ & \verb$#c$ & \verb$#"""$ 
\end{tabular}
\end{quot}

%\newpage

\section{Identifiers}
\label{sec-identifiers}

\begin{itemize}
\item {\bf alphanumeric:} a sequence of letters, digits, primes
  (\verb#'#) and underbars (\verb#_#) starting with a letter or prime;

\item {\bf symbolic:} any non-empty sequence of the following symbols:\\
\verb;      ! % & $ # + - / : < = > ? @ \ ~ ` ^ | *;
\end{itemize}

\noindent Reserved words (Section~\ref{sec-reserved-words}) are
excluded.  This means that for example \verb$#$ and \verb#|# are not
identifiers, but \verb$##$ and \verb#|=|# are identifiers.  There are
several classes of identifiers:

{\begin{center}
\begin{tabular}{@{}lll}
{\it vid }  &  (value identifiers)           &    long\\
{\it tyvar} &  (type variables)\\
{\it tycon} &  (type constructors)         &    long\\
{\it lab}   &  (record labels)\\
{\it strid} &  (structure identifiers)         &    long\\
{\it funid} &  (functor identifiers)         &    long\\
{\it modid} &  (module identifiers)         &    long\\
{\it sigid} &  (signature identifiers)\\
{\it unitid} &  (unit identifiers)
\end{tabular}
\end{center}}


\begin{itemize}
\item A type variable \verb#'a# is an alphanumeric identifier starting
  with a prime.

%\item An equality type variable \verb#''a# starts with two or more primes.
%
%\item An imperative type variable \verb#'_a# starts with one or two primes
%  followed by an underbar.
%
%\item An applicative type variable is one which is not imperative.

\item A label lab is an identifier, or a positive integral numeral
  \verb#1 2 3 #\ldots\ not starting with \verb#0#.  

\item For each identifier class X marked `long' above there is a class
  longX of long identifiers, which may have a qualifier consisting of
  a long structure identifier followed by a dot `\texttt{.}' :
  \begin{center}
      \begin{tabular}{llll}
    {\it longx\/} & ::= &  {\it x\/}         & identifier\\
          &     &  {\it longstrid\/}\texttt{.}{\it x\/}  & qualified identifier
  \end{tabular}
  \end{center}

\item 
 Although structure and functor identifiers reside in separate name-spaces,
 the syntax of structure and functor identifiers is identical. The
 set of identifiers
 {\it modid} ranges over the union of {\it strid} and {\it funid};
 {\it longmodid} ranges over the union  of {\it longstrid} and {\it longfunid}.
 Moscow ML uses type information to resolve each occurrence of a 
 {\it modid} or {\it longmodid} 
 to a structure or functor identifier during type checking, using
 the optional keyword \op\ to resolve any remaining ambiguities.
 See the comments at the end of Section \ref{sec-modules}.
 
\item Any occurrence of a structure identifier {\it strid\/} that is
  not bound in the current context refers to the unit implementation
  {\tt unitid.uo\/} of the same name (ie. {\tt unitid} = {\it strid}).
  At compile time, the unit's compiled interface {\tt unitid.ui\/}
  must exist and have been compiled in \emph{structure} mode.  At link
  time, the unit's compiled implementation {\tt unitid.uo\/} must
  exist and have been compiled in \emph{structure} mode.

\item Any occurrence of a signature identifier {\it sigid\/} that is not
bound in the current context refers to the compiled unit interface
{\tt unitid.ui\/} of the same name (ie. {\tt unitid} = {\it sigid}).
The file {\tt unitid.ui\/} must have been compiled in \emph{structure}
mode from an explicit interface {\tt unitid.sig}.

\end{itemize}

\newpage
\section{Infixed operators}
\label{sec-infixed-operators}

An identifier may be given infix status by the {\tt infix} or {\tt
  infixr} directive, which may occur as a declaration or specification.  If identifier
{\it id\/} has infix status, then {\it exp\/}$_1$ {\it id\/} {\it
  exp\/}$_2$ may occur, in parentheses if necessary, wherever the
application {\it id\/}\verb#(#{\it exp\/}\et\verb#,# {\it
  exp\/}\to\verb#)# or {\it id\/}\verb#{1=#{\it
    exp\/}\et\verb#,2=#{\it exp\/}\to\verb#}# would otherwise occur.
Infix identifiers in patterns are analogous.  On the other hand, an
occurrence of a qualified identifier, or any identifier prefixed by
{\tt op}, is treated as non-infixed.  The form of the fixity directives
is as follows ($n\geq 1$):
        
\begin{center}
\begin{tabular}{@{}llll}
{\tt infix}  & $\langle d\rangle$ & $id_1 \cdots id_n$ & left associative\\
{\tt infixr} & $\langle d\rangle$ & $id_1 \cdots id_n$ & right associative\\
{\tt nonfix} & & $id_1 \cdots id_n$ & non-associative
\end{tabular}
\end{center}

\noindent where $\langle d\rangle$ is an optional decimal digit $d$
indicating binding precedence.  A higher value of $d$ indicates
tighter binding; the default is \verb#0#.  Fixity directives are
subject to the usual scope rules governing visibility of identifiers
declared inside {\tt let} and {\tt local}. 
Fixity directives occurring within {\it dec} in a structure expression 
{\tt struct {\it dec\/} end} are local to {\it dec}.
Fixity directives occurring within {\it spec} in a signature 
{\tt sig {\it spec\/} end} are local to {\it spec}.

Mixed left-associative operators of the same precedence associate to
the left, mixed right-associative operators of the same precedence
associate to the right, and it is illegal to mix left- and
right-associative operators of the same precedence.

\section{Notational conventions used in the grammar}

\begin{itemize}
\item Each syntax class is defined by a list of alternatives, one
  alternative on each line.  An empty phrase is represented by an
  empty line.

\item The brackets \la\ and \ra\ enclose optional phrases.

%\newpage
\item For any syntax class X (over which {\it x\/} ranges) we define the syntax
  class Xseq (over which {\it xseq\/} ranges) as follows:

  \begin{center}
    \begin{tabular}{llll}
      {\it xseq\/} &  ::=  & {\it x\/} & (singleton sequence)\\
             &       &           & (empty sequence)\\
             &       & {\tt ($x_1$, $\cdots$ , $x_n$)} & (sequence,
             $n\geq 1$)
    \end{tabular}
  \end{center}
\item Alternative phrases are listed in order of decreasing precedence.

\item L and R indicate left and right association.

\item The syntax of types binds more tightly than that of expressions.

\item Each iterated construct (e.g.\ {\it match\/}) extends as far to
  the right as possible.  Hence a {\tt case} inside a {\tt case}, {\tt
    fn}, or {\tt fun} may have to be enclosed in parentheses.

\item Moscow ML phrases that are non-compliant 
      extensions of Standard ML syntax are
      marked with an bullet (\x) in the margin.
      
    \item Moscow ML phrases that are non-compliant generalisations of
      Standard ML syntax, but have instances that comply with Standard
      ML, are marked with an an bullet and a number (\x[$N$]) in the
      margin, where $N$ refers to an explanatory comment that appears
      in Section \ref{sec-SMLrestrictions}.
\end{itemize}

\newpage

\section{Grammar for the Moscow ML Core language}
\label{sec-grammar-core}

\subsubsection*{Expressions and Matches}

\begin{tabular}{@{}lllll}
{\it exp\/} & ::= & {\it infexp\/}\\
& & {\tt {\it exp\/} :\ {\it ty\/}} & type constraint (L)\\
& & {\tt {\it exp\/}\et\ andalso {\it exp\/}\to} & sequential conjunction\\
& & {\tt {\it exp\/}\et\ orelse {\it exp\/}\to}  & sequential disjunction\\
& & {\tt {\it exp\/} handle {\it match\/}} & handle exception\\
& & {\tt raise {\it exp\/}} & raise exception\\
& & {\tt if {\it exp\/}\et\ then {\it exp\/}\to\ else {\it exp\/}\tre}
& conditional\\
& & {\tt while {\it exp\/}\et\ do {\it exp\/}\to} & iteration\\
& & {\tt case {\it exp\/} of {\it match\/}} & case analysis\\
& & {\tt fn {\it match\/}} & function expression\\[2ex]

{\it infexp\/} & ::= & {\it appexp\/}\\
& & {\it infexp\/}\et\ {\it id\/} {\it infexp\/}\to & infixed
application\\[2ex]

{\it appexp\/} & ::= & {\it atexp\/}\\
& & {\it appexp\/} {\it atexp\/} & application\\[2ex]

{\it atexp\/} & ::= & {\it scon\/} &  special constant 
(see Section~\ref{sec-special-constants})\\
& & \la{\tt op}\ra\ {\it longvid\/} & value identifier\\
& & \verb#{# \la\ {\it exprow\/} \ra\ \verb#}# & record\\
& & \verb$#$ {\it lab\/} & record selector\\
& & \verb#()# &           0-tuple\\
& & {\tt ({\it exp\/}\et, $\cdots$ , {\it exp\/}\n)} 
& $n$-tuple, $n\geq 2$\\
& & {\tt [{\it exp\/}\et, $\cdots$ , {\it exp\/}\n]} 
& list, $n\geq 0$\\
& & {\tt \#[{\it exp\/}\et, $\cdots$ , {\it exp\/}\n]} 
& vector, $n\geq 0$\\
& & {\tt ({\it exp\/}\et; $\cdots$ ; {\it exp\/}\n)} 
& sequence, $n\geq 2$\\
& & {\tt let {\it dec\/} in {\it exp\/}\et; $\cdots$ ; {\it exp\/}\n\
  end} & local declaration, $n\geq 1$\\
& & {\tt [ structure {\it modexp\/} as {\it sigexp\/} ]} & structure package & \x \\
& & {\tt [ functor {\it modexp\/} as {\it sigexp\/} ]} & functor package & \x \\
& & {\tt  ( {\it exp\/} ) }\\[2ex]

{\it exprow\/} & ::= & {\tt {\it lab\/} = {\it exp\/} \la\ , {\it
    exprow\/} \ra} & expression row\\[2ex]

{\it match\/} & ::= & {\tt {\it mrule\/} \la\ | {\it match\/} \ra}\\[2ex]

{\it mrule\/} & ::= & {\tt {\it pat\/} => {\it exp\/}}
\end{tabular}


\subsubsection*{Declarations and Bindings}

\begin{tabular}{@{}lllll}
{\it dec\/} & ::= & {\tt val {\it tyvarseq\/} {\it valbind\/}} & value declaration\\
& & {\tt fun {\it tyvarseq\/} {\it fvalbind\/}} & function declaration\\
& & {\tt type {\it typbind\/}} & type declaration\\
& & {\tt datatype {\it datbind\/} \la\ withtype {\it typbind\/} \ra} 
& datatype declaration\\
& & {\tt datatype {\it tycon\/} = datatype {\it tyconpath\/}}
& datatype replication\\
& & {\tt abstype {\it datbind\/} \la\ withtype {\it typbind\/} \ra}
& abstype declaration\\
& & \hspace{1.5cm}{\tt with {\it dec\/} end}\\
& & {\tt exception {\it exbind\/}} & exception declaration\\
& & {\tt local {\it dec\/}\et\ in {\it dec\/}\to\ end} 
& local declaration\\
& & {\tt open {\it longstrid\/}\et\ $\cdots$ {\it longstrid\/}\n}
& open declaration, $n\geq 1$\\
& & {\tt structure {\it strbind}}
& structure declaration & \x[\ref{strdec}]\\
& & {\tt functor {\it funbind}}
& functor declaration & \x[\ref{topdec}]\\
& & {\tt signature {\it sigbind}}
& signature declaration & \x[\ref{topdec}]\\
& & & empty declaration\\
& & {\tt {\it dec\/}\et\ \la;\ra\ {\it dec\/}\to} 
& sequential declaration\\
& & {\tt infix \la{\it d\/}\ra\ $id_1 \cdots id_n$} & infix (left)
  directive, $n\geq 1$\\
& & {\tt infixr \la{\it d\/}\ra\ $id_1 \cdots id_n$} & infix (right)
  directive, $n\geq 1$\\
& & {\tt nonfix $id_1 \cdots id_n$} & nonfix directive, $n\geq
  1$\\[2ex]

{\it valbind\/} & ::= & {\tt {\it pat\/} = {\it exp\/} \la\ and {\it
    valbind\/} \ra} & value binding\\
& & {\tt rec {\it valbind\/}} & recursive binding\\[2ex]

{\it fvalbind\/} & ::= & 
  \begin{tabular}[t]{ll}
  {\tt \ \ \opop\ {\it var\/} {\it atpat\/}\et\et\ $\cdots$ {\it atpat\/}\et\n\ 
  \la{:}ty\ra\ = {\it exp\/}\et}\\
  {\tt | \opop\ {\it var\/} {\it atpat\/}\to\et\ $\cdots$ {\it atpat\/}\to\n\ 
  \la{:}ty\ra\ = {\it exp\/}\to}\\ 
  {\tt | $\cdots$}\\
  {\tt | \opop\ {\it var\/} {\it atpat\/}\m\et\ $\cdots$ {\it atpat\/}\m\n\ 
  \la{:}ty\ra\ = {\it exp\/}\m}\\
  {\tt \ \ \ \la\ and {\it fvalbind\/} \ra}
  \end{tabular} & $m,n\geq 1$\\[12ex]

{\it typbind\/} & ::= & {\tt {\it tyvarseq\/} {\it tycon\/} = {\it
    ty\/} \la\ and {\it typbind\/} \ra} & \x[\ref{closure}]\\[2ex]

{\it datbind\/} & ::= & {\tt {\it tyvarseq\/} {\it tycon\/} = {\it
    conbind\/} \la\ and {\it datbind\/} \ra} & \x[\ref{closure}]\\[2ex]

{\it conbind\/} & ::= & {\tt \opop\ {\it vid\/} \la{of} {\it ty\/}\ra\ \la\ | {\it conbind\/} \ra}\\[2ex]

{\it exbind\/} & ::= & {\tt \opop\ {\it vid\/} \la{of} 
{\it ty\/}\ra\ \la\ and {\it exbind\/} \ra}\\
& & {\tt \opop\ {\it vid\/} = \opop\ {\it longvid\/} \la\ and {\it
  exbind\/} \ra}\\[2ex]
\end{tabular}

\noindent Note: In the {\it fvalbind\/} form above, if {\it var\/} has
infix status then either {\tt op} must be present, or {\it var\/} must
be infixed.  Thus, at the start of any clause, {\tt op {\it var\/}
  ({\it atpat\/}, {\it atpat\/}$'$)} may be written {\tt ({\it
    atpat\/} {\it var\/} {\it atpat\/}$'$)}.  The parentheses may be
dropped if `{\tt :{\it ty\/}}' or `{\tt =}' follows immediately.

\subsubsection*{Type expressions}

\begin{tabular}{@{}lllll}
{\it tyconpath\/} & ::= & {\it longtycon\/} & long type constructor\\
& & {\tt {\it longtycon\/} where {\it strid\/} = {\it modexp\/}}& type constructor projection &\x\\[2ex]

{\it ty\/} & ::= & {\it tyvar\/} & type variable\\
& & {\tt \{ \la\ {\it tyrow\/} \ra\ \}} & record type expression\\
& & {\tt {\it tyseq\/} {\it tyconpath\/}} & type construction & \\
& & {\tt {\it ty\/}\et\ * $\cdots$ * {\it ty\/}\n} & tuple type,
$n\geq 2$\\
& & {\tt {\it ty\/}\et\ -> {\it ty\/}\to} & function type expression\\
& & {\tt [ {\it sigexp} ]} & package type expression & \x\\
& & {\tt ( {\it ty\/} )}\\[2ex]

{\it tyrow\/} & ::= & {\tt {\it lab\/} :\ {\it ty\/} \la\ , {\it
    tyrow\/} \ra} & type-expression row
\end{tabular}


\subsubsection*{Patterns}

\begin{tabular}{@{}llll}
{\it atpat\/} & ::= & \verb#_# & wildcard\\
& & {\it scon\/} & special constant (see Section~\ref{sec-special-constants})\\
& & {\tt \opop\ {\it longvid\/}} & value identifier\\
& & {\tt \{ \la\ {\it patrow\/} \ra\ \}} & record\\
& & {\tt ()} & 0-tuple\\
& & {\tt ({\it pat\/}\et, $\cdots$ , {\it pat\/}\n)} & $n$-tuple,
$n\geq 2$\\
& & {\tt [{\it pat\/}\et, $\cdots$ , {\it pat\/}\n]} & list, $n\geq 0$\\
& & {\tt \#[{\it pat\/}\et, $\cdots$ , {\it pat\/}\n]} & vector, $n\geq 0$\\
& & {\tt ( {\it pat\/} )}\\[2ex]

{\it patrow\/} & ::= & {\tt ...} & wildcard\\
& & {\tt {\it lab\/} = {\it pat\/} \la\ , {\it patrow\/} \ra} &
pattern row\\
& & {\tt {\it lab\/} \la{:}{\it ty\/}\ra\ \la\ as {\it pat\/} \ra\ 
\la\ , {\it patrow\/} \ra} &  label as variable\\[2ex]

{\it pat\/} & ::= & {\it atpat\/} & atomic pattern\\
& & {\tt \opop\ {\it longvid\/} {\it atpat\/}} & constructed value\\
& & {\tt {\it pat\/}\et\ {\it vid\/} {\it pat\/}\to} & 
infixed value construction\\
& & {\tt {\it pat\/} :\ {\it ty\/}} & typed\\
& & {\tt \opop\ {\it var\/} \la{:}{\it ty\/}\ra\ as {\it pat\/}} & layered
\end{tabular}


\subsubsection*{Syntactic restrictions}

\begin{itemize}
\item No pattern may bind the same {\it var\/} twice.  No expression
  row, pattern row or type row may bind the same {\it lab\/} twice.

\item No binding {\it valbind\/}, {\it typbind\/}, {\it datbind\/} or
  {\it exbind\/} may bind the same identifier twice; this applies also
  to value constructors within a {\it datbind\/}.
        
\item In the left side {\it tyvarseq tycon\/} of any {\it typbind\/}
  or {\it datbind\/}, {\it tyvarseq\/} must not contain the same {\it
    tyvar\/} twice.  
    Moscow ML 
    requires that   any {\it tyvar\/} occurring within the right side
    is in scope (either explictly or implicitly), but not necessarily in
    {\it tyvarseq} (cf. Section \ref{sec-SMLrestrictions}, restriction \ref{closure}).

\item For each value binding {\tt {\it pat\/} = {\it exp\/}} within
  {\tt rec}, {\it exp\/} must be of the form {\tt fn {\it match\/}},
  possibly enclosed in parentheses, and possibly constrained by one or
  more type expressions.
  
\item No {\it valbind}, {\it datbind}, or {\it exbind} may bind {\tt
    true}, {\tt false}, {\tt nil}, {\tt ::}, or {\tt ref}.  No {\it
    datbind} or {\it exbind} may bind {\tt it}.


\end{itemize}


\section{Interactive sessions}

An expression {\it exp\/} which occurs grammatically at top-level in
an interactive session is taken to be an abbreviation for the
declaration

\begin{quot}
{\tt val it = {\it exp\/}}  
\end{quot}

\noindent This convention applies to interactive sessions only.  In a
batch-compiled unit, write {\tt val it = {\tt exp}}\\ or {\tt val \verb#_# =
  {\it exp\/}} etc.

\newpage


\section{Grammar for the Moscow ML Modules language}
\label{sec-modules}

The Moscow ML Modules language is a superset of the full Standard ML Modules language.

\subsubsection*{Module expressions}

\begin{tabular}{@{}lllll}
{\it modexp\/} & ::= & {\it appmodexp\/}\\
& & {\tt {\it modexp\/} :\ {\it sigexp\/}} & transparent constraint (L)\\
& & {\tt {\it modexp\/} :> {\it sigexp\/}} & opaque constraint (L)\\
& & {\tt functor ( {\it modid\/} :\ {\it sigexp} ) => {\it modexp}}  & generative functor & \x \\
& & {\tt functor {\it modid\/} :\ {\it sigexp\/} => {\it modexp}}  & applicative functor & \x \\
& & {\tt rec ( {\it strid\/} :\ {\it sigexp} ) {\it modexp}}  & recursive structure& \x \\[2ex]

{\it appmodexp\/} & ::= & {\it atmodexp\/}\\
& & {\tt {\it appmodexp\/} {\it atmodexp\/}} & functor application&\x[\ref{atmodexp}] \\[2ex]

{\it atmodexp\/} & ::= & {\tt struct {\it dec\/} end} & basic\\
& & {\tt \opop\ {\it longmodid\/}}& module identifier\\
& & {\tt let {\it dec\/} in {\it modexp\/} end} & local declaration\\
& & {\tt ( {\it dec \/} )} & abbreviated structure & \x \\
& & {\tt ( {\it modexp\/} )} \\
\end{tabular}

\subsubsection*{Module bindings}

\begin{tabular}{@{}lllll}
{\it strbind\/} & ::= & {\tt {\it strid\/} \la\ {\it con} \ra\ = {\it modexp} \la\ and {\it strbind} \ra} 
& structure binding\\
& & {\tt {\it strid\/} as {\it sigexp} = {\it exp} \la\ and {\it strbind} \ra} 
& package binding & \x \\[2ex]

%{\it funbind\/} & ::= & {\tt {\it funid\/} = {\it modexp} \la\ and {\it funbind} \ra} 
{\it funbind\/} & ::= & {\tt {\it funid\/} {\it arg}\et\ $\cdots$\ {\it arg}\n\ \la\ {\it con\/} \ra\ = {\it modexp}} & \\
                &     & \quad {\tt \la\ and {\it funbind} \ra} & functor binding, $n \geq 0$ & \x[\ref{funbind}]\\
                & &  {\tt {\it funid\/} ( {\it spec} ) \la\ {\it con\/} \ra\ = {\it modexp}} & \\
                &  & \quad {\tt \la\ and {\it funbind} \ra} & abbreviated generative binding\\

& & {\tt {\it funid\/} as {\it sigexp} = {\it exp} \la\ and {\it funbind} \ra} 
& package binding & \x\\[2ex]

{\it sigbind\/} & ::= & {\tt {\it sigid\/} = {\it sigexp} \la\ and {\it sigbind} \ra} 
& signature binding\\[2ex]

{\it con\/} & ::= & {\tt :} {\it sigexp} & transparent constraint \\
            &     & {\tt :>} {\it sigexp} & opaque constraint \\

{\it arg\/} & ::= & {\tt ( {\it modid\/} :\ {\it sigexp} )} & argument of generative functor \\
            &     & {\tt  {\it modid\/} :\ {\it sigexp} } & argument of applicative functor & \x \\\

\end{tabular}

\subsubsection*{Signature expressions}

\begin{tabular}{@{}lllll}
{\it sigexp\/} & ::= & {\tt sig {\it spec\/} end}& basic\\
& & {\tt {\it sigid\/}} & signature identifier \\ 
%& & {\tt {\it sigexp\/} where type {\it tyvarseq\/} {\it longtycon} = {\it ty}} & type realisation & \x[\ref{closure}]\\ 
& & {\tt {\it sigexp\/} where  {\it typreal\/}}& type realisation \\ 
& & {\tt functor ( {\it modid\/} :\ {\it sigexp} ) -> {\it sigexp}}  & opaque functor signature & \x \\
& & {\tt functor {\it modid\/} :\ {\it sigexp\/} -> {\it sigexp}}  & transparent functor signature & \x \\
& & {\tt rec ( {\it strid\/} :\ {\it sigexp} ) {\it sigexp}}  & recursive structure signature & \x \\[2ex]

{\it typreal\/} & ::= & {\tt type {\it tyvarseq\/} {\it longtycon\/} = {\it ty\/}
\la\ and {\it typreal\/} \ra}  & type realisation & \x[\ref{closure}]
\end{tabular}

\subsubsection*{Specifications and Descriptions}

\begin{tabular}{lllll}
{\it spec} & ::= & {\tt val} {\it tyvarseq} {\it valdesc}     & value specification & \x[\ref{valspec}] \\
%& & {\tt val}  {\it valdesc}     & value specification & 
& & {\tt type} {\it typdesc}                    & abstract type \\
& & {\tt type} {\it typbind}            & type abbreviation \\
& & {\tt eqtype} {\it typdesc}          & abstract equality type\\
%& & {\tt datatype} {\it datdesc}        & datatype\\
& & {\tt datatype} {\it datdesc} \la\ {\tt withtype} {\it typbind\/} \ra\ &
                                          datatype with typbind & \x[\ref{datatypespec}]\\
& & {\tt datatype {\it tycon\/} = datatype {\it tyconpath\/}}
& datatype replication\\
& & {\tt exception} {\it exdesc}        & exception\\
& & {\tt structure} {\it strdesc}        & structure\\
& & {\tt functor} {\it fundesc}        & functor & \x \\
& & {\tt signature} {\it sigbind}        & signature & \x \\
& & {\tt include} {\it sigid\/}\et\ $\cdots$\ {\it strid\/}\n   & include,
 $n \geq 1$ \\
& & {\tt local} {\it lspec} {\tt in} {\it spec} {\tt end}
                                        & local specifications & \x\\
& &                                     & empty\\
& & {\tt {\it spec} $\langle${;}$\rangle$ {\it spec}} & sequential\\
%& & {\tt {\it spec} sharing type {\it longtycon}\et\ =\ $\cdots$\ =\ {\it longtycon}\n} & type sharing, $n \geq 2$\\
& & {\tt {\it spec} sharing type }& type sharing, $n \geq 2$\\
& & {\tt \quad {\it longtycon}\et\ =\ $\cdots$\ =\ {\it longtycon}\n} \\
%& & {\tt {\it spec} sharing {\it longstrid}\et =\ $\cdots$\ = {\it longstrid}\n} & structure sharing, $n \geq 2$\\
& & {\tt {\it spec} sharing} & structure sharing, $n \geq 2$\\
& & {\tt \quad {\it longstrid}\et\ =\ $\cdots$\ =\ {\it longstrid}\n} \\
& & {\tt infix \la{\it d\/}\ra\ $id_1 \cdots\ id_n$} & infix (left)
  directive, $n\geq 1$ & \x \\
& & {\tt infixr \la{\it d\/}\ra\ $id_1 \cdots\ id_n$} & infix (right)
  directive, $n\geq 1$ & \x \\
& & {\tt nonfix $id_1 \cdots id_n$} & nonfix directive, $n\geq 1$ & \x \\[2ex]

{\it lspec} & ::= & {\tt open} {\it longstrid$_1$\/} $\cdots$\ {\it
  longstrid$_n$\/}
                                        & (local) open & \x \\
& & {\tt type} {\it typbind}            & type abbreviation & \x \\
& & {\tt local} {\it lspec\/} {\tt in} {\it lspec} {\tt end}
        & local specifications & \\
& &                                             & empty & \x \\
& & {\tt {\it lspec\/} $\langle${;}$\rangle$ {\it lspec\/}} & sequential& \x\\[2ex]

{\it valdesc\/} & ::= & {\tt {\it vid\/} :\ {\it ty\/} \la\ and {\it
    valdesc\/} \ra} & value description\\[2ex]

{\it typdesc\/} & ::= & {\tt {\it tyvarseq\/} {\it tycon\/} \la\ and
  {\it typdesc\/} \ra} & type constructor description\\[2ex]
        
{\it datdesc\/} & ::= & {\tt {\it tyvarseq\/} {\it tycon\/} = {\it
    condesc\/} \la\ and {\it datdesc\/} \ra} & datatype description & \x[\ref{closure}] \\[2ex]

{\it condesc\/} & ::= & {\tt {\it vid\/} \la{of} {\it ty\/}\ra\ 
\la\ | {\it condesc\/} \ra} & constructor description\\[2ex]

{\it exdesc\/} & ::= & {\tt {\it vid\/} \la{of} {\it ty\/}\ra\ \la\
  and {\it exdesc\/} \ra} & exception constructor description\\[2ex]

{\it strdesc\/} & ::= & {\tt {\it strid\/} :\ {\it sigexp\/} 
\la\ and {\it strdesc\/} \ra} & structure description\\[2ex]

{\it fundesc\/} & ::= & {\tt {\it funid\/} :\ {\it sigexp\/} 
\la\ and {\it fundesc\/} \ra} & functor description\\[2ex]
\end{tabular}

\begin{itemize}

 \item  Although structure and functor identifiers reside in separate name-spaces,
 the syntax of structure and functor identifiers is identical.
 In the grammar, a module identifier {\it longmodid} may stand for either a 
 structure identifier {\it longstrid} or a functor identifier {\it longfunid}.
 Thus, {\sl a priori}, the module expression \opop\ \longmodid\
 may refer to a either a functor or a structure and the compiler
 must resolve this ambiguity (\opop\ is an optional prefix of the keyword \op).
 Fortunately,
 the context of the phrase often rules out one
 alternative, on the grounds that choosing that alternative 
 would force type checking to fail. In particular,
 if \opop\ \longmodid\ occurs as the right hand side of a structure
 (functor) binding, then \longmodid\ must be interpreted as a
 structure (functor) identifier; if
 \opop\ \longmodid\ occurs in the functor position of an application, then
 \longmodid\ must be interpreted as a functor identifier; if
 \opop\ \longmodid\ is constrained by a signature
 then the signature 
 forces a unique interpretation 
 on \longmodid\ (depending on whether the signature specifies a structure or functor).
 Similarly, if \opop\ \longmodid\ occurs as the argument of a functor application,
 then the functor's domain forces a unique interpretation 
 on \longmodid.
 Indeed, the only ambiguity that remains occurs when \opop\ \longmodid\ is the body of a functor. In this case, the optional prefix \opop\ is used to resolve
 the ambiguity:  the {\sl absence} of \op\ signals
 that \longmodid\ refers to structure; the {\sl presence} of \op\ signals that
 \op~\longmodid\ refers to a functor. 
 When the interpretation of \opop\ \longmodid\ is already
 determined by the context, the optional prefix \opop\ has {\sl no} effect.
 (This method of disambiguation relies on type information and is performed during
 type checking.)

 \item In a functor or functor signature's formal argument, 
{\tt ( {\it modid\/} :\ {\it sigexp} )} or 
{\tt {\it modid\/} :\ {\it sigexp} }, 
if {\it sigexp}
specifies a structure then {\it modid} binds the equivalent
structure identifier {\it strid};
if  {\it sigexp} specifies a functor, then {\it modid}
binds the equivalent functor identifier {\it funid}.



\item In a structure expression {\tt struct {\it dec\/} end}, any
signature declared in {\it dec\/} is local to {\it dec\/}: it does not
define a component of the structure {\tt struct {\it dec\/} end}, nor
is it visible in the type of {\tt struct {\it dec\/} end}.
(Note that the syntax for signature identifiers is not long, in
the sense of Section \ref{sec-identifiers}.)

\item In a signature expression {\tt sig {\it spec\/} end}, any
signature declared in {\it spec\/} is local to {\it spec\/}: in particular,
such a declaration does \emph{not}
specify that a structure matching {\tt sig {\it spec\/} end} should
also declare that signature.
\end{itemize}

\subsubsection*{Syntactic restrictions}

\begin{itemize}
\item No binding {\it strbind\/}, {\it funbind\/}, or {\it sigbind \/} may bind
      the same identifier twice.

\item No specification {\it valdesc\/}, {\it typdesc\/}, {\it
    typbind\/}, {\it datdesc\/}, {\it exdesc\/}, {\it strdesc} or {\it fundesc} may describe the same identifier twice; this applies also to value constructors
  within a {\it datdesc\/}.

\item In the left side {\it tyvarseq tycon\/} in any {\it typdesc\/},
  {\it typbind\/}, {\it datdesc\/}, or {\it typreal},
  or specification {\tt val {\it tyvarseq valdesc}}, {\it tyvarseq\/} must not
  contain the same {\it tyvar\/} twice. 
  Moscow ML
  requires that   any {\it tyvar\/} occurring within the right side
  is in scope (either explictly or implicitly), but not necessarily in
  {\it tyvarseq} (cf. Section \ref{sec-SMLrestrictions}, restriction \ref{closure}).

 
\item No sequential specification 
  may specify the same {\it tycon}, {\it vid}, {\it strid}, {\it funid}, {\it  sigid} or {\it id} (in a fixity specification) twice.
  
\item No {\it valdesc}, {\it datdesc}, or {\it exdesc} may specify
  {\tt true}, {\tt false}, {\tt nil}, {\tt ::}, or {\tt ref}.  No {\it
    datdesc\/} or {\it exdesc} may specify {\tt it}.

\item In a generative functor {\tt functor ( {\it modid\/} :\ {\it sigexp} ) => {\it modexp}}
, applicative functor {\tt functor {\it modid\/} :\ {\it sigexp\/} => {\it modexp}} 
or recursive structure  {\tt rec ( {\it strid\/} :\ {\it sigexp} ) {\it modexp}},
the body of {\it modexp} must be {\it applicative} in the sense that it contains
no structure or functor bindings of the form 
{\tt {\it strid\/} as {\it sigexp} = {\it exp}} or
{\tt {\it funid\/} as {\it sigexp} = {\it exp}},
excluding those bindings that occur within a Core {\tt let}-expression.
This restriction also applies to the bodies of functors declared in a {\it funbind}.



\end{itemize}

\newpage

\section{Grammar for the Moscow ML Unit language}


Moscow ML supports the separate compilation of named program fragments
called \emph{units}.  A unit {\tt unitid} consists of an optional
\emph{unit interface} in file {\tt unitid.sig}.  Each unit can be
compiled in one of two \emph{modes}: \emph{structure} mode and
\emph{toplevel} mode.  A unit's implementation and interface files
must be compiled in the \emph{same} mode.

In the batch compiler {\tt mosmlc}, a unit's compilation mode is
specified by preceding it with the command-line argument {\tt -structure} 
(the default) or {\tt -toplevel}.  In the interactive
system {\tt mosml}, the compilation mode of a unit is determined by
the function with which it is compiled: {\tt compile} and 
{\tt compileStructure} compile in \emph{structure} mode; 
{\tt compileToplevel} compiles in \emph{toplevel} mode.

Note that the intended mode of a unit is not determined by file name
extension or by file content: the mode must be explicitly indicated
to the batch compiler and interactive system.

The syntax and semantics of a unit's interface and implementation
files depends on the mode and is described in the following sections.


\subsection{Syntax and semantics for units compiled in \emph{structure} mode}

In \emph{structure} mode, the unit interface file {\tt unitid.sig}, if
present, must contain a single Moscow ML signature declaration binding
the signature {\tt unitid}; the unit implementation file {\tt
  unitid.sml} must contain a single Moscow ML structure declaration,
binding the structure {\tt unitid}.  The unit interface may be
omitted.

With the batch compiler {\tt mosmlc}, the files {\tt unitid.sig} and
{\tt unitid.sml} are compiled in \emph{structure} mode if their
filenames are preceded by the command line argument {\tt -structure},
eg:

\begin{alltt}
   mosmlc -c -structure unitid.sig unitid.sml 
\end{alltt}

\noindent Since \emph{structure} mode is the default compilation
mode, the {\tt -structure} option may also be omitted:

\begin{alltt}
   mosmlc -c unitid.sig unitid.sml 
\end{alltt}

\noindent 
In the interactive system, a unit interface or implementation may be
compiled in structure mode using the functions {\tt compile} and {\tt
  compileStructure}.  

The semantics of

\begin{alltt}
   - compileStructure ["unitid\et",\allttcdots,"unitid\n"] "unitid.sig";(* if unitid.sig exists *) 
   - compileStructure ["unitid\et",\allttcdots,"unitid\n"] "unitid.sml";
   - load "unitid";
\end{alltt}
\noindent is roughly equivalent to that of
\begin{alltt}
   - load "unitid\et";
   \allttcdots
   - load "unitid\n";
   - use "unitid.sig"; (* if unitid.sig exists *)
   - use "unitid.sml";
\end{alltt}

Note that the unit interface {\tt unitid.sig}, if present, should be {\tt use}'ed in the interactive system,
since the interface declares a signature that is referred to in {\tt unitid.sml}, and may be referred to
in other units that depend on unit {\tt unitid}.
A structure-mode unit interface has two effects: it (a) declares a signature and (b)
serves to constrain the structure defined in the unit implementation.

\subsubsection*{Structure-mode unit implementation (in file {\tt unitid.sml})}

\begin{tabular}{lllll}
{\it unitimp\/} & ::= 
  & {\tt structure {\it unitid\/} = {\it modexp\/}} & structure \\
& & {\tt structure {\it unitid\/} :> {\it unitid\/} = {\it modexp}}
                                                & structure with
                                                signature \\
& & {\it cdec\/}                                 & core declaration & deprecated\\[2ex]
{\it cdec\/} & ::= & {\tt val {\it tyvarseq\/} {\it valbind\/}} & value declaration\\
& & {\tt fun {\it tyvarseq\/} {\it fvalbind\/}} & function declaration\\
& & {\tt type {\it typbind\/}} & type declaration\\
& & {\tt datatype {\it datbind\/} \la\ withtype {\it typbind\/} \ra} 
& datatype declaration\\
& & {\tt datatype {\it tycon\/} = datatype {\it tyconpath\/}}
& datatype replication\\
& & {\tt abstype {\it datbind\/} \la\ withtype {\it typbind\/} \ra}
& abstype declaration\\
& & \hspace{1.5cm}{\tt with {\it dec\/} end}\\
& & {\tt exception {\it exbind\/}} & exception declaration\\
& & {\tt local {\it dec\/}\et\ in {\it dec\/}\to\ end} 
& local declaration\\
& & {\tt open {\it longstrid\/}\et\ $\cdots$ {\it longstrid\/}\n}
& open declaration, $n\geq 1$\\
& & & empty declaration\\
& & {\tt {\it cdec\/}\et\ \la;\ra\ {\it cdec\/}\to} 
& sequential declaration\\
& & {\tt infix \la{\it d\/}\ra\ $id_1 \cdots id_n$} & infix (left)
  directive, $n\geq 1$\\
& & {\tt infixr \la{\it d\/}\ra\ $id_1 \cdots id_n$} & infix (right)
  directive, $n\geq 1$\\
& & {\tt nonfix $id_1 \cdots id_n$} & nonfix directive, $n\geq
  1$\\[2ex]
\end{tabular}

\subsubsection*{Structure-mode unit interface (in file {\tt unitid.sig})}

\begin{tabular}{lllll}
{\it unitint\/} & ::= 
  & {\tt signature} {\it unitid} {\tt =}  {\it sigexp\/} 
                                                & signature binding \\
& & {\it cspec\/}                               & core specification & deprecated \\[2ex]

{\it cspec} & ::= & {\tt val}  {\it tyvarseq\/} {\it valdesc}    & value specification & \x[\ref{valspec}] \\ 
%& & {\tt val} {\it tyvarseq} {\it valdesc}     & value specification & \x \\
& & {\tt type} {\it typdesc}                    & abstract type \\
& & {\tt type} {\it typbind}            & type abbreviation \\
& & {\tt eqtype} {\it typdesc}          & abstract equality type\\
& & {\tt datatype} {\it datdesc} \la\ {\tt withtype} {\it typbind\/} \ra\ &
                                          datatype with typbind & \x[\ref{datatypespec}]\\
& & {\tt datatype {\it tycon\/} = datatype {\it tyconpath\/}}
& datatype replication\\
& & {\tt exception} {\it exdesc}        & exception\\
& & {\tt local} {\it lspec} {\tt in} {\it spec} {\tt end}
                                        & local specifications & \x\\
& &                                     & empty\\
& & {\tt {\it cspec} $\langle${;}$\rangle$ {\it cspec}} & sequential\\
& & {\tt infix \la{\it d\/}\ra\ $id_1 \cdots\ id_n$} & infix (left)
  directive, $n\geq 1$ & \x \\
& & {\tt infixr \la{\it d\/}\ra\ $id_1 \cdots\ id_n$} & infix (right)
  directive, $n\geq 1$ & \x \\
& & {\tt nonfix $id_1 \cdots id_n$} & nonfix directive, $n\geq 1$ & \x \\[2ex]
\end{tabular}

\subsubsection*{Syntactic restrictions}

\begin{itemize}
\item In Moscow ML, the {\it unitid}, if specified in the unit interface
  or unit implementation, must agree with the filename ({\tt {\it unitid}.sig} or
  {\tt {\it unitid}.sml}). 
  In the unit implementation, the name of the
  constraining signature, if any, must equal that of the structure.

\item The unit implementation syntax {\it cdec} is deprecated and is provided only 
to support code written for earlier versions of Moscow ML  (versions prior 
to $2.xx$). The phrase class
{\it cdec} is a proper subset of {\it dec} and is subject to the same restrictions as {\it dec}. The class {\it cdec} excludes
  declarations beginning with {\tt structure}, {\tt functor}, or
  {\tt signature}.

\item The unit implementation syntax {\it cdec}  abbreviates 
{\tt structure {\it unitid\/} \la:> {\it unitid\/}\ra\ = struct {\it cdec\/} end} 
thus any fixity directives in {\it cdec} are
local to the structure expression
{\tt struct {\it cdec\/} end} and are not exported in the interface.

\item The unit interface syntax {\it cspec} is deprecated and is provided only 
to support code written for earlier versions of Moscow ML  (versions prior 
to $2.xx$). The phrase class
{\it cspec} is a proper subset of {\it spec} and is subject to the same restrictions as {\it spec}. 
The class {\it cspec} excludes
specifications beginning with {\tt structure}, {\tt functor}, {\tt signature}  or {\tt include} and {\tt sharing} specifications.

\item The unit interface syntax {\it cspec}  abbreviates
 {\tt signature {\it unitid\/} = sig {\it cspec\/} end}
thus any fixity directives in {\it cspec} are local to the signature expression 
{\tt sig {\it cspec\/} end} 
and are not exported in the interface.

\end{itemize}

\subsection{Syntax and semantics for units compiled in \emph{toplevel} mode}

In \emph{toplevel} mode, the unit interface in file {\tt unitid.sig},
if present, must be a Moscow ML specification (which may itself be a
sequence of specifications); the unit implementation in file {\tt
  unitid.sml} must be a Moscow ML declaration (which may itself be a
sequence of declarations).  The unit interface may be omitted.

With the batch compiler {\tt mosmlc}, the files {\tt unitid.sig} and
{\tt unitid.sml} are compiled in \emph{toplevel} mode only if their
filenames are preceded by the command line argument {\tt -toplevel}.

\begin{alltt}
   mosmlc -c -toplevel unitid.sig unitid.sml
\end{alltt}

\noindent 
In the interactive system, a unit interface or implementation may be
compiled in \emph{toplevel} mode using the function {\tt
  compileToplevel}.

The semantics of
\begin{alltt}
   - compileToplevel ["unitid\et",\allttcdots,"unitid\n"] "unitid.sig"; (* if unitid.sig exists *) 
   - compileToplevel ["unitid\et",\allttcdots,"unitid\n"] "unitid.sml";
   - load "unitid";
\end{alltt}

\noindent Provided the compilation of {\tt unit.sml} issues no warnings (see below), this is equivalent to

\begin{alltt}
   - load "unitid\et";
   \allttcdots
   - load "unitid\n";
   - use "unitid.sml";
\end{alltt}

Note that the unit interface {\tt unitid.sig}, if present, should not be {\tt use}'ed in the interactive system.
Unlike the interface of structure-mode unit, which declares a signature, {\tt unitid.sig} does not contain a declaration,
but merely the specification of the declarations in {\tt unitid.sml}. 
The only purpose of  the interface file is to support the separate compilation of units that depend on the unit
{\tt unitid} (for instance, in the absence of file {\tt unit.sml}). Since  {\tt use}ing the implementation, as
opposed to {\tt load}ing  the compiled unit,
can potentially (a)  declare identifiers that are not specified in
the interface, or (b) declare constructors and exceptions, that are only specified as ordinary values in the interface,
and both (a) and (b) may affect the meaning of subsequent code, when compiling a toplevel-mode implementation 
against its interface, Moscow ML will issue warning whenever (a) or (b) occurs.




\subsubsection*{Toplevel-mode unit implementation (in file {\tt unitid.sml})}

\begin{tabular}{llll}
{\it unitimp\/} & ::= & {\it dec\/} & declaration \\
\end{tabular}

\subsubsection*{Toplevel-mode unit interface (in file {\tt unitid.sig})}

\begin{tabular}{lllll}
{\it unitint\/} & ::=   & {\it spec\/} & specification \\
\end{tabular}

\newpage

\section{Further restrictions imposed for Standard ML compliance}\label{sec-SMLrestrictions}

In addition to the syntactic restrictions imposed by Moscow ML,
compiling programs in {\tt orthodox} or {\tt conservative} mode (see Section
\ref{sec-SMLcompliance}),
imposes the following additional restrictions. These
are required to ensure compliance with Standard ML.


\begin{itemize}

\item \refstepcounter{extension}
      \label{extension} 
      Any instance of a Moscow ML phrase that is marked with a plain \x\ in the grammar is illegal Standard ML.
     

\item Any instance of a Moscow ML phrase that is marked with a \x[$N$] in the grammar is illegal Standard ML unless it satisfies restriction $N$ below:

\begin{enumerate}
\item\label{strdec} 
  A structure declaration   {\tt structure {\it strbind\/}}
  may only occur at top level, within the declarations of a structure, or within
  a declaration local to the declarations of a structure, but not within a Core {  \tt let}-expression.

\item\label{topdec} 
  A functor declaration   {\tt functor {\it funbind\/}} or
  signature declaration   {\tt signature {\it sigbind\/}}
  may only occur at the top level of a program, but not within the 
  declarations of a structure or Core 
  {\tt let}-expression.

\item\label{closure} 
  In any {\it typbind\/}, {\it datbind\/}, {\it datdesc} or {\it typreal},
  any {\it tyvar\/} occurring within the right side
  must occur in the {\it tyvarseq\/} of the left side. 

 \item\label{atmodexp} 
  A functor application {\tt appmodexp atmodexp} 
  must be an application of a functor
  identifier to a single argument of the form:

  \begin{tabular}{lr}
  {\tt {\it funid\/} ( {\it modexp\/} )} &  or\\
  {\tt {\it funid\/} ( {\it dec\/} )}
  \end{tabular}

  The parenthesised structure expressions {\tt ( {\it modexp\/} )} and
  {\tt( {\it dec\/} )}, although otherwise illegal in SML, are legal 
  when occurring as a functor argument.

 \item\label{funbind} 
  A functor binding must define a one-argument, generative functor, 
  and must have the form:

  \begin{tabular}{l}
  {\tt {\it funid\/}  ( {\it modid\/} :\ {\it sigexp} )  \la\ {\it con\/} \ra\ =        {\it modexp}}\\
  \quad {\tt \la\ and {\it funbind} \ra} 
  \end{tabular}

  \item\label{valspec} 
  In a value specification {\tt val} {\it tyvarseq\/} {\it valdesc\/},
  {\it tyvarseq\/} must be empty, so that the specification is of the form:

  \begin{tabular}{l}
   {\tt val} {\it valdesc\/}
  \end{tabular}

  \item\label{datatypespec} 
  In a datatype specification 
  {\tt datatype}  {\it datdesc} \la\ {\tt withtype} {\it typbind\/} \ra\
  the option must be absent, so that the specification is of the form:

  \begin{tabular}{l}
  {\tt datatype}  {\it datdesc}
  \end{tabular}
\end{enumerate}
\end{itemize}

\newpage

\section{Built-in types, constructors and exceptions}
\label{sec-builtin}

The following types, constructors, and exceptions are available in the
initial environment, of the interactive system as well as files
compiled with the batch compiler {\tt mosmlc} or the {\tt compile}
function.


\subsection*{Built-in types}

\begin{tabular}{@{\tt\ \ }llll}\hline

{\rm Type} & Values & Admits equality & Constructors and constants\\\hline
'a array    & Arrays                  &  yes \\
bool        & Booleans                &  yes  & {\tt false}, {\tt true}\\
char        & Characters              &  yes & \verb$#"a"$,
    \verb$#"b"$, $\cdots$\\ 
exn         & Exceptions              &  no\\
'a frag     & Quotation fragments     &  if {\tt 'a} does 
& {\tt QUOTE}, {\tt ANTIQUOTE}\\
int         & Integers                & yes & {\tt 241}, {\tt 0xF1}, $\cdots$\\
'a list     & Lists                   &  if {\tt 'a} does & {\tt nil},
    {\tt ::}\\ 
'a option   & Optional results        &  if {\tt 'a} does & {\tt
  NONE}, {\tt SOME}\\ 
order       & Comparisons  &  yes  & {\tt LESS}, {\tt
  EQUAL}, {\tt GREATER}\\
real        & Floating-point numbers  &  yes\\
'a ref      & References              &  yes            & {\tt ref}\\
string      & Strings                 &  yes\\
substring   & Substrings              &  no\\
unit        & The empty tuple {\tt ()}    & yes \\
'a vector   & Vectors                 &  if {\tt 'a} does \\
word        & Words (31-bit)          &  yes & {\tt 0w241}, {\tt
  0wxF1}, $\cdots$ \\
word8       & Bytes (8 bit)           &  yes & {\tt 0w241}, {\tt
  0wxF1}, $\cdots$ \\\hline 
\end{tabular}


\subsection*{Built-in exception constructors}

\begin{verbatim}
          Bind  Chr  Domain  Div  Fail  Graphic  Interrupt  Io
          Match  Option  Ord  Overflow  Size  Subscript  SysErr
\end{verbatim}

\newpage

\section{Built-in variables and functions}

For each variable or function we list its type and meaning.  Some
built-in identifiers are overloaded; this is specified using {\em
  overloading classes\/}.  For instance, an identifier whose type
involves the overloading class {\tt realint} stands for two functions:
one in which {\tt realint} (in the type) is consistently replaced by
{\tt int}, and another in which {\tt realint} is consistently replaced
by {\tt real}.  The overloading classes are:

\begin{center}
\begin{tabular}{|l|l|}\hline
Overloading class & Corresponding base types\\\hline
{\tt realint} & {\tt int}, {\tt real}\\
{\tt wordint} & {\tt int}, {\tt word}, {\tt word8}\\
{\tt num} &  {\tt int}, {\tt real}, {\tt word}, {\tt word8}\\
{\tt numtxt} &  {\tt int}, {\tt real}, {\tt word}, {\tt word8}, {\tt
  char}, {\tt string}\\\hline
\end{tabular}
\end{center}

\noindent When the context does not otherwise resolve the overloading,
it defaults to {\tt int}.


\subsection*{Nonfix identifiers in the initial environment}

\begin{tabular}{@{\tt\ \ }llll}\hline
{\it id\/}  &  type &     effect & exception \\\hline

\verb#~#    & {\tt realint -> realint}  &           arithmetic negation
        & {\tt Overflow}\\

!           & {\tt 'a ref -> 'a} &        dereference\\

abs         & {\tt realint -> realint}  & absolute value & {\tt Overflow}\\

app         & {\tt ('a -> unit) -> 'a list -> unit} 
        & apply to all elements\\

ceil       & {\tt real -> int} &           round towards $+\infty$ 
        & {\tt Overflow}\\

chr         & {\tt int -> char} &           character with number &
{\tt Chr}\\

concat      & {\tt string list -> string} & concatenate strings 
& {\tt Size}\\

explode     & {\tt string -> char list} &   list of characters in string\\

false       & {\tt bool} & logical falsehood\\

floor       & {\tt real -> int} &           round towards $-\infty$ 
        & {\tt Overflow}\\

foldl       & {\tt ('a*'b->'b)->'b->'a list->'b}
        & fold from left to right\\

foldr       & {\tt ('a*'b->'b)->'b->'a list->'b}
        & fold from right to left\\

hd          & {\tt 'a list -> 'a}         & first element & {\tt Empty}\\

help        & {\tt string -> unit}        & simple help utility\\

ignore      & {\tt 'a -> unit} &            discard argument\\

implode     & {\tt char list -> string} &   make string from
characters & {\tt Size}\\

length      & {\tt 'a list -> int}        & length of list\\

map         & {\tt ('a -> 'b) -> 'a list -> 'b list}
            & map over all elements\\

nil         & {\tt 'a list} &               empty list\\

not         & {\tt bool -> bool} &          logical negation\\

null        & {\tt 'a list -> bool}       & true if list is empty\\

ord         & {\tt char -> int} &           number of character\\

print       & {\tt string -> unit} & print on standard output\\

real        & {\tt int -> real} &           {\tt int} to {\tt real}\\

ref         & {\tt 'a -> 'a ref} &       create reference value\\

rev         & {\tt 'a list -> 'a list}    & reverse list\\

round       & {\tt real -> int} &           round to nearest integer 
        & {\tt Overflow}\\

size        & {\tt string -> int} &         length of string\\

str         & {\tt char -> string} &        create one-character string\\

substring   & {\tt string * int * int -> string} & get substring
$(s, first, len)$ & {\tt Subscript}\\

tl          & {\tt 'a list -> 'a list}    & tail of list & {\tt Empty}\\

true        & {\tt bool} & logical truth \\

trunc       & {\tt real -> int} &           round towards $0$ 
        & {\tt Overflow}\\

vector      & {\tt 'a list -> 'a vector} & make vector from list & 
              {\tt Size}\\\hline 
\end{tabular}


\subsection*{Infixed identifiers in the initial environment}

\begin{tabular}{@{\tt\ \ }llll}\hline
{\it id\/}  &  type &     effect & exception \\\hline\hline
\multicolumn{4}{@{}l}{Infix precedence 7:}\\
/     & {\tt real * real -> real} &     floating-point quotient 
        & {\tt Div, Overflow }\\
div   & {\tt wordint * wordint -> wordint}    &     quotient (round towards
$-\infty$)  & {\tt Div, Overflow}\\
mod   & {\tt wordint * wordint -> wordint} & remainder (of {\tt div}) &
{\tt Div, Overflow}\\
\verb#*# & {\tt num * num -> num}    &     product                 & {\tt
Overflow}\\\hline
\multicolumn{4}{@{}l}{Infix precedence 6:}\\
+ &         {\tt num * num -> num}  &        sum        & {\tt Overflow}\\
- &         {\tt num * num -> num}  &        difference & {\tt Overflow}\\
\verb#^# &  {\tt string * string -> string} & concatenate & {\tt Size}\\\hline
\multicolumn{4}{@{}l}{Infix precedence 5:}\\
:: &  {\tt 'a * 'a list -> 'a list}  & cons onto list (R)\\
@  &  {\tt 'a list * 'a list -> 'a list} &   append lists (R)\\\hline
\multicolumn{4}{@{}l}{Infix precedence 4:}\\
=   & {\tt ''a * ''a -> bool}   & equal to\\
<>  & {\tt ''a * ''a -> bool}   & not equal to\\
<   & {\tt numtxt * numtxt -> bool} & less than\\
<=  & {\tt numtxt * numtxt -> bool} & less than or equal to\\
>   & {\tt numtxt * numtxt -> bool} & greater than\\
>=  & {\tt numtxt * numtxt -> bool} & greater than or equal to\\\hline
\multicolumn{4}{@{}l}{Infix precedence 3:}\\
:= & {\tt 'a ref * 'a -> unit}  & assignment\\
o  & {\tt ('b->'c) * ('a->'b) -> ('a->'c)}&  function composition\\\hline
\multicolumn{4}{@{}l}{Infix precedence 0:}\\
before & {\tt 'a * 'b -> 'a} & return first argument\\\hline
\end{tabular}

\vspace*{0.8cm}

\subsection*{Built-in functions available only in the interactive system
  (unit {\tt Meta})}

\begin{tabular}{@{\tt\ \ }llll}\hline
%{\it id\/}  &  \makebox[5cm][l]{type} &     effect & exception \\\hline
{\it id\/}  &  type &     effect & exception \\\hline
compile        & {\tt string -> unit} & compile unit (U.sig or U.sml)
& {\tt Fail}\\
& & (in \emph{structure} mode) \\
compileStructure & {\tt string list ->} & In context U\et, $\ldots$, U\n, & {\tt Fail}\\
& {\tt string -> unit} & compile unit (U.sig or U.sml) \\
& & (in \emph{structure} mode) \\
compileToplevel & {\tt string list ->} & In context U\et, $\ldots$, U\n, & {\tt Fail}\\
& {\tt string -> unit} & compile unit (U.sig or U.sml) \\
& & (in \emph{toplevel} mode) \\
conservative & {\tt unit -> unit} & deprecate all Moscow ML extensions\\
%installPP      & {\tt (ppstream->'a->unit)->unit} & install prettyprinter \\
installPP      & {\tt (ppstream->'a->unit)} & install prettyprinter\\
            & {\tt -> unit} & \\
liberal & {\tt unit -> unit} & accept all Moscow ML extensions\\
load        & {\tt string -> unit} & load unit U and any units it needs
               & {\tt Fail}\\
loaded        & {\tt unit -> string list} & return list of loaded units
               &\\
loadOne        & {\tt string -> unit} & load unit U (only)
               & {\tt Fail}\\
loadPath       & {\tt string list ref} & search path for {\tt load}, 
                {\tt loadOne}, {\tt use}\\ 
orthodox & {\tt unit -> unit} & reject any Moscow ML extensions\\
printVal       & {\tt 'a -> 'a}  & print value on \verb#stdOut#\\
printDepth     & {\tt int ref}   & limit printed data depth\\
printLength    & {\tt int ref}   & limit printed list and vector length\\
quietdec       & {\tt bool ref}  & suppress prompt and responses\\
quit           & {\tt unit -> unit} & quit the interactive system\\
quotation      & {\tt bool ref}   & permit quotations in source code\\
system         & {\tt string -> int} & execute operating system command\\
use            & {\tt string -> unit} & read declarations from file\\
valuepoly      & {\tt bool ref}   & adopt value polymorphism \\
verbose        & {\tt bool ref}   & permit feedback from {\tt
  compile}\\\hline
\end{tabular}

\begin{itemize}
% \item These functions are not part of the SML Basis Library.
\item The Moscow ML Owner's Manual describes how to use {\tt compile},
  {\tt compileStructure}, \newline {\tt compileToplevel}
  and {\tt load} to perform separate compilation, and how to use
  quotations.  Evaluating {\tt load {\rm U}} automatically loads any
  units needed by U, and does nothing if U is already loaded; whereas
  {\tt loadOne {\rm U}} fails if any unit needed by U is not loaded,
  or if U is already loaded.  The {\tt loadPath} variable determines
  where {\tt load}, {\tt loadOne}, and {\tt use} will look for files.
  The commands {\tt orthodox}, {\tt conservative} and {\tt liberal}
  cause Moscow ML to enforce, monitor or ignore compliance to Standard ML.
\end{itemize}

\newpage
\section{List of all library modules}

A table of Mosml ML's predefined library modules is given on
page~\pageref{table-predefined-units}.  The status of each module is
indicated as follows:

\begin{center}
\begin{tabular}{lcl}
{\tt S} & : & the module belongs to the SML Basis Library.\\

{\tt D} & : & the module is preloaded by default.\\

{\tt F} & : & the module is loaded when option {\tt -P full}
  is specified.\\

{\tt N} & : &  the module is loaded when option {\tt -P nj93}
  is specified.\\

{\tt O} & : & the module is loaded when option {\tt -P sml90}
  is specified.
\end{tabular}
\end{center}

\noindent To find more information about the Moscow ML library:

\begin{itemize}
%\item The index in Section~\ref{sec-libindex}
%  (page~\pageref{sec-libindex}) lists all identifiers defined in
%  Moscow ML library modules.

\item Typing {\tt help "lib";} in a {\tt mosml} session gives a list of
  all library modules.

\item Typing {\tt help "{\it module\/}";} in a {\tt mosml} session gives
  information about library module {\it module\/}.

\item Typing {\tt help "{\it id\/}";} in a {\tt mosml} session gives
  information about identifier {\it id\/}, regardless which library
  module(s) it is defined in.

\item In your Moscow ML installation, consult the library documentation 
(in printable format):
\begin{verbatim}
    mosml/doc/mosmllib.ps
    mosml/doc/mosmllib.pdf
\end{verbatim}

\item In your Moscow ML installation, you may find the same documentation
  in HTML-format at 

\begin{verbatim}
    mosml/doc/mosmllib/index.html
\end{verbatim}

\item On the World Wide Web the same pages are online at
\begin{alltt}
    \url{http://www.dina.kvl.dk/~sestoft/mosmllib/index.html}    
\end{alltt}
  
  If you do not have the HTML pages, you may download them from the
  Moscow ML home page.
\end{itemize}


\begin{center}\small\renewcommand{\arraystretch}{0.9}
\begin{tabular}{@{}|lll|}\hline
Library module & Description & Status\\\hline
{\tt Array}  & Mutable polymorphic arrays & {\tt SDF}\\
{\tt Array2} & Two-dimensional arrays & {\tt S }\\
{\tt Arraysort} &  Array sorting (quicksort) & \\
{\tt BasicIO} &  Input-output as in SML'90 & {\tt \ DF}\\
{\tt Binarymap} &  Binary tree implementation of finite maps &\\
{\tt Binaryset} &  Binary tree implementation of finite sets &\\
{\tt BinIO}  & Binary input-output streams (imperative) & {\tt S F}\\
{\tt Bool}  & Booleans & {\tt S F}\\
{\tt Byte}  &  Conversions between {\tt Word8} and {\tt Char} & {\tt S F}\\
{\tt Callback}  &  Registering ML values for access from C code & {\tt SDF}\\
{\tt Char}  &  Characters & {\tt SDF}\\
{\tt CharArray} & Mutable arrays of characters & {\tt S F}\\
{\tt CharVector} & Immutable character vectors (that is, strings) & {\tt S F}\\
{\tt CommandLine} & Program name and arguments & {\tt S F}\\
{\tt Date}   & From time points to dates and vice versa& {\tt S F}\\
{\tt Dynarray} & Dynamic arrays & \\
{\tt Dynlib}  & Dynamic linking with C & \\
{\tt FileSys} & File system interface & {\tt S F}\\
{\tt Gdbm}    & Persistent hash tables of strings (GNU gdbm) & \\
{\tt Gdimage} & Generation of PNG images (Boutell's GD package) & \\
{\tt General} & Various top-level primitives & {\tt SD}\\
{\tt Help} & On-line help & {\tt \ DFNO}\\
{\tt Int} & Integer arithmetic and comparisons & {\tt S F}\\
{\tt Intmap} & Finite maps from integers & \\
{\tt Intset} & Finite sets of integers & \\
{\tt List}   & Lists & {\tt SDFNO}\\
{\tt ListPair} & Pairs of lists & {\tt S F}\\
{\tt Listsort} & List sorting (mergesort) & \\
{\tt Location} & Error reporting for lexers and parsers & \\
{\tt Math}   & Trigonometric and transcendental functions & {\tt S F}\\
{\tt Meta}   & Functions specific to the interactive system &\\
{\tt Mosml}  & Various Moscow ML utilities & {\tt \ \ F}\\
{\tt Mosmlcgi}  & Utilities for writing CGI programs & \\
{\tt Mosmlcookie}  & manipulating cookies in CGI programs & \\
{\tt Msp}    & Utilities for efficiently generating HTML code & \\
{\tt Mysql}  & Interface to the MySQL database server & \\
{\tt NJ93}   & Top-level compatibility with SML/NJ 0.93 & {\tt \ \ \ N}\\
{\tt OS}     & Operating system interface & {\tt S F}\\
{\tt Option} & Partial functions & {\tt SDFNO}\\
{\tt Path}   & File pathnames & {\tt S F}\\
{\tt Polygdbm} & Polymorphic persistent hash tables (GNU gdbm) & \\
{\tt Polyhash} & Polymorphic hash tables & \\
{\tt Postgres} & Interface to the PostgreSQL database server & \\
{\tt PP}     & General prettyprinters & {\tt \ \ F}\\
{\tt Process} & Process interface & {\tt S F}\\
{\tt Random} & Generation of pseudo-random numbers & \\
{\tt Real}   & Real arithmetic and comparisons & {\tt S F}\\
{\tt Regex}  & Regular expressions as in POSIX 1003.2 & \\
{\tt Signal}   & Unix signals & {\tt S}\\
{\tt SML90}    & Top-level compatibility with 1990 Definition & {\tt S\
  \ \ O}\\
{\tt Socket} & Interface to sockets & \\
{\tt Splaymap} & Splay-tree implementation of finite maps &\\
{\tt Splayset} & Splay-tree implementation of finite sets &\\
{\tt String} & String utilities & {\tt SDF}\\
{\tt StringCvt} & Conversion to and from strings & {\tt S F}\\
{\tt Substring} & Scanning of substrings & {\tt S F}\\
{\tt TextIO} & Text input-output streams (imperative) & {\tt SDF}\\
{\tt Time}   & Time points and durations & {\tt S F}\\
{\tt Timer}  & Timing operations & {\tt S F}\\
{\tt Unix}   & Starting concurrent subprocesses under Unix & {\tt S}\\
{\tt Vector} & Immutable vectors & {\tt SDF}\\
{\tt Weak}   & Arrays of weak pointers & \\
{\tt Word}   & Unsigned 31-bit integers (`machine words') & {\tt S F}\\
{\tt Word8}  & Unsigned 8-bit integers (bytes) & {\tt S F}\\
{\tt Word8Array}  & Mutable arrays of unsigned 8-bit integers & {\tt S F}\\
{\tt Word8Vector} & Immutable vectors of unsigned 8-bit integers
        & {\tt S F}\\\hline
\end{tabular}
\label{table-predefined-units}
\end{center}


\newpage

\section{The preloaded library modules}

The following libraries are preloaded by default: {\tt Array}, {\tt
  Char}, {\tt List}, {\tt String}, {\tt TextIO}, and {\tt Vector}.  To
load any other library {\it lib\/}, evaluate {\tt load "{\it lib\/}"}
in the interactive system.


\subsection*{Notation in the tables below}

\begin{center}
\begin{tabular}{|l|l|}\hline
$f$ & functional argument\\
$n$ & integer\\
$p$ & predicate of type  ({\tt 'a -> bool})\\
$s$ & string\\
$xs, ys$ & lists\\\hline
\end{tabular}
\end{center}


\subsection*{List manipulation functions (module {\tt List})}

\begin{tabular}{@{\tt\ \ }lll}\hline
{\it id\/}  &  type &     effect \\\hline
@           & {\tt 'a list * 'a list -> 'a list} 
        &    append\\
all         & {\tt ('a -> bool) -> 'a list -> bool} 
        & if $p$ true of all elements\\
app         & {\tt ('a -> unit) -> 'a list -> unit} 
        & apply $f$ to all elements\\
concat      & {\tt 'a list list -> 'a list} 
        & concatenate lists\\
drop    & {\tt 'a list * int -> 'a list}
        & drop $n$ first elements\\
exists      & {\tt ('a -> bool) -> 'a list -> bool} 
        & if $p$ true of some element\\
filter      & {\tt ('a -> bool) -> 'a list -> 'a list}
        & the elements for which $p$ is true\\
find        & {\tt ('a -> bool) -> 'a list -> 'a option} 
        & first element for which $p$ is true\\
foldl       & {\tt ('a * 'b -> 'b) -> 'b -> 'a list -> 'b}
        & fold from left to right\\
foldr       & {\tt ('a * 'b -> 'b) -> 'b -> 'a list -> 'b}
        & fold from right to left\\
hd          & {\tt 'a list -> 'a}
        & first element\\
last        & {\tt 'a list -> 'a}
        & last element\\
length      & {\tt 'a list -> int}
        & number of elements\\
map         & {\tt ('a -> 'b) -> 'a list -> 'b list}
        & results of applying $f$ to all elements\\
mapPartial  & {\tt ('a -> 'b option) -> 'a list -> 'b list} 
        & list of the non-{\tt NONE} results of $f$\\
nth         & {\tt 'a list * int -> 'a}
        & $n$'th element (0-based)\\
null        & {\tt 'a list -> bool}
        & true if list is empty\\
partition   & {\tt ('a->bool)->'a list->'a list*'a list}
        &  compute (true for $p$, false for $p$)\\
rev         & {\tt 'a list -> 'a list}
        & reverse list\\
revAppend   & {\tt 'a list * 'a list -> 'a list}
        & compute {\tt (rev $xs$) @ $ys$}\\ 
tabulate    & {\tt int * (int -> 'a) -> 'a list}
        & compute {\tt [$f$(0),$\cdots$,$f$(n-1)]}\\
take    & {\tt 'a list * int -> 'a list}
        & take $n$ first elements\\
tl          & {\tt 'a list -> 'a list}
        & tail of list\\\hline
\end{tabular}

\begin{itemize}
% \item Functions {\tt hd}, {\tt tl}, and {\tt last} may raise exception
%   {\tt Empty}; functions {\tt drop}, {\tt nth}, and {\tt take} may
%   raise exception {\tt Subscript}.

\item For a more detailed description, type {\tt help "List";} or see
  file {\tt mosml/lib/List.sig}.  The {\tt List} module is loaded and
  partially opened in the initial environment, making the following
  functions available: {\tt @}, {\tt app}, {\tt foldl}, {\tt foldr},
  {\tt hd}, {\tt length}, {\tt map}, {\tt null}, {\tt rev}, {\tt tl}.
\end{itemize}


\subsection*{Built-in values and functions for text-mode input/output (module
  {\tt TextIO})}

\begin{tabular}{@{\tt\ \ }lll}\hline
{\it id\/}  &  type &     effect \\\hline

closeIn       & {\tt instream -> unit}  
        & close input stream\\
closeOut      & {\tt outstream -> unit}
        & close output stream\\
endOfStream  & {\tt instream -> bool}
        & true if at end of stream\\
flushOut     & {\tt outstream -> unit}
        & flush output to consumer\\
input         & {\tt instream -> string}
        & input some characters\\
input1         & {\tt instream -> char option}
        & input one character\\
inputN         & {\tt instream * int -> string}
        & input at most $n$ characters\\
inputAll         & {\tt instream -> string} 
        & input all available characters\\
inputLine    & {\tt instream -> string}
        & read up to (and including) next end of line\\
inputNoBlock    & {\tt instream -> string option}
        & read, if possible without blocking\\
lookahead      & {\tt instream -> char option} 
        & get next char non-destructively\\
openAppend   & {\tt string -> outstream} 
        & open file for appending to it\\
openIn       & {\tt string -> instream}
        & open file for input\\
openOut      & {\tt string -> outstream} 
        & open file for output\\
output         & {\tt outstream * string -> unit}   
        & write string to output stream\\
output1        & {\tt outstream * char -> unit}
        & write character to output stream\\
print   & {\tt string -> unit} 
        & write to standard output\\ 
stdErr       & {\tt outstream} 
        & standard error output stream\\
stdIn        & {\tt instream} 
        & standard input stream\\
stdOut       & {\tt outstream} 
        & standard output stream\\
\hline
\end{tabular}

\begin{itemize}
\item For a more detailed description, see file {\tt
    mosml/lib/TextIO.sig}, or type {\tt help "TextIO";}.  

\item For the corresponding structure {\tt BinIO} for binary
  (untranslated) input and output, see {\tt help "BinIO"}.

% \item On error, these functions will raise exception {\tt Io} with an
%   explanatory argument.
\end{itemize}


\subsection*{String manipulation functions (module {\tt String})}

\noindent\begin{tabular}{@{\tt\ \ }lll}\hline
{\it id\/}  &  type &     effect \\\hline

\verb#^# & {\tt string * string -> string} & concatenate strings\\

collate & {\tt (char*char->order)->string*string->order} & compare strings\\

compare & {\tt string * string -> order} & compare strings\\

concat    & {\tt string list -> string} & concatenate list of strings
\\

explode   & {\tt string -> char list} & character list from string\\

extract & {\tt string * int * int option -> string} & get substring or tail\\

fields    & {\tt (char -> bool) -> string -> string list} & find
(possibly empty) fields\\

fromCString & {\tt string -> string option} & parse C escape
sequences\\ 

fromString & {\tt string -> string option} & parse ML escape sequences\\

implode   & {\tt char list -> string} & string from character list\\

isPrefix  & {\tt string -> string -> bool} & prefix test\\

map       & {\tt (char -> char) -> string -> string} & map over characters\\

maxSize   & \verb#int# & maximal size of a string\\

size      & {\tt string -> int}
          & length of string\\

str       & {\tt char -> string} & make one-character string\\

sub       & {\tt string * int -> char}
          & $n$'th character (0-based)\\

substring & {\tt string * int * int -> string} & get substring
$(s, first, len)$\\

toCString  & {\tt string -> string} & make C escape sequences\\

toString  & {\tt string -> string} & make ML escape sequences\\

tokens    & {\tt (char -> bool) -> string -> string list} & find
(non-empty) tokens\\

translate & {\tt (char -> string) -> string -> string} & apply $f$ 
and concatenate\\\hline
\end{tabular}

\begin{itemize}
% \item Functions \verb#^#, {\tt concat}, {\tt implode}, and {\tt
%     translate} may raise exception {\tt Size}, and {\tt sub} and {\tt
%     substring} may raise {\tt Subscript}.

\item In addition, the overloaded comparison operators {\tt <}, {\tt
    <=}, {\tt >}, {\tt >=} work on strings.

\item For a more detailed description, see file {\tt
    mosml/lib/String.sig}, or type {\tt help "String";}.  
\end{itemize}


\newpage\subsection*{Vector manipulation functions (module {\tt Vector})}

Type {\tt 'a vector} is the type of one-dimensional, immutable,
zero-based constant time access vectors with elements of type {\tt
  'a}.  Type {\tt 'a vector} admits equality if {\tt 'a} does.

\vspace{1ex}

\noindent\begin{tabular}{@{\tt\ \ }lll}\hline
{\it id\/}  &  \makebox[8.5cm][l]{type} &     effect \\\hline

app         & {\tt ('a -> unit) -> 'a vector -> unit} 
        & apply $f$ left-right\\

appi        & \multicolumn{2}{l}
        {\tt (int * 'a -> unit) -> 'a vector * int * int option -> unit}\\ 

concat      & {\tt 'a vector list -> 'a vector} 
        & concatenate vectors\\

extract     & {\tt 'a vector * int * int option -> 'a vector}
        & extract a subvector or tail\\

foldl       & {\tt ('a * 'b -> 'b) -> 'b -> 'a vector -> 'b} 
        & fold $f$ left-right\\

foldli      & \multicolumn{2}{l}
        {\tt (int * 'a * 'b -> 'b) -> 'b -> 'a vector*int*int option -> 'b} \\

foldr       & {\tt ('a * 'b -> 'b) -> 'b -> 'a vector -> 'b} 
        & fold $f$ right-left\\

foldri      & \multicolumn{2}{l}
        {\tt (int * 'a * 'b -> 'b) -> 'b -> 'a vector*int*int option -> 'b} \\

fromList    & {\tt 'a list -> 'a vector}
        & make vector from the list\\

length      & {\tt 'a vector -> int}
        & length of the vector\\

maxLen      & {\tt int} 
        & maximal vector length\\

sub         & {\tt 'a vector * int -> 'a}
        & $n$'th element (0-based)\\

tabulate    & {\tt int * (int -> 'a) -> 'a vector}
        & vector of {\tt $f$(0),$\cdots$,$f$($n$-1)}\\\hline
\end{tabular}

\begin{itemize}
% \item Functions {\tt fromList}, {\tt tabulate}, and {\tt concat} may
%   raise exception {\tt Size}, and {\tt sub} and {\tt extract} may
%   raise {\tt Subscript}.

\item For a more detailed description, type {\tt help "Vector";} or
  see file {\tt mosml/lib/Vector.sig}.
\end{itemize}


\subsection*{Array manipulation functions (module {\tt Array})}

Type {\tt 'a array} is the type of one-dimensional, mutable,
zero-based constant time access arrays with elements of type {\tt 'a}.
Type {\tt 'a array} admits equality regardless whether {\tt 'a} does.

\vspace{1ex}

\noindent\begin{tabular}{@{\tt\ \ }lll}\hline
{\it id\/}  &  \makebox[8.5cm][l]{type} &     effect \\\hline
app         & {\tt ('a -> unit) -> 'a array -> unit} 
        & apply $f$ left-right\\

appi        & \multicolumn{2}{l}
        {\tt (int * 'a -> unit) -> 'a array * int * int option -> unit}\\

array       & \verb#int * 'a -> 'a array# 
        & create and initialize array\\

copy        & {\tt \{src :\ 'a array, si :\ int, len :\ int option,} 
            & copy subarray to subarray\\
            & {\tt \ dst :\ 'a array, di :\ int\} -> unit}\\

copyVec     & {\tt \{src :\ 'a vector, si :\ int, len :\ int option,}
            & copy subvector to subarray\\
            & {\tt \ dst :\ 'a array, di :\ int\} -> unit}\\

extract     & {\tt 'a array * int * int option -> 'a vector}  
        & extract subarray to vector\\

foldl       & {\tt ('a * 'b -> 'b) -> 'b -> 'a array -> 'b}
        & fold left-right\\

foldli      & \multicolumn{2}{l}
     {\tt (int * 'a * 'b -> 'b) -> 'b -> 'a array * int * int option -> 'b}\\

foldr       & {\tt ('a * 'b -> 'b) -> 'b -> 'a array -> 'b}
        & fold right-left\\

foldri      & \multicolumn{2}{l}
     {\tt (int * 'a * 'b -> 'b) -> 'b -> 'a array * int * int option -> 'b}\\

fromList & \verb#'a list -> 'a array#
        & make array from the list\\

length      & {\tt 'a array -> int}
        & length of the array\\

maxLen      & {\tt int} & maximal array length\\

modify      & {\tt ('a -> 'a) -> 'a array -> unit} 
        & apply $f$ and update\\

modifyi     & \multicolumn{2}{l}
        {\tt (int * 'a -> 'a) -> 'a array * int * int option -> unit} \\

sub         & {\tt 'a array * int -> 'a}
        & $n$'th element (0-based)\\

tabulate    & \verb#int * (int -> 'a) -> 'a array#
        & array of {\tt $f$(0),$\cdots$,$f$($n$-1)}\\

update      & {\tt 'a array * int * 'a -> unit} 
        & set $n$'th element (0-based)\\\hline
\end{tabular}

\begin{itemize}
% \item Functions {\tt array}, {\tt tabulate}, and {\tt fromList} may
%   raise exception {\tt Size}, and {\tt sub}, {\tt update}, {\tt
%     extract}, and {\tt copy} may raise {\tt Subscript}.

\item For a more detailed description, type {\tt help "Array";} or see
  file {\tt mosml/lib/Array.sig}.  The {\tt Array} module is loaded but
  not opened in the initial environment.
\end{itemize}


\subsection*{Character manipulation functions (module {\tt Char})}

\begin{tabular}{@{\tt\ \ }llll}\hline
{\it id\/}  & type &     effect & exception \\\hline

chr & {\tt int  -> char} & from character code to character & {\tt Chr}\\
compare & {\tt char * char -> order} & compare character codes \\
contains & {\tt string -> char -> bool} & contained in string\\
fromCString & {\tt string -> char option} & parse C escape sequence\\
fromString & {\tt string -> char option} & parse SML escape sequence\\
isAlpha    & {\tt char -> bool}   & alphabetic ASCII character \\
isAlphaNum & {\tt char -> bool}   & alphanumeric ASCII character\\
isAscii    & {\tt char -> bool}   & seven-bit ASCII character \\ 
isCntrl    & {\tt char -> bool}   & ASCII control character \\
isDigit    & {\tt char -> bool}   & decimal digit \\
isGraph    & {\tt char -> bool}   & printable and visible ASCII \\
isHexDigit & {\tt char -> bool}   & hexadecimal digit \\
isLower    & {\tt char -> bool}   & lower case alphabetic (ASCII) \\
isPrint    & {\tt char -> bool}   & printable ASCII (including space) \\
isPunct    & {\tt char -> bool}   & printable, but not space or alphanumeric \\
isSpace    & {\tt char -> bool}   & space and lay-out (HT, CR, LF, VT, FF) \\
isUpper    & {\tt char -> bool}   & upper case alphabetic (ASCII) \\
maxChar    & {\tt char} & last character (in {\tt <=} order)\\
maxOrd     & {\tt int} & largest character code\\
minChar    & {\tt char} & first character (in {\tt <=} order)\\
notContains & {\tt string -> char -> bool} & not in string\\
ord & {\tt char -> int} & from character to character code \\
pred & {\tt char -> char} & preceding character & {\tt Chr}\\
succ & {\tt char -> char} & succeding character & {\tt Chr}\\
toLower    & {\tt char -> char} & convert to lower case (ASCII) \\
toCString  & {\tt char -> string} & make C escape sequence \\
toString   & {\tt char -> string} & make SML escape sequence \\
toUpper    & {\tt char -> char} & convert to upper case (ASCII) \\\hline
\end{tabular}

\begin{itemize}
\item In addition, the overloaded comparison operators {\tt <}, {\tt
    <=}, {\tt >}, {\tt >=} work on the {\tt char} type.

\item For a more detailed description, type {\tt help "Char";} or see
  file {\tt mosml/lib/Char.sig}.  The {\tt Char} module is loaded and
  partially opened in the initial environment, making the functions
  {\tt chr} and {\tt ord} available.
\end{itemize}

%\newpage
%
%\section{Relation to Standard ML}
%
%Moscow ML has a simple module system, which deviates from the Standard
%ML Modules language as follows:
%
%\begin{itemize}
%\item There are no functors (and hence no sharing constraints), and no
%  nested structures.
% 
%\item Signatures may contain type abbreviations.  In a signature, no
%  type, value, or exception constructor may be specified twice at
%  top-level; a {\tt local} specification can be used only to restrict
%  the scope of {\tt open} specifications and type abbreviations; and
%  an {\tt open} specification can appear only inside {\tt local}.
%
%\item Signature constraints are opaque: only the information given in
%  the signature U.sig can be used when compiling another unit which
%  uses unit U.
%
%\item Each signature must reside in a separate file with suffix `{\tt
%    .sig}', and each structure must reside in a separate file with
%  suffix `{\tt .sml}'.
%\end{itemize}
%
\end{document}
