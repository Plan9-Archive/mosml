\newpage

\section*{Module AppleScript}
\index{AppleScript@\verb,AppleScript, (structure)|(}
\markboth{\MakeUppercase{AppleScript}}{\MakeUppercase{AppleScript}}
\addcontentsline{toc}{section}{AppleScript}
\begin{longprogram}
{\itshape{}AppleScript \verb"-"\verb"-" Apple MacOS scripting }

type OSAID\index{OSAID@\verb,OSAID,!type (\verb,AppleScript,)}
type OSAerr = int\index{OSAerr@\verb,OSAerr,!type (\verb,AppleScript,)}

exception AppleScriptErr of OSAerr * string\index{AppleScriptErr@\verb,AppleScriptErr,!exception (\verb,AppleScript,)}

val as_compile    : string \verb"-"\verb">" OSAID\index{as_compile@\verb,as_compile,!value (\verb,AppleScript,)}
val as_dispose    : OSAID \verb"-"\verb">" unit\index{as_dispose@\verb,as_dispose,!value (\verb,AppleScript,)}
val as_run_script : OSAID \verb"-"\verb">" string\index{as_run_script@\verb,as_run_script,!value (\verb,AppleScript,)}
val as_run_text   : string \verb"-"\verb">" string\index{as_run_text@\verb,as_run_text,!value (\verb,AppleScript,)}

\separatingline
   These Mac specific functions provide the capability to compile 
   and run AppleScript programs.

   The exception AppleScriptErr is raised in the event of an error.

   [as_compile str] compiles AppleScript source code text, returning\index{as_compile@\verb,as_compile,!value (\verb,AppleScript,)}
   an abstract token of type OSAID. This token may be used to run
   the script. The token may be used repeatedly until it is returned
   with as_dispose or until mosml exits.

   [as_dispose tok] disposes of the resources associated with the \index{as_dispose@\verb,as_dispose,!value (\verb,AppleScript,)}
   OSAID token so that they may be reused by the AppleScript system.
   AppleScriptErr is raised upon any attemp to reuse a disposed token.

   [as_run_script tok] runs the script associated with the token.\index{as_run_script@\verb,as_run_script,!value (\verb,AppleScript,)}
   This typically involves AppleEvent communication with other 
   programs running on the Mac, or networked Macs. The AppleScript
   result is returned as a string.

   [as_run_text str] compiles and runs the AppleScript source code text,\index{as_run_text@\verb,as_run_text,!value (\verb,AppleScript,)}
   disposing all resources allocated in the process, and returns the
   AppleScript result as a string.


   References:

   Inside Macintosh: Interapplication Communication, Chapter 10
   AppleScript Language Guide English Edition,
   available at http://applescript.apple.com/support.html
\end{longprogram}
\index{AppleScript@\verb,AppleScript, (structure)|)}\newpage

\section*{Module Array}
\index{Array@\verb,Array, (structure)|(}
\markboth{\MakeUppercase{Array}}{\MakeUppercase{Array}}
\addcontentsline{toc}{section}{Array}
\begin{longprogram}
{\itshape{}Array \verb"-"\verb"-" SML Basis Library }

prim_EQtype 'a array\index{array@\verb,array,!type (\verb,Array,)}

val maxLen   : int\index{maxLen@\verb,maxLen,!value (\verb,Array,)}

val array    : int * '_a \verb"-"\verb">" '_a array\index{array@\verb,array,!value (\verb,Array,)}
val tabulate : int * (int \verb"-"\verb">" '_a) \verb"-"\verb">" '_a array\index{tabulate@\verb,tabulate,!value (\verb,Array,)}
val fromList : '_a list \verb"-"\verb">" '_a array\index{fromList@\verb,fromList,!value (\verb,Array,)}

val length   : 'a array \verb"-"\verb">" int\index{length@\verb,length,!value (\verb,Array,)}
val sub      : 'a array * int \verb"-"\verb">" 'a\index{sub@\verb,sub,!value (\verb,Array,)}
val update   : 'a array * int * 'a  \verb"-"\verb">" unit\index{update@\verb,update,!value (\verb,Array,)}
val extract  : 'a array * int * int option \verb"-"\verb">" 'a Vector.vector\index{extract@\verb,extract,!value (\verb,Array,)}

val copy     : \verb"{"src: 'a array,  si: int, len: int option,\index{copy@\verb,copy,!value (\verb,Array,)}
                dst: 'a array, di: int\verb"}" \verb"-"\verb">" unit
val copyVec  : \verb"{"src: 'a vector, si: int, len: int option, \index{copyVec@\verb,copyVec,!value (\verb,Array,)}
                dst: 'a array, di: int\verb"}" \verb"-"\verb">" unit

val app      : ('a \verb"-"\verb">" unit) \verb"-"\verb">" 'a array \verb"-"\verb">" unit\index{app@\verb,app,!value (\verb,Array,)}
val foldl    : ('a * 'b \verb"-"\verb">" 'b) \verb"-"\verb">" 'b \verb"-"\verb">" 'a array \verb"-"\verb">" 'b\index{foldl@\verb,foldl,!value (\verb,Array,)}
val foldr    : ('a * 'b \verb"-"\verb">" 'b) \verb"-"\verb">" 'b \verb"-"\verb">" 'a array \verb"-"\verb">" 'b\index{foldr@\verb,foldr,!value (\verb,Array,)}
val modify   : ('a \verb"-"\verb">" 'a) \verb"-"\verb">" 'a array \verb"-"\verb">" unit\index{modify@\verb,modify,!value (\verb,Array,)}

val appi     : (int * 'a \verb"-"\verb">" unit) \verb"-"\verb">" 'a array * int * int option \verb"-"\verb">" unit\index{appi@\verb,appi,!value (\verb,Array,)}
val foldli   : (int * 'a * 'b \verb"-"\verb">" 'b) \verb"-"\verb">" 'b \verb"-"\verb">" 'a array * int * int option \verb"-"\verb">" 'b\index{foldli@\verb,foldli,!value (\verb,Array,)}
val foldri   : (int * 'a * 'b \verb"-"\verb">" 'b) \verb"-"\verb">" 'b \verb"-"\verb">" 'a array * int * int option \verb"-"\verb">" 'b\index{foldri@\verb,foldri,!value (\verb,Array,)}
val modifyi  : (int * 'a \verb"-"\verb">" 'a) \verb"-"\verb">" 'a array * int * int option \verb"-"\verb">" unit\index{modifyi@\verb,modifyi,!value (\verb,Array,)}

\separatingline
   ['ty array] is the type of one\verb"-"dimensional, mutable, zero\verb"-"based\index{array@\verb,array,!type (\verb,Array,)}
   constant\verb"-"time\verb"-"access arrays with elements of type 'ty.  Type 
   'ty array admits equality even if 'ty does not.  Arrays a1 and a2 
   are equal if both were created by the same call to a primitive
   (array, tabulate, fromList).

   Some functions work on a *slice* of an array:

   The slice (a, i, SOME n) denotes the subarray a[i..i+n\verb"-"1].  That is,
   a[i] is the first element of the slice, and n is the length of the
   slice.  Valid only if 0 \verb"<"= i \verb"<"= i+n \verb"<"= length a.

   The slice (a, i, NONE) denotes the subarray a[i..length a\verb"-"1].  That
   is, the slice denotes the suffix of the array starting at i.  Valid
   only if 0 \verb"<"= i \verb"<"= length a.  Equivalent to (a, i, SOME(length a \verb"-" i)).

       slice             meaning 
       \verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"
       (a, 0, NONE)      the whole array              a[0..len\verb"-"1]   
       (a, 0, SOME n)    a left subarray (prefix)     a[0..n\verb"-"1]
       (a, i, NONE)      a right subarray (suffix)    a[i..len\verb"-"1]
       (a, i, SOME n)    a general slice              a[i..i+n\verb"-"1] 

   [maxLen] is the maximal number of elements in an array.\index{maxLen@\verb,maxLen,!value (\verb,Array,)}

   [array(n, x)] returns a new array of length n whose elements are all x.\index{array@\verb,array,!value (\verb,Array,)}
   Raises Size if n\verb"<"0 or n\verb">"maxLen.

   [tabulate(n, f)] returns a new array of length n whose elements\index{tabulate@\verb,tabulate,!value (\verb,Array,)}
   are f 0, f 1, ..., f (n\verb"-"1), created from left to right.  Raises
   Size if n\verb"<"0 or n\verb">"maxLen.

   [fromList xs] returns an array whose elements are those of xs.\index{fromList@\verb,fromList,!value (\verb,Array,)}
   Raises Size if length xs \verb">" maxLen.

   [length a] returns the number of elements in a.\index{length@\verb,length,!value (\verb,Array,)}

   [sub(a, i)] returns the i'th element of a, counting from 0.  \index{sub@\verb,sub,!value (\verb,Array,)}
   Raises Subscript if i\verb"<"0 or i\verb">"=length a.  To make `sub' infix, use
   the declaration 
                             infix 9 sub

   [update(a, i, x)] destructively replaces the i'th element of a by x.\index{update@\verb,update,!value (\verb,Array,)}
   Raises Subscript if i\verb"<"0 or i\verb">"=length a.

   [extract(a, i, NONE)] returns a vector of the elements a[i..length a\verb"-"1] \index{extract@\verb,extract,!value (\verb,Array,)}
   of a.  Raises Subscript if i\verb"<"0 or i\verb">"length a.

   [extract(a, i, SOME len)] returns a vector of the elements a[i..i+len\verb"-"1] \index{extract@\verb,extract,!value (\verb,Array,)}
   of a.  Raises Subscript if i\verb"<"0 or len\verb"<"0 or i+len\verb">"length a or
   len\verb">"Vector.maxLen.

   [copy\verb"{"src, si, len, dst, di\verb"}"] destructively copies the slice\index{copy@\verb,copy,!value (\verb,Array,)}
   (src, si, len) to dst, starting at index di.  More precisely:
   If len=NONE and n=length src, it copies src[si..n\verb"-"1] to dst[di..di+n\verb"-"si].
   If len=SOME k, it copies src[si..si+k\verb"-"1] to dst[di..di+k\verb"-"1].  
   Works also if src and dst are the same and the segments overlap.
   Raises Subscript if si \verb"<" 0 or di \verb"<" 0, 
   or if len=NONE and di + length src \verb"-" si \verb">" length dst,
   or if len=SOME k and k \verb"<" 0 or si + k \verb">" length src or di + k \verb">" length dst.

   [copyVec\verb"{"src, si, len, dst, di\verb"}"] destructively copies the slice\index{copyVec@\verb,copyVec,!value (\verb,Array,)}
   (src, si, len) to dst, starting at index di.  More precisely:
   If len=NONE and n=length src, it copies src[si..n\verb"-"1] to dst[di..di+n\verb"-"si].
   If len=SOME k, it copies src[si..si+k\verb"-"1] to dst[di..di+k\verb"-"1].  
   Works also if src and dst are the same and the segments overlap.
   Raises Subscript if si \verb"<" 0 or di \verb"<" 0, 
   or if len=NONE and di + length src \verb"-" si \verb">" length dst,
   or if len=SOME k and k \verb"<" 0 or si + k \verb">" length src or di + k \verb">" length dst.

   [foldl f e a] folds function f over a from left to right.  That is,\index{foldl@\verb,foldl,!value (\verb,Array,)}
   computes f(a[len\verb"-"1], f(a[len\verb"-"2], ..., f(a[1], f(a[0], e)) ...)),
   where len is the length of a.

   [foldr f e a] folds function f over a from right to left.  That is,\index{foldr@\verb,foldr,!value (\verb,Array,)}
   computes f(a[0], f(a[1], ..., f(a[len\verb"-"2], f(a[len\verb"-"1], e)) ...)),
   where len is the length of a.

   [app f a] applies f to a[j] for j=0,1,...,length a\verb"-"1.\index{app@\verb,app,!value (\verb,Array,)}

   [modify f a] applies f to a[j] and updates a[j] with the result\index{modify@\verb,modify,!value (\verb,Array,)}
   f(a[j]) for j=0,1,...,length a\verb"-"1. 

   The following iterators generalize the above ones in two ways:

    . the index j is also being passed to the function being iterated;
    . the iterators work on a slice (subarray) of an array.

   [foldli f e (a, i, SOME n)] folds function f over the subarray\index{foldli@\verb,foldli,!value (\verb,Array,)}
   a[i..i+n\verb"-"1] from left to right.  That is, computes 
   f(i+n\verb"-"1, a[i+n\verb"-"1], f(..., f(i+1, a[i+1], f(i, a[i], e)) ...)).  
   Raises Subscript if i\verb"<"0 or n\verb"<"0 or i+n \verb">" length a.

   [foldli f e (a, i, NONE)] folds function f over the subarray\index{foldli@\verb,foldli,!value (\verb,Array,)}
   a[i..len\verb"-"1] from left to right, where len =  length a.  That is, 
   computes f(len\verb"-"1, a[len\verb"-"1], f(..., f(i+1, a[i+1], f(i, a[i], e)) ...)).  
   Raises Subscript if i\verb"<"0 or i \verb">" length a.

   [foldri f e (a, i, SOME n)] folds function f over the subarray\index{foldri@\verb,foldri,!value (\verb,Array,)}
   a[i..i+n\verb"-"1] from right to left.  That is, computes 
   f(i, a[i], f(i+1, a[i+1], ..., f(i+n\verb"-"1, a[i+n\verb"-"1], e) ...)).
   Raises Subscript if i\verb"<"0 or n\verb"<"0 or i+n \verb">" length a.

   [foldri f e (a, i, NONE)] folds function f over the subarray\index{foldri@\verb,foldri,!value (\verb,Array,)}
   a[i..len\verb"-"1] from right to left, where len = length a.  That is, 
   computes f(i, a[i], f(i+1, a[i+1], ..., f(len\verb"-"1, a[len\verb"-"1], e) ...)).
   Raises Subscript if i\verb"<"0 or i \verb">" length a.

   [appi f (a, i, SOME n)] applies f to successive pairs (j, a[j]) for\index{appi@\verb,appi,!value (\verb,Array,)}
   j=i,i+1,...,i+n\verb"-"1.  Raises Subscript if i\verb"<"0 or n\verb"<"0 or i+n \verb">" length a.

   [appi f (a, i, NONE)] applies f to successive pairs (j, a[j]) for\index{appi@\verb,appi,!value (\verb,Array,)}
   j=i,i+1,...,len\verb"-"1, where len = length a.  Raises Subscript if i\verb"<"0
   or i \verb">" length a.

   [modifyi f (a, i, SOME n)] applies f to (j, a[j]) and updates a[j]\index{modifyi@\verb,modifyi,!value (\verb,Array,)}
   with the result f(j, a[j]) for j=i,i+1,...,i+n\verb"-"1.  Raises Subscript
   if i\verb"<"0 or n\verb"<"0 or i+n \verb">" length a.

   [modifyi f (a, i, NONE)] applies f to (j, a[j]) and updates a[j]\index{modifyi@\verb,modifyi,!value (\verb,Array,)}
   with the result f(j, a[j]) for j=i,i+1,...,len\verb"-"1.  Raises Subscript
   if i\verb"<"0 or i \verb">" length a.
\end{longprogram}
\index{Array@\verb,Array, (structure)|)}\newpage

\section*{Module Array2}
\index{Array2@\verb,Array2, (structure)|(}
\markboth{\MakeUppercase{Array2}}{\MakeUppercase{Array2}}
\addcontentsline{toc}{section}{Array2}
\begin{longprogram}
{\itshape{}Array2 \verb"-"\verb"-" SML Basis Library }

eqtype 'a array\index{array@\verb,array,!type (\verb,Array2,)}

datatype traversal = RowMajor | ColMajor\index{traversal@\verb,traversal,!type (\verb,Array2,)}

val array      : int * int * '_a \verb"-"\verb">" '_a array\index{array@\verb,array,!value (\verb,Array2,)}
val fromList   : '_a list list \verb"-"\verb">" '_a array\index{fromList@\verb,fromList,!value (\verb,Array2,)}
val tabulate   : traversal \verb"-"\verb">" int * int * (int * int \verb"-"\verb">" '_a) \verb"-"\verb">" '_a array\index{tabulate@\verb,tabulate,!value (\verb,Array2,)}

val dimensions : 'a array \verb"-"\verb">" int * int\index{dimensions@\verb,dimensions,!value (\verb,Array2,)}
val nCols      : 'a array \verb"-"\verb">" int\index{nCols@\verb,nCols,!value (\verb,Array2,)}
val nRows      : 'a array \verb"-"\verb">" int\index{nRows@\verb,nRows,!value (\verb,Array2,)}

val sub        : 'a array * int * int \verb"-"\verb">" 'a\index{sub@\verb,sub,!value (\verb,Array2,)}
val update     : 'a array * int * int * 'a \verb"-"\verb">" unit\index{update@\verb,update,!value (\verb,Array2,)}

val row        : 'a array * int \verb"-"\verb">" 'a Vector.vector\index{row@\verb,row,!value (\verb,Array2,)}
val column     : 'a array * int \verb"-"\verb">" 'a Vector.vector\index{column@\verb,column,!value (\verb,Array2,)}

type 'a region = \verb"{" base : 'a array, row : int, col : int, \index{region@\verb,region,!type (\verb,Array2,)}
                   nrows : int option, ncols : int option\verb"}"

val copy       : \verb"{" src : 'a region, dst : 'a array, \index{copy@\verb,copy,!value (\verb,Array2,)}
                   dst_row : int, dst_col : int \verb"}" \verb"-"\verb">" unit

val app        : traversal \verb"-"\verb">" ('a \verb"-"\verb">" unit) \verb"-"\verb">" 'a array \verb"-"\verb">" unit\index{app@\verb,app,!value (\verb,Array2,)}
val modify     : traversal \verb"-"\verb">" ('a \verb"-"\verb">" 'a) \verb"-"\verb">" 'a array \verb"-"\verb">" unit\index{modify@\verb,modify,!value (\verb,Array2,)}
val fold       : traversal \verb"-"\verb">" ('a * 'b \verb"-"\verb">" 'b) \verb"-"\verb">" 'b \verb"-"\verb">" 'a array \verb"-"\verb">" 'b\index{fold@\verb,fold,!value (\verb,Array2,)}

val appi       : traversal \verb"-"\verb">" (int * int * 'a \verb"-"\verb">" unit) \verb"-"\verb">" 'a region \verb"-"\verb">" unit\index{appi@\verb,appi,!value (\verb,Array2,)}
val modifyi    : traversal \verb"-"\verb">" (int * int * 'a \verb"-"\verb">" 'a) \verb"-"\verb">" 'a region \verb"-"\verb">" unit\index{modifyi@\verb,modifyi,!value (\verb,Array2,)}
val foldi      : traversal \verb"-"\verb">" (int * int * 'a * 'b \verb"-"\verb">" 'b) \verb"-"\verb">" 'b \index{foldi@\verb,foldi,!value (\verb,Array2,)}
                 \verb"-"\verb">" 'a region \verb"-"\verb">" 'b

\separatingline
   ['ty array] is the type of two\verb"-"dimensional, mutable, zero\verb"-"based\index{array@\verb,array,!type (\verb,Array2,)}
   constant\verb"-"time\verb"-"access arrays with elements of type 'ty.  
   Type 'ty array admits equality even if 'ty does not.  Arrays a1 and a2 
   are equal if both were created by the same call to one of the
   primitives array, fromList, and tabulate.

   [traversal] is the type of traversal orders: row major or column major.\index{traversal@\verb,traversal,!type (\verb,Array2,)}

   [RowMajor] specifies that an operation must be done in row\verb"-"major\index{RowMajor@\verb,RowMajor,!constructor (\verb,Array2,)}
   order, that is, one row at a time, from top to bottom, and from
   left to right within each row.  Row\verb"-"major traversal visits the
   elements of an (m,n)\verb"-"array with m rows and n columns in this 
   order:
            (0,0), (0,1), (0,2), ..., (0,n\verb"-"1), 
            (1,0), (1,1), (1,2), ..., (1,n\verb"-"1), 
                    ...
   that is, in order of lexicographically increasing (i, j).  In
   Moscow ML, row\verb"-"major traversal is usually faster than column\verb"-"major
   traversal.

   [ColMajor] specifies that an operation must be done in column\verb"-"major\index{ColMajor@\verb,ColMajor,!constructor (\verb,Array2,)}
   order, that is, one column at a time, from left to right, and from
   top to bottom within each column.  Column\verb"-"major traversal visits
   the elements of an (m,n)\verb"-"array with m rows and n columns in this
   order:
            (0,0), (1,0), (2,0), ..., (m\verb"-"1,0), 
            (0,1), (1,1), (2,1), ..., (m\verb"-"1,1), 
                    ...
   that is, in order of lexicographically increasing (j, i).  

   [array(m, n, x)] returns a new m * n matrix whose elements are all x.  \index{array@\verb,array,!value (\verb,Array2,)}
   Raises Size if n\verb"<"0 or m\verb"<"0.

   [fromList xss] returns a new array whose first row has elements\index{fromList@\verb,fromList,!value (\verb,Array2,)}
   xs1, second row has elements xs2, ..., where xss = [xs1,xs2,...,xsm].  
   Raises Size if the lists in xss do not all have the same length.

   [tabulate RowMajor (m, n, f)] returns a new m\verb"-"by\verb"-"n array whose \index{tabulate@\verb,tabulate,!value (\verb,Array2,)}
   elements are f(0,0), f(0,1), ..., f(0, n\verb"-"1), 
                f(1,0), f(1,1), ..., f(1, n\verb"-"1),
                    ...
                f(m\verb"-"1,0),    ...,    f(m\verb"-"1, n\verb"-"1)
   created in row\verb"-"major order: f(0,0), f(0,1), ..., f(1,0), f(1,1), ...
   Raises Size if n\verb"<"0 or m\verb"<"0.

   [tabulate ColMajor (m, n, f)] returns a new m\verb"-"by\verb"-"n array whose \index{tabulate@\verb,tabulate,!value (\verb,Array2,)}
   elements are as above, but created in the column\verb"-"major order:
   f(0,0), f(1,0), ..., f(0, 1), f(1, 1), ...  Raises Size if n\verb"<"0 or m\verb"<"0.

   [dimensions a] returns the dimensions (m, n) of a, where m is the\index{dimensions@\verb,dimensions,!value (\verb,Array2,)}
   number of rows and n the number of columns.

   [nCols a] returns the number of n of columns of a.\index{nCols@\verb,nCols,!value (\verb,Array2,)}

   [nRows a] returns the number of m of rows of a.\index{nRows@\verb,nRows,!value (\verb,Array2,)}

   [sub(a, i, j)] returns the i'th row's j'th element, counting from 0.\index{sub@\verb,sub,!value (\verb,Array2,)}
   Raises Subscript if i\verb"<"0 or j\verb"<"0 or i\verb">"=m or j\verb">"=n 
   where (m,n) = dimensions a.

   [update(a, i, j, x)] destructively replaces the (i,j)'th element of a \index{update@\verb,update,!value (\verb,Array2,)}
   by x. Raises Subscript if i\verb"<"0 or j\verb"<"0 or i\verb">"=m or j\verb">"=n 
   where (m,n) = dimensions a. 

   [row (a, i)] returns a vector containing the elements of the ith\index{row@\verb,row,!value (\verb,Array2,)}
   row of a.  Raises Subscript if i \verb"<" 0 or i \verb">"= height a.

   [column (a, j)] returns a vector containing the elements of the jth\index{column@\verb,column,!value (\verb,Array2,)}
   column of a.  Raises Subscript if j \verb"<" 0 or j \verb">"= width a.

   [app RowMajor f a] applies f to the elements a[0,0], a[0,1], ...,\index{app@\verb,app,!value (\verb,Array2,)}
   a[0,n\verb"-"1], a[1,0], ..., a[m\verb"-"1, n\verb"-"1] of a, where (m, n) = dimensions a.

   [app ColMajor f a] applies f to the elements a[0,0], a[1,0], ...,\index{app@\verb,app,!value (\verb,Array2,)}
   a[n\verb"-"1,0], a[0,1], a[1,1], ..., a[m\verb"-"1, n\verb"-"1] of a, where (m, n) =
   dimensions a.

   [modify RowMajor f a] applies f to the elements a[0,0], a[0,1],\index{modify@\verb,modify,!value (\verb,Array2,)}
   ..., a[0,n\verb"-"1], a[1,0], ..., a[m\verb"-"1, n\verb"-"1] of a, updating each element
   with the result of the application, where (m, n) = dimensions a.

   [modify ColMajor f a] applies f to the elements a[0,0], a[1,0],\index{modify@\verb,modify,!value (\verb,Array2,)}
   ..., a[n\verb"-"1,0], a[0,1], a[1,1], ..., a[m\verb"-"1, n\verb"-"1] of a, updating each
   element with the result of the application, where (m, n) =
   dimensions a.

   [fold RowMajor f b a] folds f left\verb"-"right and top\verb"-"down over the\index{fold@\verb,fold,!value (\verb,Array2,)}
   elements of a in row\verb"-"major order.  That is, computes
        f(a[m\verb"-"1, n\verb"-"1], f(a[m\verb"-"1, n\verb"-"2], ..., f(a[0,1], f(a[0,0], b)) ...))
   where (m, n) = dimensions a.

   [fold ColMajor f b a] folds f left\verb"-"right and top\verb"-"down over the\index{fold@\verb,fold,!value (\verb,Array2,)}
   elements of a in column\verb"-"major order.  That is, computes
        f(a[m\verb"-"1, n\verb"-"1], f(a[m\verb"-"2, n\verb"-"1], ..., f(a[1,0], f(a[0,0], b)) ...))
   where (m, n) = dimensions a.


   The following iterators generalize the above ones in two ways:

     * the indexes i and j are also being passed to the function;
     * the iterators work on a region (submatrix) of a matrix.          

   [region] is the type of records \verb"{" base, row, col, nrows, ncols \verb"}"\index{region@\verb,region,!type (\verb,Array2,)}
   determining the region or submatrix of array base whose upper left
   corner has index (row, col).

   If nrows = SOME r, then the region has r rows: row, row+1, ..., row+r\verb"-"1.
   If nrows = NONE, then the region extends to the bottom of the matrix.
   The field ncols similarly determines the number of columns.

   A region is valid for an array with dimensions (m, n) if 
       (1) either nrows = NONE and 0 \verb"<"= row \verb"<"= m 
           or nrows = SOME r and 0 \verb"<"= row \verb"<"= row + r \verb"<"= m 
   and (2) either ncols = NONE and 0 \verb"<"= col \verb"<"= n
           or ncols = SOME c and 0 \verb"<"= col \verb"<"= col + c \verb"<"= n.

   [appi RowMajor f reg] applies f to (i, j, a[i, j]) in order of\index{appi@\verb,appi,!value (\verb,Array2,)}
   lexicographically increasing (i, j) within the region reg.  Raises
   Subscript if reg is not valid.  Note that app tr f a is equivalent
   to appi tr (f o #3) \verb"{"base=a, row=0, col=0, nrows=NONE, ncols=NONE\verb"}"

   [appi ColMajor f reg] applies f to (i, j, a[i, j]) in order of\index{appi@\verb,appi,!value (\verb,Array2,)}
   lexicographically increasing (j, i) within the region reg.  Raises
   Subscript if reg is not valid.  

   [modifyi RowMajor f reg)] applies f to (i, j, a[i, j]) in order of\index{modifyi@\verb,modifyi,!value (\verb,Array2,)}
   lexicographically increasing (i, j) within the region reg.  Raises
   Subscript if reg is not valid.  Note that modify tr f a is equivalent 
   to modifyi (f o #3) \verb"{"base=a, row=0, col=0, nrows=NONE, ncols=NONE\verb"}").

   [modifyi ColMajor f reg)] applies f to (i, j, a[i, j]) in order of\index{modifyi@\verb,modifyi,!value (\verb,Array2,)}
   lexicographically increasing (j, i) within the region reg.  Raises
   Subscript if reg is not valid.  

   [foldi RowMajor f b a] folds f over (i, j, a[i, j]) in row\verb"-"major\index{foldi@\verb,foldi,!value (\verb,Array2,)}
   order within the region reg, that is, for lexicographically
   increasing (i, j) in the region.  Raises Subscript if reg is not
   valid.

   [foldi ColMajor f b a] folds f over (i, j, a[i, j]) in column\verb"-"major\index{foldi@\verb,foldi,!value (\verb,Array2,)}
   order within the region reg, that is, for lexicographically
   increasing (j, i) in the region.  Raises Subscript if reg is not
   valid.

   [copy \verb"{" src, dst, dst_row, dst_col \verb"}"] copies the region determined\index{copy@\verb,copy,!value (\verb,Array2,)}
   by src to array dst such that the upper leftmost corner of src is
   copied to dst[dst_row, dst_col].  Works correctly even when src and
   dst are the same and the source and destination regions overlap.
   Raises Subscript if the src region is invalid, or if src translated
   to (dst_row, dst_col) is invalid for dst.
\end{longprogram}
\index{Array2@\verb,Array2, (structure)|)}\newpage

\section*{Module Arraysort}
\index{Arraysort@\verb,Arraysort, (structure)|(}
\markboth{\MakeUppercase{Arraysort}}{\MakeUppercase{Arraysort}}
\addcontentsline{toc}{section}{Arraysort}
\begin{longprogram}
{\itshape{}Arraysort \verb"-"\verb"-" Quicksort for arrays, from SML/NJ library }

val sort   : ('a * 'a \verb"-"\verb">" order) \verb"-"\verb">" 'a Array.array \verb"-"\verb">" unit\index{sort@\verb,sort,!value (\verb,Arraysort,)}
val sorted : ('a * 'a \verb"-"\verb">" order) \verb"-"\verb">" 'a Array.array \verb"-"\verb">" bool\index{sorted@\verb,sorted,!value (\verb,Arraysort,)}

\separatingline
   [sort ordr arr] sorts array arr in\verb"-"place, using ordering relation ordr.\index{sort@\verb,sort,!value (\verb,Arraysort,)}

   [sorted ordr arr] returns true if the elements of array arr is\index{sorted@\verb,sorted,!value (\verb,Arraysort,)}
   appear in (weakly) increasing order, according to ordering ordr.
\end{longprogram}
\index{Arraysort@\verb,Arraysort, (structure)|)}\newpage

\section*{Module BinIO}
\index{BinIO@\verb,BinIO, (structure)|(}
\markboth{\MakeUppercase{BinIO}}{\MakeUppercase{BinIO}}
\addcontentsline{toc}{section}{BinIO}
\begin{longprogram}
{\itshape{}BinIO \verb"-"\verb"-" SML Basis Library }

type elem   = Word8.word\index{elem@\verb,elem,!type (\verb,BinIO,)}
type vector = Word8Vector.vector\index{vector@\verb,vector,!type (\verb,BinIO,)}

{\itshape{}Binary input }

type instream \index{instream@\verb,instream,!type (\verb,BinIO,)}

val openIn       : string \verb"-"\verb">" instream\index{openIn@\verb,openIn,!value (\verb,BinIO,)}
val closeIn      : instream \verb"-"\verb">" unit\index{closeIn@\verb,closeIn,!value (\verb,BinIO,)}
val input        : instream \verb"-"\verb">" vector\index{input@\verb,input,!value (\verb,BinIO,)}
val inputAll     : instream \verb"-"\verb">" vector\index{inputAll@\verb,inputAll,!value (\verb,BinIO,)}
val inputNoBlock : instream \verb"-"\verb">" vector option\index{inputNoBlock@\verb,inputNoBlock,!value (\verb,BinIO,)}
val input1       : instream \verb"-"\verb">" elem option\index{input1@\verb,input1,!value (\verb,BinIO,)}
val inputN       : instream * int \verb"-"\verb">" vector\index{inputN@\verb,inputN,!value (\verb,BinIO,)}
val endOfStream  : instream \verb"-"\verb">" bool\index{endOfStream@\verb,endOfStream,!value (\verb,BinIO,)}
val lookahead    : instream \verb"-"\verb">" elem option\index{lookahead@\verb,lookahead,!value (\verb,BinIO,)}

{\itshape{}Binary output }

type outstream\index{outstream@\verb,outstream,!type (\verb,BinIO,)}

val openOut      : string \verb"-"\verb">" outstream\index{openOut@\verb,openOut,!value (\verb,BinIO,)}
val openAppend   : string \verb"-"\verb">" outstream\index{openAppend@\verb,openAppend,!value (\verb,BinIO,)}
val closeOut     : outstream \verb"-"\verb">" unit\index{closeOut@\verb,closeOut,!value (\verb,BinIO,)}
val output       : outstream * vector \verb"-"\verb">" unit\index{output@\verb,output,!value (\verb,BinIO,)}
val output1      : outstream * elem \verb"-"\verb">" unit\index{output1@\verb,output1,!value (\verb,BinIO,)}
val flushOut     : outstream \verb"-"\verb">" unit\index{flushOut@\verb,flushOut,!value (\verb,BinIO,)}

\separatingline
   This structure provides input/output functions on byte streams.
   The functions are state\verb"-"based: reading from or writing to a stream
   changes the state of the stream.  The streams are buffered: output
   to a stream may not immediately affect the underlying file or
   device.

   [instream] is the type of state\verb"-"based byte input streams.\index{instream@\verb,instream,!type (\verb,BinIO,)}

   [outstream] is the type of state\verb"-"based byte output streams.\index{outstream@\verb,outstream,!type (\verb,BinIO,)}

   [elem] is the type Word8.word of bytes.\index{elem@\verb,elem,!type (\verb,BinIO,)}

   [vector] is the type of Word8Vector.vector (byte vectors).\index{vector@\verb,vector,!type (\verb,BinIO,)}


   BYTE INPUT:

   [openIn s] creates a new instream associated with the file named s.\index{openIn@\verb,openIn,!value (\verb,BinIO,)}
   Raises Io.Io is file s does not exist or is not accessible.

   [closeIn istr] closes stream istr.  Has no effect if istr is closed\index{closeIn@\verb,closeIn,!value (\verb,BinIO,)}
   already.  Further operations on istr will behave as if istr is at
   end of stream (that is, will return "" or NONE or true).

   [input istr] reads some elements from istr, returning a vector v of\index{input@\verb,input,!value (\verb,BinIO,)}
   those elements.  The vector will be empty (size v = 0) if and only
   if istr is at end of stream or is closed.  May block (not return
   until data are available in the external world).

   [inputAll istr] reads and returns the vector v of all bytes\index{inputAll@\verb,inputAll,!value (\verb,BinIO,)}
   remaining in istr up to end of stream.

   [inputNoBlock istr] returns SOME(v) if some elements v can be read\index{inputNoBlock@\verb,inputNoBlock,!value (\verb,BinIO,)}
   without blocking; returns SOME("") if it can be determined without
   blocking that istr is at end of stream; returns NONE otherwise.  If
   istr does not support non\verb"-"blocking input, raises
   Io.NonblockingNotSupported.

   [input1 istr] returns SOME(e) if at least one element e of istr is\index{input1@\verb,input1,!value (\verb,BinIO,)}
   available; returns NONE if istr is at end of stream or is closed;
   blocks if necessary until one of these conditions holds.

   [inputN(istr, n)] returns the next n bytes from istr as a vector,\index{inputN@\verb,inputN,!value (\verb,BinIO,)}
   if that many are available; returns all remaining bytes if end of
   stream is reached before n bytes are available; blocks if necessary
   until one of these conditions holds.  

   [endOfStream istr] returns false if any elements are available in\index{endOfStream@\verb,endOfStream,!value (\verb,BinIO,)}
   istr; returns true if istr is at end of stream or closed; blocks if
   necessary until one of these conditions holds.

   [lookahead istr] returns SOME(e) where e is the next element in the\index{lookahead@\verb,lookahead,!value (\verb,BinIO,)}
   stream; returns NONE if istr is at end of stream or is closed;
   blocks if necessary until one of these conditions holds.  Does not
   advance the stream.


   BYTE OUTPUT:

   [openOut s] creates a new outstream associated with the file named\index{openOut@\verb,openOut,!value (\verb,BinIO,)}
   s.  If file s does not exist, and the directory exists and is
   writable, then a new file is created.  If file s exists, it is
   truncated (any existing contents are lost).

   [openAppend s] creates a new outstream associated with the file\index{openAppend@\verb,openAppend,!value (\verb,BinIO,)}
   named s.  If file s does not exist, and the directory exists and is
   writable, then a new file is created.  If file s exists, any
   existing contents are retained, and output goes at the end of the
   file.

   [closeOut ostr] closes stream ostr; further operations on ostr\index{closeOut@\verb,closeOut,!value (\verb,BinIO,)}
   (except for additional close operations) will raise exception Io.Io.

   [output(ostr, v)] writes the byte vector v on outstream ostr.\index{output@\verb,output,!value (\verb,BinIO,)}

   [output1(ostr, e)] writes the byte e on outstream ostr.\index{output1@\verb,output1,!value (\verb,BinIO,)}

   [flushOut ostr] flushes the outstream ostr, so that all data\index{flushOut@\verb,flushOut,!value (\verb,BinIO,)}
   written to ostr becomes available to the underlying file or device.


   The functions below are not yet implemented:

   [setPosIn(istr, i)] sets istr to the position i.  Raises Io.Io if
   not supported on istr.

   [getPosIn istr] returns the current position of istr.  Raises Io.Io
   if not supported on istr.

   [endPosIn istr] returns the last position of istr.  

   [getPosOut ostr] returns the current position in stream ostr.
   Raises Io.Io if not supported on ostr.

   [endPosOut ostr] returns the ending position in stream ostr.
   Raises Io.Io if not supported on ostr.

   [setPosOut(ostr, i)] sets the current position in stream to ostr to
   i.  Raises Io.Io if not supported on ostr.

   [mkInstream sistr] creates a state\verb"-"based instream from the
   functional instream sistr.

   [getInstream istr] returns the functional instream underlying the
   state\verb"-"based instream istr.

   [setInstream(istr, sistr)] redirects istr, so that subsequent input
   is taken from the functional instream sistr.

   [mkOutstream sostr] creates a state\verb"-"based outstream from the
   outstream sostr.

   [getOutstream ostr] returns the outstream underlying the
   state\verb"-"based outstream ostr.

   [setOutstream(ostr, sostr)] redirects the outstream ostr so that
   subsequent output goes to sostr.
\end{longprogram}
\index{BinIO@\verb,BinIO, (structure)|)}\newpage

\section*{Module Binarymap}
\index{Binarymap@\verb,Binarymap, (structure)|(}
\markboth{\MakeUppercase{Binarymap}}{\MakeUppercase{Binarymap}}
\addcontentsline{toc}{section}{Binarymap}
\begin{longprogram}
{\itshape{}Binarymap \verb"-"\verb"-" applicative maps as balanced ordered binary trees }
{\itshape{}From SML/NJ lib 0.2, copyright 1993 by AT\&T Bell Laboratories  }
{\itshape{}Original implementation due to Stephen Adams, Southampton, UK  }

type ('key, 'a) dict\index{dict@\verb,dict,!type (\verb,Binarymap,)}

exception NotFound\index{NotFound@\verb,NotFound,!exception (\verb,Binarymap,)}

val mkDict    : ('key * 'key \verb"-"\verb">" order) \verb"-"\verb">" ('key, 'a) dict\index{mkDict@\verb,mkDict,!value (\verb,Binarymap,)}
val insert    : ('key, 'a) dict * 'key * 'a \verb"-"\verb">" ('key, 'a) dict\index{insert@\verb,insert,!value (\verb,Binarymap,)}
val find      : ('key, 'a) dict * 'key \verb"-"\verb">" 'a\index{find@\verb,find,!value (\verb,Binarymap,)}
val peek      : ('key, 'a) dict * 'key \verb"-"\verb">" 'a option\index{peek@\verb,peek,!value (\verb,Binarymap,)}
val remove    : ('key, 'a) dict * 'key \verb"-"\verb">" ('key, 'a) dict * 'a\index{remove@\verb,remove,!value (\verb,Binarymap,)}
val numItems  : ('key, 'a) dict \verb"-"\verb">" int\index{numItems@\verb,numItems,!value (\verb,Binarymap,)}
val listItems : ('key, 'a) dict \verb"-"\verb">" ('key * 'a) list\index{listItems@\verb,listItems,!value (\verb,Binarymap,)}
val app       : ('key * 'a \verb"-"\verb">" unit) \verb"-"\verb">" ('key,'a) dict \verb"-"\verb">" unit\index{app@\verb,app,!value (\verb,Binarymap,)}
val revapp    : ('key * 'a \verb"-"\verb">" unit) \verb"-"\verb">" ('key,'a) dict \verb"-"\verb">" unit\index{revapp@\verb,revapp,!value (\verb,Binarymap,)}
val foldr     : ('key * 'a * 'b \verb"-"\verb">" 'b)\verb"-"\verb">" 'b \verb"-"\verb">" ('key,'a) dict \verb"-"\verb">" 'b\index{foldr@\verb,foldr,!value (\verb,Binarymap,)}
val foldl     : ('key * 'a * 'b \verb"-"\verb">" 'b) \verb"-"\verb">" 'b \verb"-"\verb">" ('key,'a) dict \verb"-"\verb">" 'b\index{foldl@\verb,foldl,!value (\verb,Binarymap,)}
val map       : ('key * 'a \verb"-"\verb">" 'b) \verb"-"\verb">" ('key,'a) dict \verb"-"\verb">" ('key, 'b) dict\index{map@\verb,map,!value (\verb,Binarymap,)}
val transform : ('a \verb"-"\verb">" 'b) \verb"-"\verb">" ('key,'a) dict \verb"-"\verb">" ('key, 'b) dict\index{transform@\verb,transform,!value (\verb,Binarymap,)}

\separatingline
   [('key, 'a) dict] is the type of applicative maps from domain type\index{dict@\verb,dict,!type (\verb,Binarymap,)}
   'key to range type 'a, or equivalently, applicative dictionaries
   with keys of type 'key and values of type 'a.  They are implemented
   as ordered balanced binary trees.

   [mkDict ordr] returns a new, empty map whose keys have ordering\index{mkDict@\verb,mkDict,!value (\verb,Binarymap,)}
   ordr.

   [insert(m, i, v)] extends (or modifies) map m to map i to v.\index{insert@\verb,insert,!value (\verb,Binarymap,)}

   [find (m, k)] returns v if m maps k to v; otherwise raises NotFound.\index{find@\verb,find,!value (\verb,Binarymap,)}
   
   [peek(m, k)] returns SOME v if m maps k to v; otherwise returns NONE.\index{peek@\verb,peek,!value (\verb,Binarymap,)}

   [remove(m, k)] removes k from the domain of m and returns the\index{remove@\verb,remove,!value (\verb,Binarymap,)}
   modified map and the element v corresponding to k.  Raises NotFound
   if k is not in the domain of m.

   [numItems m] returns the number of entries in m (that is, the size\index{numItems@\verb,numItems,!value (\verb,Binarymap,)}
   of the domain of m).

   [listItems m] returns a list of the entries (k, v) of keys k and\index{listItems@\verb,listItems,!value (\verb,Binarymap,)}
   the corresponding values v in m, in order of increasing key values.

   [app f m] applies function f to the entries (k, v) in m, in\index{app@\verb,app,!value (\verb,Binarymap,)}
   increasing order of k (according to the ordering ordr used to
   create the map or dictionary).

   [revapp f m] applies function f to the entries (k, v) in m, in\index{revapp@\verb,revapp,!value (\verb,Binarymap,)}
   decreasing order of k.

   [foldl f e m] applies the folding function f to the entries (k, v)\index{foldl@\verb,foldl,!value (\verb,Binarymap,)}
   in m, in increasing order of k.

   [foldr f e m] applies the folding function f to the entries (k, v)\index{foldr@\verb,foldr,!value (\verb,Binarymap,)}
   in m, in decreasing order of k.

   [map f m] returns a new map whose entries have form (k, f(k,v)),\index{map@\verb,map,!value (\verb,Binarymap,)}
   where (k, v) is an entry in m.

   [transform f m] returns a new map whose entries have form (k, f v),\index{transform@\verb,transform,!value (\verb,Binarymap,)}
   where (k, v) is an entry in m.
\end{longprogram}
\index{Binarymap@\verb,Binarymap, (structure)|)}\newpage

\section*{Module Binaryset}
\index{Binaryset@\verb,Binaryset, (structure)|(}
\markboth{\MakeUppercase{Binaryset}}{\MakeUppercase{Binaryset}}
\addcontentsline{toc}{section}{Binaryset}
\begin{longprogram}
{\itshape{}Binaryset \verb"-"\verb"-" sets implemented by ordered balanced binary trees }
{\itshape{}From SML/NJ lib 0.2, copyright 1993 by AT\&T Bell Laboratories  }
{\itshape{}Original implementation due to Stephen Adams, Southampton, UK  }

type 'item set\index{set@\verb,set,!type (\verb,Binaryset,)}

exception NotFound\index{NotFound@\verb,NotFound,!exception (\verb,Binaryset,)}

val empty        : ('item * 'item \verb"-"\verb">" order) \verb"-"\verb">" 'item set\index{empty@\verb,empty,!value (\verb,Binaryset,)}
val singleton    : ('item * 'item \verb"-"\verb">" order) \verb"-"\verb">" 'item \verb"-"\verb">" 'item set\index{singleton@\verb,singleton,!value (\verb,Binaryset,)}
val add          : 'item set * 'item \verb"-"\verb">" 'item set\index{add@\verb,add,!value (\verb,Binaryset,)}
val addList      : 'item set * 'item list \verb"-"\verb">" 'item set\index{addList@\verb,addList,!value (\verb,Binaryset,)}
val retrieve     : 'item set * 'item \verb"-"\verb">" 'item\index{retrieve@\verb,retrieve,!value (\verb,Binaryset,)}
val peek         : 'item set * 'item \verb"-"\verb">" 'item option\index{peek@\verb,peek,!value (\verb,Binaryset,)}
val isEmpty      : 'item set \verb"-"\verb">" bool\index{isEmpty@\verb,isEmpty,!value (\verb,Binaryset,)}
val equal        : 'item set * 'item set \verb"-"\verb">" bool\index{equal@\verb,equal,!value (\verb,Binaryset,)}
val isSubset     : 'item set * 'item set \verb"-"\verb">" bool\index{isSubset@\verb,isSubset,!value (\verb,Binaryset,)}
val member       : 'item set * 'item \verb"-"\verb">" bool\index{member@\verb,member,!value (\verb,Binaryset,)}
val delete       : 'item set * 'item \verb"-"\verb">" 'item set\index{delete@\verb,delete,!value (\verb,Binaryset,)}
val numItems     : 'item set \verb"-"\verb">"  int\index{numItems@\verb,numItems,!value (\verb,Binaryset,)}
val union        : 'item set * 'item set \verb"-"\verb">" 'item set\index{union@\verb,union,!value (\verb,Binaryset,)}
val intersection : 'item set * 'item set \verb"-"\verb">" 'item set\index{intersection@\verb,intersection,!value (\verb,Binaryset,)}
val difference   : 'item set * 'item set \verb"-"\verb">" 'item set\index{difference@\verb,difference,!value (\verb,Binaryset,)}
val listItems    : 'item set \verb"-"\verb">" 'item list\index{listItems@\verb,listItems,!value (\verb,Binaryset,)}
val app          : ('item \verb"-"\verb">" unit) \verb"-"\verb">" 'item set \verb"-"\verb">" unit\index{app@\verb,app,!value (\verb,Binaryset,)}
val revapp       : ('item \verb"-"\verb">" unit) \verb"-"\verb">" 'item set \verb"-"\verb">" unit\index{revapp@\verb,revapp,!value (\verb,Binaryset,)}
val foldr        : ('item * 'b \verb"-"\verb">" 'b) \verb"-"\verb">" 'b \verb"-"\verb">" 'item set \verb"-"\verb">" 'b\index{foldr@\verb,foldr,!value (\verb,Binaryset,)}
val foldl        : ('item * 'b \verb"-"\verb">" 'b) \verb"-"\verb">" 'b \verb"-"\verb">" 'item set \verb"-"\verb">" 'b\index{foldl@\verb,foldl,!value (\verb,Binaryset,)}
val find         : ('item \verb"-"\verb">" bool) \verb"-"\verb">" 'item set \verb"-"\verb">" 'item option\index{find@\verb,find,!value (\verb,Binaryset,)}

\separatingline
   ['item set] is the type of sets of ordered elements of type 'item.\index{set@\verb,set,!type (\verb,Binaryset,)}
   The ordering relation on the elements is used in the representation
   of the set.  The result of combining two sets with different
   underlying ordering relations is undefined.  The implementation
   uses ordered balanced binary trees.

   [empty ordr] creates a new empty set with the given ordering\index{empty@\verb,empty,!value (\verb,Binaryset,)}
   relation.  

   [singleton ordr i] creates the singleton set containing i, with the\index{singleton@\verb,singleton,!value (\verb,Binaryset,)}
   given ordering relation.

   [add(s, i)] adds item i to set s.  \index{add@\verb,add,!value (\verb,Binaryset,)}

   [addList(s, xs)] adds all items from the list xs to the set s.\index{addList@\verb,addList,!value (\verb,Binaryset,)}

   [retrieve(s, i)] returns i if it is in s; raises NotFound otherwise.\index{retrieve@\verb,retrieve,!value (\verb,Binaryset,)}

   [peek(s, i)] returns SOME i if i is in s; returns NONE otherwise.\index{peek@\verb,peek,!value (\verb,Binaryset,)}

   [isEmpty s] returns true if and only if the set is empty.\index{isEmpty@\verb,isEmpty,!value (\verb,Binaryset,)}

   [equal(s1, s2)] returns true if and only if the two sets have the\index{equal@\verb,equal,!value (\verb,Binaryset,)}
   same elements.

   [isSubset(s1, s2)] returns true if and only if s1 is a subset of s2.\index{isSubset@\verb,isSubset,!value (\verb,Binaryset,)}

   [member(s, i)] returns true if and only if i is in s.\index{member@\verb,member,!value (\verb,Binaryset,)}

   [delete(s, i)] removes item i from s.  Raises NotFound if i is not in s.\index{delete@\verb,delete,!value (\verb,Binaryset,)}
   
   [numItems s] returns the number of items in set s.\index{numItems@\verb,numItems,!value (\verb,Binaryset,)}

   [union(s1, s2)] returns the union of s1 and s2.  \index{union@\verb,union,!value (\verb,Binaryset,)}

   [intersection(s1, s2)] returns the intersectionof s1 and s2.\index{intersection@\verb,intersection,!value (\verb,Binaryset,)}

   [difference(s1, s2)] returns the difference between s1 and s2 (that\index{difference@\verb,difference,!value (\verb,Binaryset,)}
   is, the set of elements in s1 but not in s2).

   [listItems s] returns a list of the items in set s, in increasing\index{listItems@\verb,listItems,!value (\verb,Binaryset,)}
   order.

   [app f s] applies function f to the elements of s, in increasing\index{app@\verb,app,!value (\verb,Binaryset,)}
   order.

   [revapp f s] applies function f to the elements of s, in decreasing\index{revapp@\verb,revapp,!value (\verb,Binaryset,)}
   order. 

   [foldl f e s] applies the folding function f to the entries of the\index{foldl@\verb,foldl,!value (\verb,Binaryset,)}
   set in increasing order.

   [foldr f e s] applies the folding function f to the entries of the\index{foldr@\verb,foldr,!value (\verb,Binaryset,)}
   set in decreasing order. 

   [find p s] returns SOME i, where i is an item in s which satisfies\index{find@\verb,find,!value (\verb,Binaryset,)}
   p, if one exists; otherwise returns NONE.
\end{longprogram}
\index{Binaryset@\verb,Binaryset, (structure)|)}\newpage

\section*{Module Bool}
\index{Bool@\verb,Bool, (structure)|(}
\markboth{\MakeUppercase{Bool}}{\MakeUppercase{Bool}}
\addcontentsline{toc}{section}{Bool}
\begin{longprogram}
{\itshape{}Bool \verb"-"\verb"-" SML Basis Library }

datatype bool = datatype bool\index{bool@\verb,bool,!type (\verb,Bool,)}

val not        : bool \verb"-"\verb">" bool\index{not@\verb,not,!value (\verb,Bool,)}

val toString   : bool \verb"-"\verb">" string\index{toString@\verb,toString,!value (\verb,Bool,)}
val fromString : string \verb"-"\verb">" bool option\index{fromString@\verb,fromString,!value (\verb,Bool,)}
val scan       : (char, 'a) StringCvt.reader \verb"-"\verb">" (bool, 'a) StringCvt.reader\index{scan@\verb,scan,!value (\verb,Bool,)}

\separatingline
   [bool] is the type of Boolean (logical) values: true and false.\index{bool@\verb,bool,!type (\verb,Bool,)}

   [not b] is the logical negation of b.\index{not@\verb,not,!value (\verb,Bool,)}

   [toString b] returns the string "false" or "true" according as b is\index{toString@\verb,toString,!value (\verb,Bool,)}
   false or true.

   [fromString s] scans a boolean b from the string s, after possible\index{fromString@\verb,fromString,!value (\verb,Bool,)}
   initial whitespace (blanks, tabs, newlines).  Returns (SOME b) if s
   has a prefix which is either "false" or "true"; the value b is the
   corresponding truth value; otherwise NONE is returned.

   [scan getc src] scans a boolean b from the stream src, using the\index{scan@\verb,scan,!value (\verb,Bool,)}
   stream accessor getc.  In case of success, returns SOME(b, rst)
   where b is the scanned boolean value and rst is the remainder of
   the stream; otherwise returns NONE.
\end{longprogram}
\index{Bool@\verb,Bool, (structure)|)}\newpage

\section*{Module Byte}
\index{Byte@\verb,Byte, (structure)|(}
\markboth{\MakeUppercase{Byte}}{\MakeUppercase{Byte}}
\addcontentsline{toc}{section}{Byte}
\begin{longprogram}
{\itshape{}Byte \verb"-"\verb"-" SML Basis Library }

val byteToChar      : Word8.word \verb"-"\verb">" Char.char\index{byteToChar@\verb,byteToChar,!value (\verb,Byte,)}
val charToByte      : Char.char \verb"-"\verb">" Word8.word\index{charToByte@\verb,charToByte,!value (\verb,Byte,)}
val bytesToString   : Word8Vector.vector \verb"-"\verb">" String.string\index{bytesToString@\verb,bytesToString,!value (\verb,Byte,)}
val stringToBytes   : String.string \verb"-"\verb">" Word8Vector.vector\index{stringToBytes@\verb,stringToBytes,!value (\verb,Byte,)}

val unpackStringVec : Word8Vector.vector * int * int option \verb"-"\verb">" string\index{unpackStringVec@\verb,unpackStringVec,!value (\verb,Byte,)}
val unpackString    : Word8Array.array * int * int option \verb"-"\verb">" string\index{unpackString@\verb,unpackString,!value (\verb,Byte,)}
val packString      : Substring.substring * Word8Array.array * int \verb"-"\verb">" unit\index{packString@\verb,packString,!value (\verb,Byte,)}

\separatingline
   Conversions between bytes and characters, and between byte vectors 
   and strings (character vectors).  

   [byteToChar w] is the character corresponding to the byte w.\index{byteToChar@\verb,byteToChar,!value (\verb,Byte,)}

   [charToByte c] is the byte corresponding to character c.\index{charToByte@\verb,charToByte,!value (\verb,Byte,)}

   [bytesToString v] is the string whose character codes are the bytes \index{bytesToString@\verb,bytesToString,!value (\verb,Byte,)}
   from vector v.

   [stringToBytes s] is the byte vector of character codes of the string s.\index{stringToBytes@\verb,stringToBytes,!value (\verb,Byte,)}

   In Moscow ML, all the above operations take constant time.  That
   is, no copying is done.

   [unpackStringVec (v, i, NONE)] is the string whose character codes are\index{unpackStringVec@\verb,unpackStringVec,!value (\verb,Byte,)}
   the bytes of v[i..length v\verb"-"1].  Raises Subscript if i\verb"<"0 or i\verb">"length v.
   Equivalent to bytesToString(Word8Vector.extract (v, i, NONE)).
   
   [unpackStringVec (v, i, SOME n)] is the string whose character codes are\index{unpackStringVec@\verb,unpackStringVec,!value (\verb,Byte,)}
   the bytes of v[i..i+n\verb"-"1].  Raises Subscript if i\verb"<"0 or n\verb"<"0 or i+n\verb">"length v.
   Equivalent to bytesToString(Word8Vector.extract (v, i, SOME n)).

   [unpackString (a, i, NONE)] is the string whose character codes are\index{unpackString@\verb,unpackString,!value (\verb,Byte,)}
   the bytes of a[i..length a\verb"-"1].  Raises Subscript if i\verb"<"0 or i\verb">"length a.
   Equivalent to bytesToString(Word8Array.extract (v, i, NONE)).
   
   [unpackString (a, i, SOME n)] is the string whose character codes are\index{unpackString@\verb,unpackString,!value (\verb,Byte,)}
   the bytes of a[i..i+n\verb"-"1].  Raises Subscript if i\verb"<"0 or n\verb"<"0 or i+n\verb">"length a.
   Equivalent to bytesToString(Word8Array.extract (a, i, SOME n)).

   [packString (ss, a, i)] copies the character codes of substring ss into\index{packString@\verb,packString,!value (\verb,Byte,)}
   the subarray a[i..i+n\verb"-"1] where n = Substring.size ss.  Raises Subscript 
   if i\verb"<"0 or i+n \verb">" length a.
   Equivalent to Word8Array.copyVec\verb"{"src=s, si=si, len=SOME n, dst=a, di=i\verb"}" 
   when (s, si, n) = Substring.base ss.
\end{longprogram}
\index{Byte@\verb,Byte, (structure)|)}\newpage

\section*{Module Callback}
\index{Callback@\verb,Callback, (structure)|(}
\markboth{\MakeUppercase{Callback}}{\MakeUppercase{Callback}}
\addcontentsline{toc}{section}{Callback}
\begin{longprogram}
{\itshape{}Callback \verb"-"\verb"-" registering ML values with C, and accessing C values from ML }

{\itshape{}Registering ML values for access from C code: }

val register     : string \verb"-"\verb">" 'a \verb"-"\verb">" unit\index{register@\verb,register,!value (\verb,Callback,)}
val unregister   : string \verb"-"\verb">" unit\index{unregister@\verb,unregister,!value (\verb,Callback,)}
val isRegistered : string \verb"-"\verb">" bool\index{isRegistered@\verb,isRegistered,!value (\verb,Callback,)}


{\itshape{}Accessing C variables and functions from ML: }

type cptr\index{cptr@\verb,cptr,!type (\verb,Callback,)}

val getcptr : string \verb"-"\verb">" cptr\index{getcptr@\verb,getcptr,!value (\verb,Callback,)}
val var     : cptr \verb"-"\verb">" 'b                            \index{var@\verb,var,!value (\verb,Callback,)}
val app1    : cptr \verb"-"\verb">" 'a1 \verb"-"\verb">" 'b                     \index{app1@\verb,app1,!value (\verb,Callback,)}
val app2    : cptr \verb"-"\verb">" 'a1 \verb"-"\verb">" 'a2 \verb"-"\verb">" 'b              \index{app2@\verb,app2,!value (\verb,Callback,)}
val app3    : cptr \verb"-"\verb">" 'a1 \verb"-"\verb">" 'a2 \verb"-"\verb">" 'a3 \verb"-"\verb">" 'b       \index{app3@\verb,app3,!value (\verb,Callback,)}
val app4    : cptr \verb"-"\verb">" 'a1 \verb"-"\verb">" 'a2 \verb"-"\verb">" 'a3 \verb"-"\verb">" 'a4 \verb"-"\verb">" 'b\index{app4@\verb,app4,!value (\verb,Callback,)}
val app5    : cptr \verb"-"\verb">" 'a1 \verb"-"\verb">" 'a2 \verb"-"\verb">" 'a3 \verb"-"\verb">" 'a4 \verb"-"\verb">" 'a5 \verb"-"\verb">" 'b\index{app5@\verb,app5,!value (\verb,Callback,)}

\separatingline
   REGISTERING ML VALUES FOR ACCESS FROM C CODE
   \verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"

   This example shows how to register the ML function (fn n =\verb">" 2*n) so
   that it may be called from C code.

   (0) The ML side registers the function:
          Callback.register "myfun" (fn n =\verb">" 2*n)               

   (1) The C side first obtains an ML value pointer:
          valueptr mvp = get_valueptr("myfun");
   
   (2) The C side then uses the ML value pointer to obtain an ML
       value, and uses it:
          callback(get_value(mvp), Val_long(42));

   Operation (1) involves a callback to ML, and hence may be slow.
   Calling get_valueptr may cause the garbage collector to run; hence
   other live ML values must be registered as GC roots.  The garbage
   collector will never move the ML value pointer; hence it need not
   be registered as a GC root in the C code.

   Operation (2) is very fast.  If the garbage collector is invoked
   between the call of get_value() and the use of the ML value, then 
   the value must be registered as a GC root.  However, the idiom
        callback(get_value(mvp), arg1);
   is safe provided the evaluation of arg1 does not provoke a garbage
   collection (e.g. if arg1 is a variable).

   The C function get_valueptr returns NULL if nam is not registered.

   The C function get_value returns NULL if nam has been unregistered
   (and not reregistered) since mvp was obtained; it raises exception
   Fail if mvp itself is NULL.  Every access to the ML value from C
   code should use the ML valueptr and get_valueptr, otherwise the C
   code will not know when the value has been unregistered and
   possibly deallocated.

   The C functions (in mosml/src/runtime/callback.c)
      void registervalue(char* nam, value mlval)
      void unregistervalue(char* nam)
   can be used just as Callback.register and Callback.unregister.

   The C functions
      value callbackptr (valueptr mvp, value arg1)
      value callbackptr2(valueptr mvp, value arg1, value arg2)
      value callbackptr3(valueptr mvp, value arg1, value arg2, value arg3)
   can be used for callback via an ML value pointer; they will raise
   exception Fail if the ML function indicated by mvp has been unregistered.


   [register nam v] registers the ML value v, so that it can be\index{register@\verb,register,!value (\verb,Callback,)}
   retrieved from C code under the name nam.  If nam has previously
   been registered and then unregistered, it will be reregistered with
   the new value.  The new value immediately becomes visible to the C
   side, both via get_valueptr nam and via any ML value pointer
   previously obtained for nam.  Raises exception Fail if nam has
   been registered and not yet unregistered.

   [unregister nam] deletes the registration.  This prevents C code\index{unregister@\verb,unregister,!value (\verb,Callback,)}
   from obtaining an ML value pointer for nam and from using an ML
   value pointer already obtained (but does not prevent C from
   attempting to use a stored ML value previously obtained with the
   help of the ML value pointer, which is unsafe anyway).  Does
   nothing if nam is already unregistered.  Raises exception Fail
   if nam has never been registered.

   [isRegistered nam] returns true if nam has been registered and not\index{isRegistered@\verb,isRegistered,!value (\verb,Callback,)}
   yet unregistered.


   ACCESSING REGISTERED C VARIABLES AND FUNCTIONS FROM ML
   \verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"

   This example shows how to register the C function 

      value silly_cfun(value v) 
      \verb"{" return copy_double(42.42 * Double_val(v)); \verb"}"

   so that it may be called from ML.

   (0) The C side registers the function:
          registercptr("mycfun", sillycfun);

   (1) The ML side obtains a C pointer and defines an ML function
       via that pointer: 
          val sillycfun = app1 (getcptr "mycfun") : real \verb"-"\verb">" real
       The type ascription is needed to ensure any type safety whatsoever.
       Mistakes in the types will lead to crashes, as usual with C.

   (2) To the ML side, the new ML function is indistinguishable from
       other ML functions
          val result = sillyfun(3.4)

   The C function (in mosml/src/runtime/callback.c)
        void registercptr(char* nam, void* cptr);

   is used to register C pointers for access from ML.  Only pointers
   to static C variables, and C functions, should be registered. There
   is no way to unregister a C pointer.

   [cptr] is the type of pointers to C variables and C functions.\index{cptr@\verb,cptr,!type (\verb,Callback,)}

   [getcptr nam] returns a pointer to the C variable or function\index{getcptr@\verb,getcptr,!value (\verb,Callback,)}
   registered (by the C side) under the name nam.  Raises exception
   Fail if the name nam has not been registered.

   [var cptr] returns the value of the C variable associated with cptr.\index{var@\verb,var,!value (\verb,Callback,)}

   [app1 cptr arg1] applies the C function associated with cptr to arg1.\index{app1@\verb,app1,!value (\verb,Callback,)}

   [app2 cptr arg1 arg2] applies the C function associated with cptr to\index{app2@\verb,app2,!value (\verb,Callback,)}
   (arg1, arg2).

   [app3 cptr arg1 arg2 arg3] applies the C function associated with\index{app3@\verb,app3,!value (\verb,Callback,)}
   cptr to (arg1, arg2, arg3).

   [app4 cptr arg1 arg2 arg3 arg4] applies the C function associated\index{app4@\verb,app4,!value (\verb,Callback,)}
   with cptr to (arg1, arg2, arg3, arg4).

   [app5 cptr arg1 arg2 arg3 arg4 arg5] applies the C function\index{app5@\verb,app5,!value (\verb,Callback,)}
   associated with cptr to (arg1, arg2, arg3, arg4, arg5). 
\end{longprogram}
\index{Callback@\verb,Callback, (structure)|)}\newpage

\section*{Module Char}
\index{Char@\verb,Char, (structure)|(}
\markboth{\MakeUppercase{Char}}{\MakeUppercase{Char}}
\addcontentsline{toc}{section}{Char}
\begin{longprogram}
{\itshape{}Char \verb"-"\verb"-" SML Basis Library }

type char = char\index{char@\verb,char,!type (\verb,Char,)}

val minChar : char\index{minChar@\verb,minChar,!value (\verb,Char,)}
val maxChar : char\index{maxChar@\verb,maxChar,!value (\verb,Char,)}
val maxOrd  : int       \index{maxOrd@\verb,maxOrd,!value (\verb,Char,)}

val chr     : int  \verb"-"\verb">" char       {\itshape{}May raise Chr }\index{chr@\verb,chr,!value (\verb,Char,)}
val ord     : char \verb"-"\verb">" int\index{ord@\verb,ord,!value (\verb,Char,)}
val succ    : char \verb"-"\verb">" char       {\itshape{}May raise Chr }\index{succ@\verb,succ,!value (\verb,Char,)}
val pred    : char \verb"-"\verb">" char       {\itshape{}May raise Chr }\index{pred@\verb,pred,!value (\verb,Char,)}

val isLower     : char \verb"-"\verb">" bool   {\itshape{}contains "abcdefghijklmnopqrstuvwxyz"  }\index{isLower@\verb,isLower,!value (\verb,Char,)}
val isUpper     : char \verb"-"\verb">" bool   {\itshape{}contains "ABCDEFGHIJKLMNOPQRSTUVWXYZ"  }\index{isUpper@\verb,isUpper,!value (\verb,Char,)}
val isDigit     : char \verb"-"\verb">" bool   {\itshape{}contains "0123456789"                  }\index{isDigit@\verb,isDigit,!value (\verb,Char,)}
val isAlpha     : char \verb"-"\verb">" bool   {\itshape{}isUpper orelse isLower                 }\index{isAlpha@\verb,isAlpha,!value (\verb,Char,)}
val isHexDigit  : char \verb"-"\verb">" bool   {\itshape{}isDigit orelse contains "abcdefABCDEF" }\index{isHexDigit@\verb,isHexDigit,!value (\verb,Char,)}
val isAlphaNum  : char \verb"-"\verb">" bool   {\itshape{}isAlpha orelse isDigit                 }\index{isAlphaNum@\verb,isAlphaNum,!value (\verb,Char,)}
val isPrint     : char \verb"-"\verb">" bool   {\itshape{}any printable character (incl. #" ")   }\index{isPrint@\verb,isPrint,!value (\verb,Char,)}
val isSpace     : char \verb"-"\verb">" bool   {\itshape{}contains " \verb"\"t\verb"\"r\verb"\"n\verb"\"v\verb"\"f"                 }\index{isSpace@\verb,isSpace,!value (\verb,Char,)}
val isPunct     : char \verb"-"\verb">" bool   {\itshape{}printable, not space or alphanumeric   } \index{isPunct@\verb,isPunct,!value (\verb,Char,)}
val isGraph     : char \verb"-"\verb">" bool   {\itshape{}(not isSpace) andalso isPrint          }\index{isGraph@\verb,isGraph,!value (\verb,Char,)}
val isAscii     : char \verb"-"\verb">" bool   {\itshape{}ord c \verb"<" 128                            }\index{isAscii@\verb,isAscii,!value (\verb,Char,)}
val isCntrl     : char \verb"-"\verb">" bool   {\itshape{}control character                      }\index{isCntrl@\verb,isCntrl,!value (\verb,Char,)}

val toLower     : char \verb"-"\verb">" char\index{toLower@\verb,toLower,!value (\verb,Char,)}
val toUpper     : char \verb"-"\verb">" char\index{toUpper@\verb,toUpper,!value (\verb,Char,)}

val fromString  : string \verb"-"\verb">" char option       {\itshape{}ML escape sequences }\index{fromString@\verb,fromString,!value (\verb,Char,)}
val toString    : char \verb"-"\verb">" string              {\itshape{}ML escape sequences }\index{toString@\verb,toString,!value (\verb,Char,)}

val fromCString : string \verb"-"\verb">" char option       {\itshape{}C escape sequences  }\index{fromCString@\verb,fromCString,!value (\verb,Char,)}
val toCString   : char \verb"-"\verb">" string              {\itshape{}C escape sequences  }\index{toCString@\verb,toCString,!value (\verb,Char,)}

val contains    : string \verb"-"\verb">" char \verb"-"\verb">" bool\index{contains@\verb,contains,!value (\verb,Char,)}
val notContains : string \verb"-"\verb">" char \verb"-"\verb">" bool\index{notContains@\verb,notContains,!value (\verb,Char,)}

val \verb"<"       : char * char \verb"-"\verb">" bool\index{<@\verb,<,!value (\verb,Char,)}
val \verb"<"=      : char * char \verb"-"\verb">" bool\index{<=@\verb,<=,!value (\verb,Char,)}
val \verb">"       : char * char \verb"-"\verb">" bool\index{>@\verb,>,!value (\verb,Char,)}
val \verb">"=      : char * char \verb"-"\verb">" bool\index{>=@\verb,>=,!value (\verb,Char,)}
val compare : char * char \verb"-"\verb">" order\index{compare@\verb,compare,!value (\verb,Char,)}

\separatingline
   [char] is the type of characters.  \index{char@\verb,char,!type (\verb,Char,)}

   [minChar] is the least character in the ordering \verb"<".\index{minChar@\verb,minChar,!value (\verb,Char,)}

   [maxChar] is the greatest character in the ordering \verb"<".\index{maxChar@\verb,maxChar,!value (\verb,Char,)}

   [maxOrd] is the greatest character code; equals ord(maxChar).\index{maxOrd@\verb,maxOrd,!value (\verb,Char,)}

   [chr i] returns the character whose code is i.  Raises Chr if\index{chr@\verb,chr,!value (\verb,Char,)}
   i\verb"<"0 or i\verb">"maxOrd.

   [ord c] returns the code of character c.\index{ord@\verb,ord,!value (\verb,Char,)}

   [succ c] returns the character immediately following c, or raises\index{succ@\verb,succ,!value (\verb,Char,)}
   Chr if c = maxChar.

   [pred c] returns the character immediately preceding c, or raises\index{pred@\verb,pred,!value (\verb,Char,)}
   Chr if c = minChar.

   [isLower c] returns true if c is a lowercase letter (a to z).\index{isLower@\verb,isLower,!value (\verb,Char,)}

   [isUpper c] returns true if c is a uppercase letter (A to Z).\index{isUpper@\verb,isUpper,!value (\verb,Char,)}

   [isDigit c] returns true if c is a decimal digit (0 to 9).\index{isDigit@\verb,isDigit,!value (\verb,Char,)}

   [isAlpha c] returns true if c is a letter (lowercase or uppercase).\index{isAlpha@\verb,isAlpha,!value (\verb,Char,)}

   [isHexDigit c] returns true if c is a hexadecimal digit (0 to 9 or \index{isHexDigit@\verb,isHexDigit,!value (\verb,Char,)}
   a to f or A to F).

   [isAlphaNum c] returns true if c is alphanumeric (a letter or a\index{isAlphaNum@\verb,isAlphaNum,!value (\verb,Char,)}
   decimal digit).

   [isPrint c] returns true if c is a printable character (space or visible)\index{isPrint@\verb,isPrint,!value (\verb,Char,)}

   [isSpace c] returns true if c is a whitespace character (blank, newline,\index{isSpace@\verb,isSpace,!value (\verb,Char,)}
   tab, vertical tab, new page).

   [isGraph c] returns true if c is a graphical character, that is,\index{isGraph@\verb,isGraph,!value (\verb,Char,)}
   it is printable and not a whitespace character.

   [isPunct c] returns true if c is a punctuation character, that is, \index{isPunct@\verb,isPunct,!value (\verb,Char,)}
   graphical but not alphanumeric.

   [isCntrl c] returns true if c is a control character, that is, if\index{isCntrl@\verb,isCntrl,!value (\verb,Char,)}
   not (isPrint c).

   [isAscii c] returns true if 0 \verb"<"= ord c \verb"<"= 127.\index{isAscii@\verb,isAscii,!value (\verb,Char,)}

   [toLower c] returns the lowercase letter corresponding to c,\index{toLower@\verb,toLower,!value (\verb,Char,)}
   if c is a letter (a to z or A to Z); otherwise returns c.

   [toUpper c] returns the uppercase letter corresponding to c,\index{toUpper@\verb,toUpper,!value (\verb,Char,)}
   if c is a letter (a to z or A to Z); otherwise returns c.

   [contains s c] returns true if character c occurs in the string s;\index{contains@\verb,contains,!value (\verb,Char,)}
   false otherwise.  The function, when applied to s, builds a table
   and returns a function which uses table lookup to decide whether a
   given character is in the string or not.  Hence it is relatively
   expensive to compute  val p = contains s  but very fast to compute 
   p(c) for any given character.

   [notContains s c] returns true if character c does not occur in the\index{notContains@\verb,notContains,!value (\verb,Char,)}
   string s; false otherwise.  Works by construction of a lookup table
   in the same way as the above function.

   [fromString s] attempts to scan a character or ML escape sequence\index{fromString@\verb,fromString,!value (\verb,Char,)}
   from the string s.  Does not skip leading whitespace.  For
   instance, fromString "\verb"\"\verb"\"065" equals #"A".

   [toString c] returns a string consisting of the character c, if c\index{toString@\verb,toString,!value (\verb,Char,)}
   is printable, else an ML escape sequence corresponding to c.  A
   printable character is mapped to a one\verb"-"character string; bell,
   backspace, tab, newline, vertical tab, form feed, and carriage
   return are mapped to the two\verb"-"character strings "\verb"\"\verb"\"a", "\verb"\"\verb"\"b", "\verb"\"\verb"\"t",
   "\verb"\"\verb"\"n", "\verb"\"\verb"\"v", "\verb"\"\verb"\"f", and "\verb"\"\verb"\"r"; other characters with code less
   than 32 are mapped to three\verb"-"character strings of the form "\verb"\"\verb"\"^Z",
   and characters with codes 127 through 255 are mapped to
   four\verb"-"character strings of the form "\verb"\"\verb"\"ddd", where ddd are three decimal 
   digits representing the character code.  For instance,
             toString #"A"      equals "A" 
             toString #"\verb"\"\verb"\""     equals "\verb"\"\verb"\"\verb"\"\verb"\"" 
             toString #"\verb"\"""     equals "\verb"\"\verb"\"\verb"\""" 
             toString (chr   0) equals "\verb"\"\verb"\"^@"
             toString (chr   1) equals "\verb"\"\verb"\"^A"
             toString (chr   6) equals "\verb"\"\verb"\"^F"
             toString (chr   7) equals "\verb"\"\verb"\"a"
             toString (chr   8) equals "\verb"\"\verb"\"b"
             toString (chr   9) equals "\verb"\"\verb"\"t"
             toString (chr  10) equals "\verb"\"\verb"\"n"
             toString (chr  11) equals "\verb"\"\verb"\"v"
             toString (chr  12) equals "\verb"\"\verb"\"f"
             toString (chr  13) equals "\verb"\"\verb"\"r"
             toString (chr  14) equals "\verb"\"\verb"\"^N"
             toString (chr 127) equals "\verb"\"\verb"\"127"
             toString (chr 128) equals "\verb"\"\verb"\"128"

   [fromCString s] attempts to scan a character or C escape sequence\index{fromCString@\verb,fromCString,!value (\verb,Char,)}
   from the string s.  Does not skip leading whitespace.  For
   instance, fromString "\verb"\"\verb"\"065" equals #"A".

   [toCString c] returns a string consisting of the character c, if c\index{toCString@\verb,toCString,!value (\verb,Char,)}
   is printable, else an C escape sequence corresponding to c.  A
   printable character is mapped to a one\verb"-"character string; bell,
   backspace, tab, newline, vertical tab, form feed, and carriage
   return are mapped to the two\verb"-"character strings "\verb"\"\verb"\"a", "\verb"\"\verb"\"b", "\verb"\"\verb"\"t",
   "\verb"\"\verb"\"n", "\verb"\"\verb"\"v", "\verb"\"\verb"\"f", and "\verb"\"\verb"\"r"; other characters are mapped to 
   four\verb"-"character strings of the form "\verb"\"\verb"\"ooo", where ooo are three 
   octal digits representing the character code.  For instance,
             toString #"A"      equals "A" 
             toString #"A"      equals "A" 
             toString #"\verb"\"\verb"\""     equals "\verb"\"\verb"\"\verb"\"\verb"\"" 
             toString #"\verb"\"""     equals "\verb"\"\verb"\"\verb"\""" 
             toString (chr   0) equals "\verb"\"\verb"\"000"
             toString (chr   1) equals "\verb"\"\verb"\"001"
             toString (chr   6) equals "\verb"\"\verb"\"006"
             toString (chr   7) equals "\verb"\"\verb"\"a"
             toString (chr   8) equals "\verb"\"\verb"\"b"
             toString (chr   9) equals "\verb"\"\verb"\"t"
             toString (chr  10) equals "\verb"\"\verb"\"n"
             toString (chr  11) equals "\verb"\"\verb"\"v"
             toString (chr  12) equals "\verb"\"\verb"\"f"
             toString (chr  13) equals "\verb"\"\verb"\"r"
             toString (chr  14) equals "\verb"\"\verb"\"016"
             toString (chr 127) equals "\verb"\"\verb"\"177"
             toString (chr 128) equals "\verb"\"\verb"\"200"

   [\verb"<"] \index{<@\verb,<,!value (\verb,Char,)}
   [\verb"<"=]\index{<=@\verb,<=,!value (\verb,Char,)}
   [\verb">"]\index{>@\verb,>,!value (\verb,Char,)}
   [\verb">"=] compares character codes.  For instance, c1 \verb"<" c2 returns true \index{>=@\verb,>=,!value (\verb,Char,)}
   if ord(c1) \verb"<" ord(c2), and similarly for \verb"<"=, \verb">", \verb">"=.  

   [compare(c1, c2)] returns LESS, EQUAL, or GREATER, according as c1 is\index{compare@\verb,compare,!value (\verb,Char,)}
   precedes, equals, or follows c2 in the ordering Char.\verb"<" .
\end{longprogram}
\index{Char@\verb,Char, (structure)|)}\newpage

\section*{Module CharArray}
\index{CharArray@\verb,CharArray, (structure)|(}
\markboth{\MakeUppercase{CharArray}}{\MakeUppercase{CharArray}}
\addcontentsline{toc}{section}{CharArray}
\begin{longprogram}
{\itshape{}CharArray \verb"-"\verb"-" SML Basis Library }

eqtype array\index{array@\verb,array,!type (\verb,CharArray,)}
type elem   = Char.char\index{elem@\verb,elem,!type (\verb,CharArray,)}
type vector = CharVector.vector\index{vector@\verb,vector,!type (\verb,CharArray,)}

val maxLen   : int\index{maxLen@\verb,maxLen,!value (\verb,CharArray,)}

val array    : int * elem \verb"-"\verb">" array\index{array@\verb,array,!value (\verb,CharArray,)}
val tabulate : int * (int \verb"-"\verb">" elem) \verb"-"\verb">" array\index{tabulate@\verb,tabulate,!value (\verb,CharArray,)}
val fromList : elem list \verb"-"\verb">" array\index{fromList@\verb,fromList,!value (\verb,CharArray,)}

val length   : array \verb"-"\verb">" int\index{length@\verb,length,!value (\verb,CharArray,)}
val sub      : array * int \verb"-"\verb">" elem\index{sub@\verb,sub,!value (\verb,CharArray,)}
val update   : array * int * elem \verb"-"\verb">" unit\index{update@\verb,update,!value (\verb,CharArray,)}
val extract  : array * int * int option \verb"-"\verb">" vector\index{extract@\verb,extract,!value (\verb,CharArray,)}

val copy     : \verb"{"src: array,  si: int, len: int option, \index{copy@\verb,copy,!value (\verb,CharArray,)}
                dst: array, di: int\verb"}" \verb"-"\verb">" unit
val copyVec  : \verb"{"src: vector, si: int, len: int option, \index{copyVec@\verb,copyVec,!value (\verb,CharArray,)}
                dst: array, di: int\verb"}" \verb"-"\verb">" unit

val app      : (elem \verb"-"\verb">" unit) \verb"-"\verb">" array \verb"-"\verb">" unit\index{app@\verb,app,!value (\verb,CharArray,)}
val foldl    : (elem * 'b \verb"-"\verb">" 'b) \verb"-"\verb">" 'b \verb"-"\verb">" array \verb"-"\verb">" 'b\index{foldl@\verb,foldl,!value (\verb,CharArray,)}
val foldr    : (elem * 'b \verb"-"\verb">" 'b) \verb"-"\verb">" 'b \verb"-"\verb">" array \verb"-"\verb">" 'b\index{foldr@\verb,foldr,!value (\verb,CharArray,)}
val modify   : (elem \verb"-"\verb">" elem) \verb"-"\verb">" array \verb"-"\verb">" unit\index{modify@\verb,modify,!value (\verb,CharArray,)}

val appi     : (int * elem \verb"-"\verb">" unit) \verb"-"\verb">" array * int * int option \verb"-"\verb">" unit\index{appi@\verb,appi,!value (\verb,CharArray,)}
val foldli   : (int * elem * 'b \verb"-"\verb">" 'b) \verb"-"\verb">" 'b \verb"-"\verb">" array * int * int option \verb"-"\verb">" 'b\index{foldli@\verb,foldli,!value (\verb,CharArray,)}
val foldri   : (int * elem * 'b \verb"-"\verb">" 'b) \verb"-"\verb">" 'b \verb"-"\verb">" array * int * int option \verb"-"\verb">" 'b\index{foldri@\verb,foldri,!value (\verb,CharArray,)}
val modifyi  : (int * elem \verb"-"\verb">" elem) \verb"-"\verb">" array * int * int option \verb"-"\verb">" unit\index{modifyi@\verb,modifyi,!value (\verb,CharArray,)}

\separatingline
   [array] is the type of one\verb"-"dimensional, mutable, zero\verb"-"based\index{array@\verb,array,!type (\verb,CharArray,)}
   constant\verb"-"time\verb"-"access arrays with elements of type Char.char, that
   is, characters.  Arrays a1 and a2 are equal if both were created by
   the same call to a primitive, or if both are empty.

   All operations are as for Array.array.
\end{longprogram}
\index{CharArray@\verb,CharArray, (structure)|)}\newpage

\section*{Module CharVector}
\index{CharVector@\verb,CharVector, (structure)|(}
\markboth{\MakeUppercase{CharVector}}{\MakeUppercase{CharVector}}
\addcontentsline{toc}{section}{CharVector}
\begin{longprogram}
{\itshape{}CharVector \verb"-"\verb"-" SML Basis Library }

type vector = string\index{vector@\verb,vector,!type (\verb,CharVector,)}
type elem = Char.char\index{elem@\verb,elem,!type (\verb,CharVector,)}

val maxLen   : int\index{maxLen@\verb,maxLen,!value (\verb,CharVector,)}

val fromList : elem list \verb"-"\verb">" vector\index{fromList@\verb,fromList,!value (\verb,CharVector,)}
val tabulate : int * (int \verb"-"\verb">" elem) \verb"-"\verb">" vector\index{tabulate@\verb,tabulate,!value (\verb,CharVector,)}

val length   : vector \verb"-"\verb">" int\index{length@\verb,length,!value (\verb,CharVector,)}
val sub      : vector * int \verb"-"\verb">" elem\index{sub@\verb,sub,!value (\verb,CharVector,)}
val extract  : vector * int * int option \verb"-"\verb">" vector\index{extract@\verb,extract,!value (\verb,CharVector,)}
val concat   : vector list \verb"-"\verb">" vector\index{concat@\verb,concat,!value (\verb,CharVector,)}

val app      : (elem \verb"-"\verb">" unit) \verb"-"\verb">" vector \verb"-"\verb">" unit\index{app@\verb,app,!value (\verb,CharVector,)}
val map      : (elem \verb"-"\verb">" elem) \verb"-"\verb">" vector \verb"-"\verb">" vector\index{map@\verb,map,!value (\verb,CharVector,)}
val foldl    : (elem * 'b \verb"-"\verb">" 'b) \verb"-"\verb">" 'b \verb"-"\verb">" vector \verb"-"\verb">" 'b\index{foldl@\verb,foldl,!value (\verb,CharVector,)}
val foldr    : (elem * 'b \verb"-"\verb">" 'b) \verb"-"\verb">" 'b \verb"-"\verb">" vector \verb"-"\verb">" 'b\index{foldr@\verb,foldr,!value (\verb,CharVector,)}

val appi     : (int * elem \verb"-"\verb">" unit) \verb"-"\verb">" vector * int * int option \verb"-"\verb">" unit\index{appi@\verb,appi,!value (\verb,CharVector,)}
val mapi     : (int * elem \verb"-"\verb">" elem) \verb"-"\verb">" vector * int * int option \verb"-"\verb">" vector\index{mapi@\verb,mapi,!value (\verb,CharVector,)}
val foldli   : (int * elem * 'b \verb"-"\verb">" 'b) \verb"-"\verb">" 'b \verb"-"\verb">" vector*int*int option \verb"-"\verb">" 'b\index{foldli@\verb,foldli,!value (\verb,CharVector,)}
val foldri   : (int * elem * 'b \verb"-"\verb">" 'b) \verb"-"\verb">" 'b \verb"-"\verb">" vector*int*int option \verb"-"\verb">" 'b\index{foldri@\verb,foldri,!value (\verb,CharVector,)}

\separatingline
   [vector] is the type of one\verb"-"dimensional, immutable, zero\verb"-"based\index{vector@\verb,vector,!type (\verb,CharVector,)}
   constant\verb"-"time\verb"-"access vectors with elements of type Char.char, that
   is, characters.  Type vector admits equality, and vectors v1 and v2
   are equal if they have the same length and their elements are
   equal.  The type vector is the same as String.string.

   All operations are as for Vector.vector.
\end{longprogram}
\index{CharVector@\verb,CharVector, (structure)|)}\newpage

\section*{Module CommandLine}
\index{CommandLine@\verb,CommandLine, (structure)|(}
\markboth{\MakeUppercase{CommandLine}}{\MakeUppercase{CommandLine}}
\addcontentsline{toc}{section}{CommandLine}
\begin{longprogram}
{\itshape{}CommandLine \verb"-"\verb"-" SML Basis Library }

val name      : unit \verb"-"\verb">" string \index{name@\verb,name,!value (\verb,CommandLine,)}
val arguments : unit \verb"-"\verb">" string list\index{arguments@\verb,arguments,!value (\verb,CommandLine,)}

\separatingline
   [name ()] returns the name used to start the current process.\index{name@\verb,name,!value (\verb,CommandLine,)}

   [arguments ()] returns the command line arguments of the current process.\index{arguments@\verb,arguments,!value (\verb,CommandLine,)}
   Hence List.nth(arguments (), 0) is the first argument.
\end{longprogram}
\index{CommandLine@\verb,CommandLine, (structure)|)}\newpage

\section*{Module Date}
\index{Date@\verb,Date, (structure)|(}
\markboth{\MakeUppercase{Date}}{\MakeUppercase{Date}}
\addcontentsline{toc}{section}{Date}
\begin{longprogram}
{\itshape{}Date \verb"-"\verb"-" SML Basis Library }

datatype weekday = Mon | Tue | Wed | Thu | Fri | Sat | Sun\index{weekday@\verb,weekday,!type (\verb,Date,)}

datatype month = Jan | Feb | Mar | Apr | May | Jun\index{month@\verb,month,!type (\verb,Date,)}
               | Jul | Aug | Sep | Oct | Nov | Dec

type date\index{date@\verb,date,!type (\verb,Date,)}

exception Date\index{Date@\verb,Date,!exception (\verb,Date,)}

val date : \verb"{"\index{date@\verb,date,!value (\verb,Date,)}
             year   : int,              {\itshape{}e.g. 1999                     }
             month  : month,            {\itshape{}Jan, Feb, ...                 }
             day    : int,              {\itshape{}1\verb"-"31                          }
             hour   : int,              {\itshape{}0\verb"-"23                          }
             minute : int,              {\itshape{}0\verb"-"59                          }
             second : int,              {\itshape{}0\verb"-"61, permitting leap seconds }
             offset : Time.time option  {\itshape{}time zone west of UTC         }
           \verb"}" \verb"-"\verb">" date

val year       : date \verb"-"\verb">" int\index{year@\verb,year,!value (\verb,Date,)}
val month      : date \verb"-"\verb">" month\index{month@\verb,month,!value (\verb,Date,)}
val day        : date \verb"-"\verb">" int\index{day@\verb,day,!value (\verb,Date,)}
val hour       : date \verb"-"\verb">" int\index{hour@\verb,hour,!value (\verb,Date,)}
val minute     : date \verb"-"\verb">" int\index{minute@\verb,minute,!value (\verb,Date,)}
val second     : date \verb"-"\verb">" int\index{second@\verb,second,!value (\verb,Date,)}
val weekDay    : date \verb"-"\verb">" weekday\index{weekDay@\verb,weekDay,!value (\verb,Date,)}
val yearDay    : date \verb"-"\verb">" int\index{yearDay@\verb,yearDay,!value (\verb,Date,)}
val isDst      : date \verb"-"\verb">" bool option\index{isDst@\verb,isDst,!value (\verb,Date,)}
val offset     : date \verb"-"\verb">" Time.time option\index{offset@\verb,offset,!value (\verb,Date,)}

val compare    : date * date \verb"-"\verb">" order\index{compare@\verb,compare,!value (\verb,Date,)}

val toString   : date \verb"-"\verb">" string\index{toString@\verb,toString,!value (\verb,Date,)}
val fmt        : string \verb"-"\verb">" date \verb"-"\verb">" string\index{fmt@\verb,fmt,!value (\verb,Date,)}
val fromString : string \verb"-"\verb">" date option\index{fromString@\verb,fromString,!value (\verb,Date,)}
val scan       : (char, 'a) StringCvt.reader \verb"-"\verb">" (date, 'a) StringCvt.reader\index{scan@\verb,scan,!value (\verb,Date,)}

val fromTimeLocal : Time.time \verb"-"\verb">" date\index{fromTimeLocal@\verb,fromTimeLocal,!value (\verb,Date,)}
val fromTimeUniv  : Time.time \verb"-"\verb">" date\index{fromTimeUniv@\verb,fromTimeUniv,!value (\verb,Date,)}
val toTime        : date \verb"-"\verb">" Time.time\index{toTime@\verb,toTime,!value (\verb,Date,)}
val localOffset   : unit \verb"-"\verb">" Time.time\index{localOffset@\verb,localOffset,!value (\verb,Date,)}

\separatingline
   These functions convert times to dates and vice versa, and format
   and scan dates.

   [date] is the type of points in time in a given time zone.  If the\index{date@\verb,date,!type (\verb,Date,)}
   offset is NONE, then the date is in the local time zone.  If the
   offset is SOME t, then t is the offset of the main timezone
   (ignoring daylight savings time) west of UTC.
        When 0 hours \verb"<"= t \verb"<" 12 hours, the represented time is to the
   west of UTC and the local time is UTC\verb"-"t.  
        When 12 hours \verb"<"= t \verb"<" 23 hours, the represented time is to the
   East of UTC and the local time is UTC+(24\verb"-"t).

   [date \verb"{" year, month, day, hour, minute, second, offset \verb"}"] returns a\index{date@\verb,date,!value (\verb,Date,)}
   canonical date value.  Seconds outside the range 0..59 are
   converted to the equivalent minutes and added to the minutes
   argument; leap seconds are ignored.  Similarly, excess minutes are
   converted to hours, hours to days, days to months, and months to
   years.  Then the weekday and day number in the year are computed.
   Leap years are assumed in accordance with the Gregorian calendar,
   for any year after year 0 A.D.

   If the offset is greater than one day (24 hours), then the excess
   days are added to the days, and the offset modulo 24 hours is used.

   [year dt] returns the year of dt, e.g. 1999.\index{year@\verb,year,!value (\verb,Date,)}

   [month dt] returns the month of dt.\index{month@\verb,month,!value (\verb,Date,)}

   [day dt] returns the day of dt\index{day@\verb,day,!value (\verb,Date,)}

   [hour dt] returns the hour of dt.\index{hour@\verb,hour,!value (\verb,Date,)}

   [minute dt] returns the minute of dt.\index{minute@\verb,minute,!value (\verb,Date,)}

   [second dt] returns the second of dt.\index{second@\verb,second,!value (\verb,Date,)}

   [weekDay dt] returns the weekday of dt.\index{weekDay@\verb,weekDay,!value (\verb,Date,)}

   [yearDay dt] returns the number of the day in the year of dt.\index{yearDay@\verb,yearDay,!value (\verb,Date,)}
   January 1 is day 0, and December 31 is day 364 (and 365 in leap years).

   [isDst dt] returns SOME(true) if daylight savings time is in effect\index{isDst@\verb,isDst,!value (\verb,Date,)}
   at the date dt; returns SOME(false) if not; and returns NONE if
   this information is unavailable.

   [offset dt] returns NONE if the date dt is in the local time zone;\index{offset@\verb,offset,!value (\verb,Date,)}
   returns SOME t where t is the offset west of UTC otherwise.  Thus
   SOME(Time.zeroTime) is UTC.

   [compare(dt1, dt2)] returns LESS, EQUAL, or GREATER, according as\index{compare@\verb,compare,!value (\verb,Date,)}
   date dt1 precedes, equals, or follows dt2 in time.
   Lexicographically compares the dates.  Ignores timezone offset and
   DST.  Does not detect invalid dates.

   [toString dt] returns a 24 character string representing the date dt\index{toString@\verb,toString,!value (\verb,Date,)}
   in the following format:   
                       Wed Mar  8 19:06:45 1995
   The result may be wrong if the date is not representable as a
   Time.time value.  Raises Date if dt is an invalid date.
   Corresponds to the ANSI C function `asctime'.

   [fmt fmtstr dt] formats the date dt according to the format string\index{fmt@\verb,fmt,!value (\verb,Date,)}
   fmtstr.  The format string has the same meaning as with the ANSI C
   function `strftime'.  These ANSI C format codes should work on all
   platforms:

      \verb"%"a  abbreviated weekday name (e.g. "Mon")
      \verb"%"A  full weekday name (e.g. "Monday")
      \verb"%"b  abbreviated month name (e.g. "Oct")
      \verb"%"B  full month name (e.g. "October")
      \verb"%"c  date and time (e.g. "Dec  2 06:55:15 1979")
      \verb"%"d  day of month (01..31)
      \verb"%"H  hour (00..23)
      \verb"%"I  hour (01..12)
      \verb"%"j  day of year (001..366)
      \verb"%"m  month number (01..12)
      \verb"%"M  minutes (00..59)
      \verb"%"p  locale's equivalent of a.m./p.m.
      \verb"%"S  seconds (00..61, allowing for leap seconds)
      \verb"%"U  week number (00..53), with Sunday as the first day of week 01
      \verb"%"w  day of week, with 0 representing Sunday (0..6)
      \verb"%"W  week number (00..53), with Monday as the first day of week 01
      \verb"%"x  locale's appropriate date representation
      \verb"%"y  year of century (00..99)
      \verb"%"Y  year including century (e.g. 1997)
      \verb"%"Z  time zone name if it exists; otherwise the empty string
      \verb"%"\verb"%"  the percent character   

   Example: The current local date in ISO format (e.g. 1998\verb"-"04\verb"-"06) can
   be obtained by using: 
        fmt "\verb"%"Y\verb"-"\verb"%"m\verb"-"\verb"%"d" (fromTimeLocal (Time.now ()))

   [fromString s] scans a 24\verb"-"character date from the string s, after\index{fromString@\verb,fromString,!value (\verb,Date,)}
   possible initial whitespace (blanks, tabs, newlines).  The format
   of the string must be as produced by toString.  The fields isDst
   and offset in the resulting date will be NONE.  No check of the
   consistency of the date (weekday, date in the month, ...) is
   performed. 

   [scan getc src] scans a 24\verb"-"character date from the stream src,\index{scan@\verb,scan,!value (\verb,Date,)}
   using the stream accessor getc.  Otherwise works as fromString.  In
   case of success, returns SOME(date, rst) where date is the scanned
   date and rst is the remainder of the stream; otherwise returns
   NONE.

   [fromTimeLocal t] returns the local date at (UTC) time t.  The\index{fromTimeLocal@\verb,fromTimeLocal,!value (\verb,Date,)}
   resulting date will have offset = NONE.  The fields year, month,
   day, hour, minute, and second are as expected.  The resulting isDst
   may be NONE if the system cannot determine whether daylight savings
   time is in effect at the given time.  Corresponds to the ANSI C
   function `localtime'.

   [fromTimeUniv t] is similar to fromTime, but returns the UTC date\index{fromTimeUniv@\verb,fromTimeUniv,!value (\verb,Date,)}
   at (UTC) time t.  The resulting date will have offset = SOME
   Time.zeroTime.  Corresponds to the ANSI C function `gmtime'.

   [toTime dt] returns the (UTC) time corresponding to the date dt.\index{toTime@\verb,toTime,!value (\verb,Date,)}
   Uses the isDst time field if it is present (SOME _) and cannot be
   calculated from the given date.  May raise Date if the given date
   is invalid.  Raises Time.Time if the Date cannot be represented as
   a Time.time value.  At least the dates in the interval 1970\verb"-"2030
   can be represented as Time.time values.  Corresponds to the ANSI C
   function `mktime'.

   [localOffset ()] is the local time zone offset west of UTC.  \index{localOffset@\verb,localOffset,!value (\verb,Date,)}
   It holds that 0 hours \verb"<"= localOffset () \verb"<" 24 hours.
\end{longprogram}
\index{Date@\verb,Date, (structure)|)}\newpage

\section*{Module Dynarray}
\index{Dynarray@\verb,Dynarray, (structure)|(}
\markboth{\MakeUppercase{Dynarray}}{\MakeUppercase{Dynarray}}
\addcontentsline{toc}{section}{Dynarray}
\begin{longprogram}
{\itshape{}Dynarray \verb"-"\verb"-" polymorphic dynamic arrays a la SML/NJ library }

type 'a array\index{array@\verb,array,!type (\verb,Dynarray,)}

val array    : int * '_a \verb"-"\verb">" '_a array\index{array@\verb,array,!value (\verb,Dynarray,)}
val subArray : '_a array * int * int \verb"-"\verb">" '_a array\index{subArray@\verb,subArray,!value (\verb,Dynarray,)}
val fromList : '_a list * '_a \verb"-"\verb">" '_a array\index{fromList@\verb,fromList,!value (\verb,Dynarray,)}
val tabulate : int * (int \verb"-"\verb">" '_a) * '_a \verb"-"\verb">" '_a array\index{tabulate@\verb,tabulate,!value (\verb,Dynarray,)}
val sub      : 'a array * int \verb"-"\verb">" 'a\index{sub@\verb,sub,!value (\verb,Dynarray,)}
val update   : '_a array * int * '_a  \verb"-"\verb">" unit\index{update@\verb,update,!value (\verb,Dynarray,)}
val default  : 'a array \verb"-"\verb">" 'a\index{default@\verb,default,!value (\verb,Dynarray,)}
val bound    : 'a array \verb"-"\verb">" int\index{bound@\verb,bound,!value (\verb,Dynarray,)}

\separatingline
   ['ty array] is the type of one\verb"-"dimensional, mutable, zero\verb"-"based\index{array@\verb,array,!type (\verb,Dynarray,)}
   unbounded arrays with elements of type 'ty.  Type 'ty array does
   not admit equality.

   [array(n, d)] returns a dynamic array, all of whose elements are\index{array@\verb,array,!value (\verb,Dynarray,)}
   initialized to the default d.  The parameter n is used as a hint of the 
   upper bound on non\verb"-"default elements.  Raises Size if n \verb"<" 0.

   [subArray(a, m, n)] returns a new array with the same default\index{subArray@\verb,subArray,!value (\verb,Dynarray,)}
   value as a, and whose values in the range [0,n\verb"-"m] equal the
   values in a in the range [m,n].  Raises the exception Size if n \verb"<" m.

   [fromList (xs, d)] returns an array whose first elements are\index{fromList@\verb,fromList,!value (\verb,Dynarray,)}
   those of [xs], and the rest are the default d.

   [tabulate(n, f, d)] returns a new array whose first n elements \index{tabulate@\verb,tabulate,!value (\verb,Dynarray,)}
   are f 0, f 1, ..., f (n\verb"-"1), created from left to right, and whose 
   remaining elements are the default d.  Raises Size if n \verb"<" 0.

   [sub(a, i)] returns the i'th element of a, counting from 0.\index{sub@\verb,sub,!value (\verb,Dynarray,)}
   Raises Subscript if i \verb"<" 0.

   [update(a, i, x)] destructively replaces the i'th element of a by x.\index{update@\verb,update,!value (\verb,Dynarray,)}
   Raises Subscript if i \verb"<" 0.

   [default a] returns the default value of the array a.\index{default@\verb,default,!value (\verb,Dynarray,)}

   [bound a] returns an upper bound on the indices of non\verb"-"default values.\index{bound@\verb,bound,!value (\verb,Dynarray,)}
\end{longprogram}
\index{Dynarray@\verb,Dynarray, (structure)|)}\newpage

\section*{Module Dynlib}
\index{Dynlib@\verb,Dynlib, (structure)|(}
\markboth{\MakeUppercase{Dynlib}}{\MakeUppercase{Dynlib}}
\addcontentsline{toc}{section}{Dynlib}
\begin{longprogram}
{\itshape{}Dynlib \verb"-"\verb"-" dynamic linking with foreign functions }

type dlHandle\index{dlHandle@\verb,dlHandle,!type (\verb,Dynlib,)}
type symHandle\index{symHandle@\verb,symHandle,!type (\verb,Dynlib,)}
    
exception Closed\index{Closed@\verb,Closed,!exception (\verb,Dynlib,)}

datatype flag = RTLD_LAZY | RTLD_NOW\index{flag@\verb,flag,!type (\verb,Dynlib,)}
val dlopen  : \verb"{" lib : string, flag : flag, global : bool \verb"}" \verb"-"\verb">" dlHandle\index{dlopen@\verb,dlopen,!value (\verb,Dynlib,)}
val dlsym   : dlHandle \verb"-"\verb">" string \verb"-"\verb">" symHandle\index{dlsym@\verb,dlsym,!value (\verb,Dynlib,)}
val dlclose : dlHandle \verb"-"\verb">" unit\index{dlclose@\verb,dlclose,!value (\verb,Dynlib,)}

val var  : symHandle \verb"-"\verb">" 'b                            \index{var@\verb,var,!value (\verb,Dynlib,)}
val app1 : symHandle \verb"-"\verb">" 'a1 \verb"-"\verb">" 'b                     \index{app1@\verb,app1,!value (\verb,Dynlib,)}
val app2 : symHandle \verb"-"\verb">" 'a1 \verb"-"\verb">" 'a2 \verb"-"\verb">" 'b              \index{app2@\verb,app2,!value (\verb,Dynlib,)}
val app3 : symHandle \verb"-"\verb">" 'a1 \verb"-"\verb">" 'a2 \verb"-"\verb">" 'a3 \verb"-"\verb">" 'b       \index{app3@\verb,app3,!value (\verb,Dynlib,)}
val app4 : symHandle \verb"-"\verb">" 'a1 \verb"-"\verb">" 'a2 \verb"-"\verb">" 'a3 \verb"-"\verb">" 'a4 \verb"-"\verb">" 'b\index{app4@\verb,app4,!value (\verb,Dynlib,)}
val app5 : symHandle \verb"-"\verb">" 'a1 \verb"-"\verb">" 'a2 \verb"-"\verb">" 'a3 \verb"-"\verb">" 'a4 \verb"-"\verb">" 'a5 \verb"-"\verb">" 'b\index{app5@\verb,app5,!value (\verb,Dynlib,)}

\separatingline
   Structure Dynlib provides dynamic loading and calling of C
   functions, using the dlfcn interface.  A dynamic library is a
   collection of symbols (C variables and functions).  

   An ML value passed to or returned from a symbol has type `value' as
   defined in src/runtime/mlvalues.h.  The C functions should use the
   macroes defined there to access and produce ML values.  When
   writing a C function, remember that the garbage collector may be
   activated whenever you allocate an ML value.  Also, remember that
   the garbage collector may move values from the young heap to the
   old one, so that a C pointer pointing into the ML heap may need to
   be updated. Use the Push_roots and Pop_roots macroes to achieve
   this.

   [dlHandle] is the type of dynamic library handles.  A dynamic\index{dlHandle@\verb,dlHandle,!type (\verb,Dynlib,)}
   library handle is created by opening a dynamic library using
   dlopen.  This will load the library into the runtime system.  The
   dynamic library handle is used for accessing symbols in that
   library.  The library may be closed and removed from the runtime
   system using dlclose.

   The same library may be opened more than once, resulting in
   different library handles.  The physical library will be loaded
   only once, though, and will remain in the runtime system until all
   handles to the library have been closed.

   [symHandle] is the type of symbol handles.  A symbol handle is used\index{symHandle@\verb,symHandle,!type (\verb,Dynlib,)}
   to access a symbol (variable or function) in the dynamic library,
   using the functions var, app1, app2, ..., app5.  Type safety is the
   responsibility of the programmer; the runtime system performs no
   type checking.  Hence you are advised to add explicit types
   whenever you define an ML function in terms of var, app1, ..., app5.

   How to create a dynamically loadable library
   \verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"
   Assume file "xyz.c" contains your C functions.  

   To compile xyz.c into xyz.o and then create a dynamic library 
   libxyz.so from xyz.o:

     Under Linux and OSF/1 (Digital Unix):
        gcc \verb"-"c \verb"-"o xyz.o xyz.c 
        ld \verb"-"shared \verb"-"o libxyz.so xyz.o
     Under Solaris (ignore the warnings from ld):
        gcc \verb"-"c \verb"-"o xyz.o xyz.c 
        ld \verb"-"G \verb"-"B symbolic \verb"-"z nodefs \verb"-"o libxyz.so xyz.o
     Under HP\verb"-"UX:
        gcc \verb"-"fPIC \verb"-"c \verb"-"o xyz.o xyz.c 
        ld \verb"-"b \verb"-"B symbolic \verb"-"E \verb"-"o libxyz.so xyz.o

   If "xyz.o" depends on another library "libabc.a" you may link the
   required functions into libxyz.so just by adding \verb"-"labc or libabc.a
   to the above linker command.

   If "xyz.o" depends on another dynamic library "libabc.so" you may
   specify this by adding \verb"-"labc to the above linker command.  Then
   Dynlib.dlopen will automatically load libabc.so before libxyz.so.


   [dlopen \verb"{" lib, flag, global \verb"}"] will load and open the library in\index{dlopen@\verb,dlopen,!value (\verb,Dynlib,)}
   file `lib', returning a handle to it.  Libraries are usually
   specified just by file name, leaving out the directory path.
   Linux/Unix\verb"-"specific information: Libraries are searched for in
   those directories mentioned in LD_LIBRARY_PATH, those mentioned in
   /etc/ld.so.cache, in /usr/lib and /lib.  (Note that
   /etc/ld.so.cache is created from /etc/ld.so.conf by running
   ldconfig; you must be superuser to do that).
        If `global' is true, then the library's global symbols are
   made available for other libraries subsequently loaded.

   [flag] is the type of library loading modes: RTLD_LAZY and RTLD_NOW.  \index{flag@\verb,flag,!type (\verb,Dynlib,)}

   [RTLD_LAZY] specifies that only symbol relocations will be\index{RTLD_LAZY@\verb,RTLD_LAZY,!constructor (\verb,Dynlib,)}
   performed when calling dlopen, whereas function relocations will be
   performed later when a function is invoked for the first time (if
   ever).  This is the normal situation.

   [RTLD_NOW] specifies that all function relocations must be\index{RTLD_NOW@\verb,RTLD_NOW,!constructor (\verb,Dynlib,)}
   performed immediately, also for functions that will never be
   called.  This checks that all functions are defined, but may waste
   some time.

   [dlsym dlh nam] returns a symbol handle for the symbol called `nam'\index{dlsym@\verb,dlsym,!value (\verb,Dynlib,)}
   in the library associated with dlh.  Raises Closed if dlh has been
   closed.

   [dlclose dlh] closes the library handle and deallocates the library\index{dlclose@\verb,dlclose,!value (\verb,Dynlib,)}
   if there are no more open handles to this library.

   The following functions raise Closed if the associated handle has
   been closed.

   [var sym] returns the value of the C variable associated with sym.\index{var@\verb,var,!value (\verb,Dynlib,)}

   [app1 sym arg1] applies the C function associated with sym to arg1.\index{app1@\verb,app1,!value (\verb,Dynlib,)}

   [app2 sym arg1 arg2] applies the C function associated with sym to\index{app2@\verb,app2,!value (\verb,Dynlib,)}
   (arg1, arg2).

   [app3 sym arg1 arg2 arg3] applies the C function associated with\index{app3@\verb,app3,!value (\verb,Dynlib,)}
   sym to (arg1, arg2, arg3).

   [app4 sym arg1 arg2 arg3 arg4] applies the C function associated\index{app4@\verb,app4,!value (\verb,Dynlib,)}
   with sym to (arg1, arg2, arg3, arg4).

   [app5 sym arg1 arg2 arg3 arg4 arg5] applies the C function\index{app5@\verb,app5,!value (\verb,Dynlib,)}
   associated with sym to (arg1, arg2, arg3, arg4, arg5). 
\end{longprogram}
\index{Dynlib@\verb,Dynlib, (structure)|)}\newpage

\section*{Module FileSys}
\index{FileSys@\verb,FileSys, (structure)|(}
\markboth{\MakeUppercase{FileSys}}{\MakeUppercase{FileSys}}
\addcontentsline{toc}{section}{FileSys}
\begin{longprogram}
{\itshape{}OS.FileSys \verb"-"\verb"-" SML Basis Library }

type dirstream\index{dirstream@\verb,dirstream,!type (\verb,FileSys,)}

val openDir   : string \verb"-"\verb">" dirstream\index{openDir@\verb,openDir,!value (\verb,FileSys,)}
val readDir   : dirstream \verb"-"\verb">" string option\index{readDir@\verb,readDir,!value (\verb,FileSys,)}
val rewindDir : dirstream \verb"-"\verb">" unit\index{rewindDir@\verb,rewindDir,!value (\verb,FileSys,)}
val closeDir  : dirstream \verb"-"\verb">" unit\index{closeDir@\verb,closeDir,!value (\verb,FileSys,)}

val chDir     : string \verb"-"\verb">" unit\index{chDir@\verb,chDir,!value (\verb,FileSys,)}
val getDir    : unit \verb"-"\verb">" string\index{getDir@\verb,getDir,!value (\verb,FileSys,)}
val mkDir     : string \verb"-"\verb">" unit\index{mkDir@\verb,mkDir,!value (\verb,FileSys,)}
val rmDir     : string \verb"-"\verb">" unit\index{rmDir@\verb,rmDir,!value (\verb,FileSys,)}
val isDir     : string \verb"-"\verb">" bool\index{isDir@\verb,isDir,!value (\verb,FileSys,)}

val realPath  : string \verb"-"\verb">" string\index{realPath@\verb,realPath,!value (\verb,FileSys,)}
val fullPath  : string \verb"-"\verb">" string\index{fullPath@\verb,fullPath,!value (\verb,FileSys,)}
val isLink    : string \verb"-"\verb">" bool\index{isLink@\verb,isLink,!value (\verb,FileSys,)}
val readLink  : string \verb"-"\verb">" string\index{readLink@\verb,readLink,!value (\verb,FileSys,)}

val modTime   : string \verb"-"\verb">" Time.time\index{modTime@\verb,modTime,!value (\verb,FileSys,)}
val setTime   : string * Time.time option \verb"-"\verb">" unit\index{setTime@\verb,setTime,!value (\verb,FileSys,)}
val remove    : string \verb"-"\verb">" unit\index{remove@\verb,remove,!value (\verb,FileSys,)}
val rename    : \verb"{"old: string, new: string\verb"}" \verb"-"\verb">" unit\index{rename@\verb,rename,!value (\verb,FileSys,)}

datatype access = A_READ | A_WRITE | A_EXEC\index{access@\verb,access,!type (\verb,FileSys,)}
val access    : string * access list \verb"-"\verb">" bool\index{access@\verb,access,!value (\verb,FileSys,)}

val fileSize  : string \verb"-"\verb">" int\index{fileSize@\verb,fileSize,!value (\verb,FileSys,)}

val tmpName   : unit \verb"-"\verb">" string\index{tmpName@\verb,tmpName,!value (\verb,FileSys,)}

eqtype file_id\index{file_id@\verb,file_id,!type (\verb,FileSys,)}
val fileId    : string \verb"-"\verb">" file_id\index{fileId@\verb,fileId,!value (\verb,FileSys,)}
val hash      : file_id \verb"-"\verb">" word\index{hash@\verb,hash,!value (\verb,FileSys,)}
val compare   : file_id * file_id \verb"-"\verb">" order\index{compare@\verb,compare,!value (\verb,FileSys,)}

\separatingline
   These functions operate on the file system.  They raise OS.SysErr
   in case of errors.

   [openDir p] opens directory p and returns a directory stream for\index{openDir@\verb,openDir,!value (\verb,FileSys,)}
   use by readDir, rewindDir, and closeDir.  Subsequent calls to
   readDir will return the directory entries in some unspecified
   order.

   [readDir dstr] returns SOME(s), consuming an entry s from the\index{readDir@\verb,readDir,!value (\verb,FileSys,)}
   directory stream if it is non\verb"-"empty; returns NONE if it is empty
   (when all directory entries have been read).  Only entries distinct
   from the parent arc and the current arc (that is, .. and . in Unix,
   DOS, and Windows; see the Path structure) will be returned.  

   [rewindDir dstr] resets the directory stream as if it had just been\index{rewindDir@\verb,rewindDir,!value (\verb,FileSys,)}
   opened.

   [closeDir dstr] closes the directory stream.  All subsequent\index{closeDir@\verb,closeDir,!value (\verb,FileSys,)}
   operations on the stream will raise OS.SysErr.

   [chDir p] changes the current working directory to p.  This affects\index{chDir@\verb,chDir,!value (\verb,FileSys,)}
   calls to the functions use, load, compile in the interactive
   system, as well as all functions defined in this library.  If p
   specifies a volume name, then this command also changes the current
   volume (relevant under DOS, Windows, OS/2, etc.).  

   [getDir ()] returns the name of the current working directory.\index{getDir@\verb,getDir,!value (\verb,FileSys,)}

   [mkDir p] creates directory p on the file system.\index{mkDir@\verb,mkDir,!value (\verb,FileSys,)}

   [rmDir p] removes directory p from the file system.\index{rmDir@\verb,rmDir,!value (\verb,FileSys,)}

   [isDir p] tests whether p is a directory.\index{isDir@\verb,isDir,!value (\verb,FileSys,)}

   [fullPath p] returns a canonical form of path p, where all\index{fullPath@\verb,fullPath,!value (\verb,FileSys,)}
   occurrences of the arcs ".", "..", "" have been expanded or
   removed, and (under Unix) symbolic links have been fully expanded.
   Raises SysErr if a directory on the path, or the file or directory
   named, does not exist or is not accessible, or if there is a link
   loop.

   [realPath p] behaves as fullPath(p) if p is absolute.  If p is\index{realPath@\verb,realPath,!value (\verb,FileSys,)}
   relative and on the same volume as the current working directory,
   it returns a canonical path relative to the current working
   directory, where superfluous occurrences of the arcs ".", "..", ""
   have been removed, and (under Unix) symbolic links have been fully
   expanded.  Raises SysErr if a directory on the path, or the file or
   directory named, does not exist or is not accessible, or if there
   is a link loop.  Raises Path if p is relative and on a different
   volume than the current working directory.

   [isLink p] returns true if p names a symbolic link.  Raises SysErr\index{isLink@\verb,isLink,!value (\verb,FileSys,)}
   if the file does not exist or there is an access violation.  On
   operating systems without symbolic links, it returns false, or
   raises SysErr if the file does not exist or there is an access
   violation.

   [readLink p] returns the contents of the symbolic link p.  Raises\index{readLink@\verb,readLink,!value (\verb,FileSys,)}
   SysErr if p does not exist or is not a symbolic link, or there is
   an access violation.  On operating systems without symbolic links,
   it raises SysErr.

   [modTime p] returns the modification time of file p.\index{modTime@\verb,modTime,!value (\verb,FileSys,)}

   [setTime (p, tmopt)] sets the modification and access time of file\index{setTime@\verb,setTime,!value (\verb,FileSys,)}
   p.  If tmopt is SOME t, then the time t is used; otherwise the
   current time, that is, Time.now(), is used.

   [remove p] deletes file p from the file system.\index{remove@\verb,remove,!value (\verb,FileSys,)}

   [rename \verb"{"old, new\verb"}"] changes the name of file `old' to `new'.\index{rename@\verb,rename,!value (\verb,FileSys,)}

   [access] is the type of access permissions:\index{access@\verb,access,!type (\verb,FileSys,)}

   [A_READ] specifies read access.\index{A_READ@\verb,A_READ,!constructor (\verb,FileSys,)}

   [A_WRITE] specifies write access.\index{A_WRITE@\verb,A_WRITE,!constructor (\verb,FileSys,)}

   [A_EXEC] specifies permission to execute the file (or directory).\index{A_EXEC@\verb,A_EXEC,!constructor (\verb,FileSys,)}

   [access (p, accs)] tests the access permissions of file p,\index{access@\verb,access,!value (\verb,FileSys,)}
   expanding symbolic links as necessary.  If the list accs of
   required access permission is empty, it tests whether p exists.  If
   accs contains A_READ, A_WRITE, or A_EXEC, respectively, it tests
   whether the user process has read, write, or execute permission for
   the file.  
       Under Unix, the access test is done with the `real' user
   id and group id (as opposed to the `effective' user id and group
   id) of the user process.  Hence access("file", [A_READ]) may return
   false, yet the file may be readable by the process, in case the
   effective user id or group id has been changed by setuid.

   [fileSize p] return the size, in bytes, of the file p.  Raises SysErr \index{fileSize@\verb,fileSize,!value (\verb,FileSys,)}
   if p does not exist or its directory is not accessible.

   [tmpName ()] returns a file name suitable for creating a fresh\index{tmpName@\verb,tmpName,!value (\verb,FileSys,)}
   temporary file.  Note that there is no guarantee that the file name
   will be unique, since a file of that name may be created between
   the call to tmpName and a subsequent call to openOut which creates
   the file.  The file name will be absolute, usually of the form
   /tmp/xxxxxxxx provided by POSIX tmpnam (3).

   [file_id] is the type of unique identities of file system objects\index{file_id@\verb,file_id,!type (\verb,FileSys,)}
   (including device ids and volume ids, but possibly insensitive to
   volume changes on removable volumes, such as tapes and diskettes).
   The set of file ids is equipped with a total linear order.

   [fileId p] returns the file_id of the file system object named by\index{fileId@\verb,fileId,!value (\verb,FileSys,)}
   path p.  It holds that fileId p1 = fileId p2 if and only if p1 and
   p2 name the same file system object.
   
   [hash fid] returns a hashvalue for fid, suitable for use in a\index{hash@\verb,hash,!value (\verb,FileSys,)}
   hashtable of file ids (and hence files).  
   If fid1 = fid2 then hash fid1 = hash fid2.

   [compare (fid1, fid2)] returns LESS, EQUAL, or GREATER, according\index{compare@\verb,compare,!value (\verb,FileSys,)}
   as fid1 precedes, equals, or follows fid2 in the total linear order
   on file ids.  This is suitable for e.g. an ordered binary tree of
   file ids (and hence files).  
\end{longprogram}
\index{FileSys@\verb,FileSys, (structure)|)}\newpage

\section*{Module Gdbm}
\index{Gdbm@\verb,Gdbm, (structure)|(}
\markboth{\MakeUppercase{Gdbm}}{\MakeUppercase{Gdbm}}
\addcontentsline{toc}{section}{Gdbm}
\begin{longprogram}
{\itshape{}Gdbm \verb"-"\verb"-" GNU gdbm persistent string hashtables \verb"-"\verb"-" requires Dynlib }

type table \index{table@\verb,table,!type (\verb,Gdbm,)}

datatype openmode =\index{openmode@\verb,openmode,!type (\verb,Gdbm,)}
    READER                              {\itshape{}read\verb"-"only access (nonexclusive) }
  | WRITER                              {\itshape{}read/write, table must exist    }
  | WRCREAT                             {\itshape{}read/write, create if necessary }
  | NEWDB                               {\itshape{}read/write, create empty table  }

type datum = string\index{datum@\verb,datum,!type (\verb,Gdbm,)}

exception NotFound\index{NotFound@\verb,NotFound,!exception (\verb,Gdbm,)}
exception AlreadyThere\index{AlreadyThere@\verb,AlreadyThere,!exception (\verb,Gdbm,)}
exception NotWriter\index{NotWriter@\verb,NotWriter,!exception (\verb,Gdbm,)}
exception Closed\index{Closed@\verb,Closed,!exception (\verb,Gdbm,)}
exception GdbmError of string\index{GdbmError@\verb,GdbmError,!exception (\verb,Gdbm,)}

val withtable  : string * openmode \verb"-"\verb">" (table \verb"-"\verb">" 'a) \verb"-"\verb">" 'a\index{withtable@\verb,withtable,!value (\verb,Gdbm,)}
val withtables : (string * openmode) list \verb"-"\verb">" (table list \verb"-"\verb">" 'a) \verb"-"\verb">" 'a\index{withtables@\verb,withtables,!value (\verb,Gdbm,)}
val add        : table \verb"-"\verb">" datum * datum \verb"-"\verb">" unit \index{add@\verb,add,!value (\verb,Gdbm,)}
val insert     : table \verb"-"\verb">" datum * datum \verb"-"\verb">" unit\index{insert@\verb,insert,!value (\verb,Gdbm,)}
val find       : table \verb"-"\verb">" datum \verb"-"\verb">" datum\index{find@\verb,find,!value (\verb,Gdbm,)}
val peek       : table \verb"-"\verb">" datum \verb"-"\verb">" datum option\index{peek@\verb,peek,!value (\verb,Gdbm,)}
val hasKey     : table \verb"-"\verb">" datum \verb"-"\verb">" bool\index{hasKey@\verb,hasKey,!value (\verb,Gdbm,)}
val remove     : table \verb"-"\verb">" datum \verb"-"\verb">" unit\index{remove@\verb,remove,!value (\verb,Gdbm,)}
val listKeys   : table \verb"-"\verb">" datum list\index{listKeys@\verb,listKeys,!value (\verb,Gdbm,)}
val numItems   : table \verb"-"\verb">" int\index{numItems@\verb,numItems,!value (\verb,Gdbm,)}
val listItems  : table \verb"-"\verb">" (datum * datum) list\index{listItems@\verb,listItems,!value (\verb,Gdbm,)}
val app        : (datum * datum \verb"-"\verb">" unit) \verb"-"\verb">" table \verb"-"\verb">" unit\index{app@\verb,app,!value (\verb,Gdbm,)}
val map        : (datum * datum \verb"-"\verb">" 'a) \verb"-"\verb">" table \verb"-"\verb">" 'a list\index{map@\verb,map,!value (\verb,Gdbm,)}
val fold       : (datum * datum * 'a \verb"-"\verb">" 'a) \verb"-"\verb">" 'a \verb"-"\verb">" table \verb"-"\verb">" 'a\index{fold@\verb,fold,!value (\verb,Gdbm,)}
val fastwrite  : bool ref    \index{fastwrite@\verb,fastwrite,!value (\verb,Gdbm,)}
val reorganize : table \verb"-"\verb">" unit\index{reorganize@\verb,reorganize,!value (\verb,Gdbm,)}

\separatingline
   [table] is the type of an opened table.  A value of type table can\index{table@\verb,table,!type (\verb,Gdbm,)}
   be used only in the argument f to the withtable function.  This
   makes sure that the table is closed after use.

   [openmode] is the type of opening modes.  Read\verb"-"only access (READER)\index{openmode@\verb,openmode,!type (\verb,Gdbm,)}
   is non\verb"-"exclusive; read/write access (WRITER, WRCREAT, NEWDB) is
   exclusive.
    
   [withtable (nam, mod) f] first opens the table db in file nam with\index{withtable@\verb,withtable,!value (\verb,Gdbm,)}
   mode mod, then applies f to db, then closes db.  Makes sure to
   close db even if an exception is raised during the evaluation of
   f(db).  Raises GdbmError with an informative message in case the
   table cannot be opened.  E.g. the table cannot be opened for
   reading if already opened for writing, and cannot be opened for
   writing if already opened for reading.

   A table is only guaranteed to work properly if created by withtable
   using open modes WRCREAT or NEWDB.  If you create a table by
   creating and then opening an empty file, then numItems, listKeys,
   listItems, etc. will raise an exception.

   [withtables nammod f], where nammod = [(nam1, mod1), ..., (namn, modn)], \index{withtables@\verb,withtables,!value (\verb,Gdbm,)}
   is equivalent to 
        withtable (nam1, mod1) (fn db1 =\verb">" 
            withtable (nam2, mod2) (fn db2 =\verb">" 
                ...
                    f [db1, db2, ...]))
   That is, first opens the databases db1, db2, ... in that order in
   files nam1, nam2, ... with modes mod1, mod2, ..., then applies f to
   [db1, db2, ...], and finally closes [db1, db2, ...].  Makes sure to
   close all databases even if an exception is raised during the
   opening of db1, db2, ... or during the evaluation of f[db1, db2, ...].
 
   [add db (k,v)] adds the pair (k, v) to db.  Raises AlreadyThere if\index{add@\verb,add,!value (\verb,Gdbm,)}
   there is a pair (k, _) in db already.  Raises NotWriter if db is
   not opened in write mode.

   [insert db (k, v)] adds the pair (k, v) to db, replacing any pair\index{insert@\verb,insert,!value (\verb,Gdbm,)}
   (k, _) at k if present.  Raises NotWriter if db is not opened in
   write mode.

   [find db k] returns v if the pair (k, v) is in db; otherwise\index{find@\verb,find,!value (\verb,Gdbm,)}
   raises NotFound.

   [peek db k] returns SOME v if the pair (k, v) is in db; otherwise\index{peek@\verb,peek,!value (\verb,Gdbm,)}
   returns NONE.

   [hasKey db k] returns true if there is a pair (k, _) in db;\index{hasKey@\verb,hasKey,!value (\verb,Gdbm,)}
   otherwise returns false.

   [remove db k] deletes the pair (k, _) from the table if present;\index{remove@\verb,remove,!value (\verb,Gdbm,)}
   otherwise raises NotFound.  Raises NotWriter if db is not opened in
   write mode.

   [listKeys db] returns a list of all keys in db in an unspecified\index{listKeys@\verb,listKeys,!value (\verb,Gdbm,)}
   order.  

   [numItems db] is the number of (key, value) pairs in db.\index{numItems@\verb,numItems,!value (\verb,Gdbm,)}
   Equivalent to length(listKeys db).

   [listItems db] returns a list of all (key, value) pairs in db in some \index{listItems@\verb,listItems,!value (\verb,Gdbm,)}
   order.  Equivalent to 
        List.map (fn key =\verb">" (key, find(db,key))) (listKeys db)

   [app f db] is equivalent to List.app f (listItems db), provided the\index{app@\verb,app,!value (\verb,Gdbm,)}
   function f does not change the set of keys in the table.
   Otherwise the effect is unpredictable.

   [map f db] is equivalent to List.map f (listItems db), provided the\index{map@\verb,map,!value (\verb,Gdbm,)}
   function f does not change the set of keys in the table.
   Otherwise the result and effect are unpredictable.
   
   [fold f a db] is equivalent to \index{fold@\verb,fold,!value (\verb,Gdbm,)}
        List.foldr (fn ((k, v), r) =\verb">" f(k, v, r)) a (listItems db)
   provided the function f does not change the set of keys in the 
   table. Otherwise the result and effect are unpredictable.

   [fastwrite] can be set to speed up writes to a table.  By default,\index{fastwrite@\verb,fastwrite,!value (\verb,Gdbm,)}
   !fastwrite is false and every write to a table will be followed by
   file system synchronization.  This is safe, but slow if you perform
   thousands of writes.  However, if !fastwrite is true when calling
   withtable, then writes may not be followed by synchronization,
   which may speed up writes considerably.  In any case, the file
   system is synchronized before withtable returns.

   [reorganize db] has no visible effect, but may be called after a\index{reorganize@\verb,reorganize,!value (\verb,Gdbm,)}
   lot of deletions to shrink the size of the table file.
\end{longprogram}
\index{Gdbm@\verb,Gdbm, (structure)|)}\newpage

\section*{Module Gdimage}
\index{Gdimage@\verb,Gdimage, (structure)|(}
\markboth{\MakeUppercase{Gdimage}}{\MakeUppercase{Gdimage}}
\addcontentsline{toc}{section}{Gdimage}
\begin{longprogram}
{\itshape{}Gdimage \verb"-"\verb"-" creating PNG images \verb"-"\verb"-" requires Dynlib }

type image\index{image@\verb,image,!type (\verb,Gdimage,)}

type color\index{color@\verb,color,!type (\verb,Gdimage,)}

datatype style = \index{style@\verb,style,!type (\verb,Gdimage,)}
    ColorS of color
  | TransparentS

datatype mode = \index{mode@\verb,mode,!type (\verb,Gdimage,)}
    Color of color
  | Transparent
  | Brushed of image
  | Styled of style vector
  | StyledBrushed of bool vector * image
  | Tiled of image

datatype font = \index{font@\verb,font,!type (\verb,Gdimage,)}
    Tiny 
  | Small
  | MediumBold
  | Large 
  | Giant

type rgb = int * int * int           {\itshape{}RGB color components, 0..255   }\index{rgb@\verb,rgb,!type (\verb,Gdimage,)}
type xy  = int * int                 {\itshape{}points (x, y) and sizes (w, h) }\index{xy@\verb,xy,!type (\verb,Gdimage,)}

val image     : xy \verb"-"\verb">" rgb \verb"-"\verb">" image\index{image@\verb,image,!value (\verb,Gdimage,)}
val fromPng   : string \verb"-"\verb">" image\index{fromPng@\verb,fromPng,!value (\verb,Gdimage,)}
val toPng     : image \verb"-"\verb">" string \verb"-"\verb">" unit\index{toPng@\verb,toPng,!value (\verb,Gdimage,)}
val stdoutPng : image \verb"-"\verb">" unit \index{stdoutPng@\verb,stdoutPng,!value (\verb,Gdimage,)}
val size      : image \verb"-"\verb">" xy\index{size@\verb,size,!value (\verb,Gdimage,)}

val color          : image \verb"-"\verb">" rgb \verb"-"\verb">" color\index{color@\verb,color,!value (\verb,Gdimage,)}
val rgb            : image \verb"-"\verb">" color \verb"-"\verb">" rgb\index{rgb@\verb,rgb,!value (\verb,Gdimage,)}
val htmlcolors     : image \verb"-"\verb">" \verb"{" aqua : color, black : color, blue : color,\index{htmlcolors@\verb,htmlcolors,!value (\verb,Gdimage,)}
                                fuchsia : color, gray : color, 
                                green : color, lime : color, maroon : color,
                                navy : color, olive : color, purple : color,
                                red : color, silver : color, teal : color,
                                white : color, yellow : color \verb"}"
val getTransparent : image \verb"-"\verb">" color option \index{getTransparent@\verb,getTransparent,!value (\verb,Gdimage,)}
val setTransparent : image \verb"-"\verb">" color \verb"-"\verb">" unit\index{setTransparent@\verb,setTransparent,!value (\verb,Gdimage,)}
val noTransparent  : image \verb"-"\verb">" unit \index{noTransparent@\verb,noTransparent,!value (\verb,Gdimage,)}

val drawPixel   : image \verb"-"\verb">" mode \verb"-"\verb">" xy \verb"-"\verb">" unit\index{drawPixel@\verb,drawPixel,!value (\verb,Gdimage,)}
val drawLine    : image \verb"-"\verb">" mode \verb"-"\verb">" xy * xy \verb"-"\verb">" unit\index{drawLine@\verb,drawLine,!value (\verb,Gdimage,)}
val drawRect    : image \verb"-"\verb">" mode \verb"-"\verb">" xy * xy \verb"-"\verb">" unit\index{drawRect@\verb,drawRect,!value (\verb,Gdimage,)}
val fillRect    : image \verb"-"\verb">" mode \verb"-"\verb">" xy * xy \verb"-"\verb">" unit\index{fillRect@\verb,fillRect,!value (\verb,Gdimage,)}
val drawPolygon : image \verb"-"\verb">" mode \verb"-"\verb">" xy vector \verb"-"\verb">" unit\index{drawPolygon@\verb,drawPolygon,!value (\verb,Gdimage,)}
val fillPolygon : image \verb"-"\verb">" mode \verb"-"\verb">" xy vector \verb"-"\verb">" unit\index{fillPolygon@\verb,fillPolygon,!value (\verb,Gdimage,)}
val drawArc     : image \verb"-"\verb">" mode \verb"-"\verb">" \verb"{" c : xy, wh : xy, from : int, to : int \verb"}"\index{drawArc@\verb,drawArc,!value (\verb,Gdimage,)}
                  \verb"-"\verb">" unit
val fill        : image \verb"-"\verb">" mode \verb"-"\verb">" xy \verb"-"\verb">" unit\index{fill@\verb,fill,!value (\verb,Gdimage,)}
val fillBorder  : image \verb"-"\verb">" mode \verb"-"\verb">" xy \verb"-"\verb">" color \verb"-"\verb">" unit\index{fillBorder@\verb,fillBorder,!value (\verb,Gdimage,)}
 
val copy        : \verb"{" src : image, srcxy : xy, srcwh : xy,\index{copy@\verb,copy,!value (\verb,Gdimage,)}
                    dst : image, dstxy : xy \verb"}" \verb"-"\verb">" unit
val copyResize  : \verb"{" src : image, srcxy : xy, srcwh : xy,\index{copyResize@\verb,copyResize,!value (\verb,Gdimage,)}
                    dst : image, dstxy : xy, dstwh : xy \verb"}" \verb"-"\verb">" unit

val char        : image \verb"-"\verb">" color \verb"-"\verb">" font \verb"-"\verb">" xy \verb"-"\verb">" char \verb"-"\verb">" unit\index{char@\verb,char,!value (\verb,Gdimage,)}
val charUp      : image \verb"-"\verb">" color \verb"-"\verb">" font \verb"-"\verb">" xy \verb"-"\verb">" char \verb"-"\verb">" unit\index{charUp@\verb,charUp,!value (\verb,Gdimage,)}
val string      : image \verb"-"\verb">" color \verb"-"\verb">" font \verb"-"\verb">" xy \verb"-"\verb">" string \verb"-"\verb">" unit\index{string@\verb,string,!value (\verb,Gdimage,)}
val stringUp    : image \verb"-"\verb">" color \verb"-"\verb">" font \verb"-"\verb">" xy \verb"-"\verb">" string \verb"-"\verb">" unit\index{stringUp@\verb,stringUp,!value (\verb,Gdimage,)}
val charsize    : font \verb"-"\verb">" xy\index{charsize@\verb,charsize,!value (\verb,Gdimage,)}

\separatingline
   This is an interface to version 1.7.3 of Thomas Boutell's gd image
   package for creating PNG images.

   [image] is the type of images being drawn.  They can be created\index{image@\verb,image,!type (\verb,Gdimage,)}
   from scratch, imported from PNG files, and exported to PNG files.

   All functions correctly clip to the actual size of the image.
   
   [color] is the type of colors.  Currently there can be at most 256\index{color@\verb,color,!constructor (\verb,Gdimage,)}\index{color@\verb,color,!type (\verb,Gdimage,)}
   different colors in an image.

   [style] is the type of drawing styles.  A style is either a color,\index{style@\verb,style,!type (\verb,Gdimage,)}
   or transparent.

   [mode] is the type of drawing modes for line drawing and filling.  \index{mode@\verb,mode,!type (\verb,Gdimage,)}
   It may be one of
        Color c         where c is a color
        Transparent
        Brushed img     for line drawing using the given image as brush
        Styled stys     for line drawing, cyclically using the styles 
                        in the given vector to create a dashed line
        StyledBrushed (vis, img) 
                        for line drawing, using the given image as a brush,
                        cyclically switching it on and off according to the 
                        given bool vector
        Tiled img       for filling, using the given image as a tile

   [font] is the type of fonts: Tiny, Small, MediumBold, Large, Giant\index{font@\verb,font,!type (\verb,Gdimage,)}

   [rgb] is the type of (r, g, b) triples, where the components\index{rgb@\verb,rgb,!type (\verb,Gdimage,)}
   indicate color intensity as an integer value in the range 0..255.

   [xy] is the type of pairs, used for (x, y) coordinates and to\index{xy@\verb,xy,!type (\verb,Gdimage,)}
   indicate dimensions (width, height).  The origin (0, 0) is the
   upper left\verb"-"hand corner of the image.  The x coordinates increase to
   the right; the y coordinates increase downwards.

   [image (w, h) rgb] creates a new empty image with size (w, h) and\index{image@\verb,image,!value (\verb,Gdimage,)}
   the background color rgb.  Raises Fail if the image cannot be
   created.

   [fromPng filename] reads an image from the given PNG file.  Raises\index{fromPng@\verb,fromPng,!value (\verb,Gdimage,)}
   Fail if the file does not exist or does not contain a PNG image.

   [size img] returns (w, h) where w is the width and h the height of\index{size@\verb,size,!value (\verb,Gdimage,)}
   img.

   [toPng img filename] write the image to the given file in PNG\index{toPng@\verb,toPng,!value (\verb,Gdimage,)}
   format.

   [stdoutPng img] writes the image to standard output in PNG format,\index{stdoutPng@\verb,stdoutPng,!value (\verb,Gdimage,)}
   preceded by the HTTP header "Content\verb"-"type: image/png\verb"\"n\verb"\"n".  Useful
   in CGI scripts.

   [color img rgb] returns the color code corresponding to rgb in the\index{color@\verb,color,!constructor (\verb,Gdimage,)}\index{color@\verb,color,!value (\verb,Gdimage,)}
   color table of img.  Reuses the color code if it has already been
   allocated; otherwise allocates the color if possible; otherwise
   returns an approximation to the color rgb.

   [htmlcolors im] returns a record containing the 16 standard HTML\index{htmlcolors@\verb,htmlcolors,!value (\verb,Gdimage,)}
   colors: aqua, black, blue, fuchsia, gray, green, lime, maroon,
   navy, olive, purple, red, silver, teal, white, yellow.  This call
   will allocate all these colors in the color table of the image,
   even if you do not use all of them.

   [rgb img color] returns (r, g, b) where r, g, b are the component\index{rgb@\verb,rgb,!value (\verb,Gdimage,)}
   intensities of the given color in the color table of img.

   [getTransparent img] returns SOME c where c is the `transparent'\index{getTransparent@\verb,getTransparent,!value (\verb,Gdimage,)}
   color of the image, if any; otherwise returns NONE.

   [setTransparent img col] makes the given color transparent in the\index{setTransparent@\verb,setTransparent,!value (\verb,Gdimage,)}
   image.

   [noTransparent img] makes all colors non\verb"-"transparent in the image.\index{noTransparent@\verb,noTransparent,!value (\verb,Gdimage,)}
   This is useful for images that are to be used as tiles for filling.
   Such images are not allowed to have a transparent color.

   [drawPixel img mode xy] draws the pixel in img at xy using the\index{drawPixel@\verb,drawPixel,!value (\verb,Gdimage,)}
   given mode.

   [drawLine img mode (xy1, xy2)] draws a line in img from xy1 to xy2\index{drawLine@\verb,drawLine,!value (\verb,Gdimage,)}
   using the given mode.

   [drawRect img mode (xy1, xy2)] draws a rectangle in img with\index{drawRect@\verb,drawRect,!value (\verb,Gdimage,)}
   opposing corners xy1 and xy2 using the given mode.

   [fillRect img mode (xy1, xy2)] draws a filled rectangle in img with\index{fillRect@\verb,fillRect,!value (\verb,Gdimage,)}
   opposing corners xy1 and xy2 using the given mode.

   [drawPolygon img mode xys] draws a polygon in img with corners as\index{drawPolygon@\verb,drawPolygon,!value (\verb,Gdimage,)}
   given by the vector xys of coordinates using the given mode.

   [fillPolygon img mode xys] draws a filled polygon in img with\index{fillPolygon@\verb,fillPolygon,!value (\verb,Gdimage,)}
   corners as given by the vector xys of coordinates using the given
   mode.

   [drawArc img mode \verb"{" c, wh, from, to \verb"}"] draw part of an ellipsis arc\index{drawArc@\verb,drawArc,!value (\verb,Gdimage,)}
   in img, with center c, width and height wh, using the given `from'
   and `to' angles, given in degrees (0..360).

   [fill img mode xy] fills the region in img around xy which has the\index{fill@\verb,fill,!value (\verb,Gdimage,)}
   same color as the point at img, using the given mode.

   [fillBorder img mode xy col] fills the region in img around xy\index{fillBorder@\verb,fillBorder,!value (\verb,Gdimage,)}
   which is delimited by the color col, using the given mode.
 
   [copy \verb"{" src, srcxy, srcwh, dst, dstxy \verb"}"] copies part of the image\index{copy@\verb,copy,!value (\verb,Gdimage,)}
   src into the image dst, without rescaling.  More precisely, copies
   the subimage of src whose upper left\verb"-"hand corner is srcxy and whose
   size is srcwh, into the subimage of dst whose upper left\verb"-"hand
   corner is dstxy.  The images src and dst may be the same, but if
   the subimages overlap, then the result is unpredictable.  

   [copyResize \verb"{" src, srcxy, srcwh, dst, dstxy, dstwh \verb"}"] copies part\index{copyResize@\verb,copyResize,!value (\verb,Gdimage,)}
   of the image src into the image dst, rescaling to the given size
   dstwh of the destination subimage.  Otherwise works as copy.

   [char img col font xy ch] draws the character ch left\verb"-"right (to be\index{char@\verb,char,!value (\verb,Gdimage,)}
   read from south) in img at xy using the given color.

   [charUp img col font xy ch] draws the character ch bottom\verb"-"up (to be\index{charUp@\verb,charUp,!value (\verb,Gdimage,)}
   read from east) in img at xy using the given color.

   [string img col font xy s] draws the string s left\verb"-"right (to be\index{string@\verb,string,!value (\verb,Gdimage,)}
   read from south) in img at xy using the given color.

   [stringUp img col font xy s] draws the string s bottom\verb"-"up (to be\index{stringUp@\verb,stringUp,!value (\verb,Gdimage,)}
   read from east) in img at xy using the given color.

   [charsize font] returns (w, h) where w is the width and h the\index{charsize@\verb,charsize,!value (\verb,Gdimage,)}
   height, in pixels, of each character in the given font.
\end{longprogram}
\index{Gdimage@\verb,Gdimage, (structure)|)}\newpage

\section*{Module Help}
\index{Help@\verb,Help, (structure)|(}
\markboth{\MakeUppercase{Help}}{\MakeUppercase{Help}}
\addcontentsline{toc}{section}{Help}
\begin{longprogram}
{\itshape{}Help \verb"-"\verb"-" on\verb"-"line help functions }

val help           : string \verb"-"\verb">" unit\index{help@\verb,help,!value (\verb,Help,)}

val displayLines   : int ref\index{displayLines@\verb,displayLines,!value (\verb,Help,)}
val helpdirs       : string list ref\index{helpdirs@\verb,helpdirs,!value (\verb,Help,)}
val indexfiles     : string list ref\index{indexfiles@\verb,indexfiles,!value (\verb,Help,)}
val specialfiles   : \verb"{"term : string, file : string, title : string\verb"}" list ref\index{specialfiles@\verb,specialfiles,!value (\verb,Help,)}
val welcome        : string vector ref\index{welcome@\verb,welcome,!value (\verb,Help,)}
val browser        : (string \verb"-"\verb">" unit) ref\index{browser@\verb,browser,!value (\verb,Help,)}
val defaultBrowser : string \verb"-"\verb">" unit\index{defaultBrowser@\verb,defaultBrowser,!value (\verb,Help,)}

\separatingline
   [help s] provides on\verb"-"line help on the topic indicated by string s.  \index{help@\verb,help,!value (\verb,Help,)}

      help "lib";   gives an overview of the Moscow ML library.
      help "id";    provides help on identifier id (case\verb"-"insensitive).

   If exactly one identifier in the library matches id (case\verb"-"insensitive), 
   then the browser opens the signature defining that identifier, 
   positioning the first occurrence of id at the center of the screen.

   If more than one identifier matches id (case\verb"-"insensitive), then a
   small menu lists the signatures containing the identifier.  To
   invoke the browser, just type in the number of the desired
   signature.

   The browser accepts the following commands, which must be followed
   by a newline:

      d      move down by half a screen
      u      move up by half a screen
      t      move to top of file
      b      move to bottom of file
      /str   cyclically search for string str in help file (case\verb"-"insensitive)
      n      search for next occurrence of str
      q      quit the browser

   A newline by itself moves down one screen (24 lines).

   [helpdirs] is a reference to a list of additional directories to be\index{helpdirs@\verb,helpdirs,!value (\verb,Help,)}
   searched for help files.  The directories are searched in order,
   after the \verb"-"stdlib directory.

   [indexfiles] is a reference to a list of full paths of help term\index{indexfiles@\verb,indexfiles,!value (\verb,Help,)}
   index files.  Setting `indexfiles' affects subsequent invocations
   of `help'.  (Every invocation of `help' reads the index files anew).

   [specialfiles] is a reference to a list of \verb"{"term, file, title\verb"}"\index{specialfiles@\verb,specialfiles,!value (\verb,Help,)}
   records, each of which maps a search term to the specified file
   with the specified title (in the browser).  The string in the
   `term' field should be all lowercase, since the argument passed to
   `help' will be converted to lowercase.

   [welcome] is a reference to the text shown in response to the query \index{welcome@\verb,welcome,!value (\verb,Help,)}
   help "".  This is a vector of lines of text.

   [browser] is a reference to the function that gets invoked on the \index{browser@\verb,browser,!value (\verb,Help,)}
   text of the help file.  Initially set to defaultBrowser.

   [defaultBrowser] is the default (built\verb"-"in) help browser.\index{defaultBrowser@\verb,defaultBrowser,!value (\verb,Help,)}

   [displayLines] is a reference to the size of the display (window)\index{displayLines@\verb,displayLines,!value (\verb,Help,)}
   assumed by the defaultBrowser; initially 24 lines.  Set it to the
   actual size of your window for best results.  
\end{longprogram}
\index{Help@\verb,Help, (structure)|)}\newpage

\section*{Module Int}
\index{Int@\verb,Int, (structure)|(}
\markboth{\MakeUppercase{Int}}{\MakeUppercase{Int}}
\addcontentsline{toc}{section}{Int}
\begin{longprogram}
{\itshape{}Int \verb"-"\verb"-" SML Basis Library }

type int = int\index{int@\verb,int,!type (\verb,Int,)}

val precision : int option\index{precision@\verb,precision,!value (\verb,Int,)}
val minInt    : int option\index{minInt@\verb,minInt,!value (\verb,Int,)}
val maxInt    : int option\index{maxInt@\verb,maxInt,!value (\verb,Int,)}

val ~         : int \verb"-"\verb">" int              {\itshape{}Overflow      }\index{~@\verb,~,!value (\verb,Int,)}
val *         : int * int \verb"-"\verb">" int        {\itshape{}Overflow      }\index{*@\verb,*,!value (\verb,Int,)}
val div       : int * int \verb"-"\verb">" int        {\itshape{}Div, Overflow }\index{div@\verb,div,!value (\verb,Int,)}
val mod       : int * int \verb"-"\verb">" int        {\itshape{}Div           }\index{mod@\verb,mod,!value (\verb,Int,)}
val quot      : int * int \verb"-"\verb">" int        {\itshape{}Div, Overflow }\index{quot@\verb,quot,!value (\verb,Int,)}
val rem       : int * int \verb"-"\verb">" int        {\itshape{}Div           }\index{rem@\verb,rem,!value (\verb,Int,)}
val +         : int * int \verb"-"\verb">" int        {\itshape{}Overflow      }\index{+@\verb,+,!value (\verb,Int,)}
val \verb"-"         : int * int \verb"-"\verb">" int        {\itshape{}Overflow      }\index{-@\verb,-,!value (\verb,Int,)}
val \verb">"         : int * int \verb"-"\verb">" bool\index{>@\verb,>,!value (\verb,Int,)}
val \verb">"=        : int * int \verb"-"\verb">" bool\index{>=@\verb,>=,!value (\verb,Int,)}
val \verb"<"         : int * int \verb"-"\verb">" bool\index{<@\verb,<,!value (\verb,Int,)}
val \verb"<"=        : int * int \verb"-"\verb">" bool\index{<=@\verb,<=,!value (\verb,Int,)}
val abs       : int \verb"-"\verb">" int              {\itshape{}Overflow      }\index{abs@\verb,abs,!value (\verb,Int,)}
val min       : int * int \verb"-"\verb">" int\index{min@\verb,min,!value (\verb,Int,)}
val max       : int * int \verb"-"\verb">" int\index{max@\verb,max,!value (\verb,Int,)}

val sign      : int \verb"-"\verb">" int\index{sign@\verb,sign,!value (\verb,Int,)}
val sameSign  : int * int \verb"-"\verb">" bool\index{sameSign@\verb,sameSign,!value (\verb,Int,)}
val compare   : int * int \verb"-"\verb">" order\index{compare@\verb,compare,!value (\verb,Int,)}

val toInt     : int \verb"-"\verb">" int\index{toInt@\verb,toInt,!value (\verb,Int,)}
val fromInt   : int \verb"-"\verb">" int\index{fromInt@\verb,fromInt,!value (\verb,Int,)}
val toLarge   : int \verb"-"\verb">" int\index{toLarge@\verb,toLarge,!value (\verb,Int,)}
val fromLarge : int \verb"-"\verb">" int\index{fromLarge@\verb,fromLarge,!value (\verb,Int,)}

val scan      : StringCvt.radix \index{scan@\verb,scan,!value (\verb,Int,)}
                \verb"-"\verb">" (char, 'a) StringCvt.reader \verb"-"\verb">" (int, 'a) StringCvt.reader
val fmt       : StringCvt.radix \verb"-"\verb">" int \verb"-"\verb">" string\index{fmt@\verb,fmt,!value (\verb,Int,)}

val toString  : int \verb"-"\verb">" string\index{toString@\verb,toString,!value (\verb,Int,)}
val fromString : string \verb"-"\verb">" int option   {\itshape{}Overflow      }\index{fromString@\verb,fromString,!value (\verb,Int,)}

\separatingline
   [precision] is SOME n, where n is the number of significant bits in an\index{precision@\verb,precision,!value (\verb,Int,)}
   integer.  In Moscow ML n is 31 in 32\verb"-"bit architectures and 63 in 64\verb"-"bit
   architectures.

   [minInt] is SOME n, where n is the most negative integer.\index{minInt@\verb,minInt,!value (\verb,Int,)}

   [maxInt] is SOME n, where n is the most positive integer.\index{maxInt@\verb,maxInt,!value (\verb,Int,)}

   [~]\index{~@\verb,~,!value (\verb,Int,)}
   [*]\index{*@\verb,*,!value (\verb,Int,)}
   [+]\index{+@\verb,+,!value (\verb,Int,)}
   [\verb"-"] are the usual operations on integers.  They raise Overflow if\index{-@\verb,-,!value (\verb,Int,)}
   the result is not representable as an integer.

   [abs] returns the absolute value of its argument.  Raises Overflow\index{abs@\verb,abs,!value (\verb,Int,)}
   if applied to the most negative integer.

   [div] is integer division, rounding towards minus infinity.\index{div@\verb,div,!value (\verb,Int,)}
   Evaluating i div 0 raises Div.  Evaluating i div ~1 raises
   Overflow if i is the most negative integer.

   [mod] is the remainder for div.  If q = i div d and r = i mod d then\index{mod@\verb,mod,!value (\verb,Int,)}
   it holds that qd + r = i, where either 0 \verb"<"= r \verb"<" d or d \verb"<" r \verb"<"= 0.  
   Evaluating i mod 0 raises Div, whereas i mod ~1 = 0, for all i.

   [quot] is integer division, rounding towards zero.  Evaluating\index{quot@\verb,quot,!value (\verb,Int,)}
   quot(i, 0) raises Div.  Evaluating quot(i, ~1) raises Overflow if i
   is the most negative integer.

   [rem(i, d)] is the remainder for quot.  That is, if q = quot(i, d)\index{rem@\verb,rem,!value (\verb,Int,)}
   and r = rem(i, d) then d * q + r = i, where r is zero or has the
   same sign as i.  If made infix, the recommended fixity for quot and
   rem is
        infix 7 quot rem

   [min(x, y)] is the smaller of x and y.\index{min@\verb,min,!value (\verb,Int,)}

   [max(x, y)] is the larger of x and y.\index{max@\verb,max,!value (\verb,Int,)}

   [sign x] is ~1, 0, or 1, according as x is negative, zero, or positive.\index{sign@\verb,sign,!value (\verb,Int,)}

   [\verb"<"]\index{<@\verb,<,!value (\verb,Int,)}
   [\verb"<"=]\index{<=@\verb,<=,!value (\verb,Int,)}
   [\verb">"]\index{>@\verb,>,!value (\verb,Int,)}
   [\verb">"=] are the usual comparisons on integers.\index{>=@\verb,>=,!value (\verb,Int,)}

   [compare(x, y)] returns LESS, EQUAL, or GREATER, according \index{compare@\verb,compare,!value (\verb,Int,)}
   as x is less than, equal to, or greater than y.

   [sameSign(x, y)] is true iff sign x = sign y.\index{sameSign@\verb,sameSign,!value (\verb,Int,)}

   [toInt x] is x (because this is the default int type in Moscow ML).

   [fromInt x] is x (because this is the default int type in Moscow ML).

   [toLarge x] is x (because this is the largest int type in Moscow ML).

   [fromLarge x] is x (because this is the largest int type in Moscow ML).

   [fmt radix i] returns a string representing i, in the radix (base)\index{fmt@\verb,fmt,!value (\verb,Int,)}
   specified by radix.

     radix    description                     output format  
     \verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"
      BIN     signed binary      (base  2)    ~?[01]+
      OCT     signed octal       (base  8)    ~?[0\verb"-"7]+
      DEC     signed decimal     (base 10)    ~?[0\verb"-"9]+
      HEX     signed hexadecimal (base 16)    ~?[0\verb"-"9A\verb"-"F]+

   [toString i] returns a string representing i in signed decimal format.\index{toString@\verb,toString,!value (\verb,Int,)}
   Equivalent to (fmt DEC i).
   
   [fromString s] returns SOME(i) if a decimal integer numeral can be\index{fromString@\verb,fromString,!value (\verb,Int,)}
   scanned from a prefix of string s, ignoring any initial whitespace;
   returns NONE otherwise.  A decimal integer numeral must have form,
   after possible initial whitespace: 
        [+~\verb"-"]?[0\verb"-"9]+

   [scan radix getc charsrc] attempts to scan an integer numeral\index{scan@\verb,scan,!value (\verb,Int,)}
   from the character source charsrc, using the accessor getc, and
   ignoring any initial whitespace.  The radix argument specifies the base
   of the numeral (BIN, OCT, DEC, HEX).  If successful, it returns
   SOME(i, rest) where i is the value of the number scanned, and rest
   is the unused part of the character source.  A numeral must have
   form, after possible initial whitespace:

     radix    input format 
     \verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"
      BIN     [+~\verb"-"]?[0\verb"-"1]+
      OCT     [+~\verb"-"]?[0\verb"-"7]+
      DEC     [+~\verb"-"]?[0\verb"-"9]+
      HEX     [+~\verb"-"]?[0\verb"-"9a\verb"-"fA\verb"-"F]+
\end{longprogram}
\index{Int@\verb,Int, (structure)|)}\newpage

\section*{Module Intmap}
\index{Intmap@\verb,Intmap, (structure)|(}
\markboth{\MakeUppercase{Intmap}}{\MakeUppercase{Intmap}}
\addcontentsline{toc}{section}{Intmap}
\begin{longprogram}
{\itshape{}Intmap \verb"-"\verb"-" Applicative maps with integer keys                  }
{\itshape{}From SML/NJ lib 0.2, copyright 1993 by AT\&T Bell Laboratories }
{\itshape{}Original implementation due to Stephen Adams, Southampton, UK }

type 'a intmap\index{intmap@\verb,intmap,!type (\verb,Intmap,)}

exception NotFound\index{NotFound@\verb,NotFound,!exception (\verb,Intmap,)}

val empty     : unit \verb"-"\verb">" 'a intmap\index{empty@\verb,empty,!value (\verb,Intmap,)}
val insert    : 'a intmap * int * 'a \verb"-"\verb">" 'a intmap\index{insert@\verb,insert,!value (\verb,Intmap,)}
val retrieve  : 'a intmap * int \verb"-"\verb">" 'a\index{retrieve@\verb,retrieve,!value (\verb,Intmap,)}
val peek      : 'a intmap * int \verb"-"\verb">" 'a option\index{peek@\verb,peek,!value (\verb,Intmap,)}
val remove    : 'a intmap * int \verb"-"\verb">" 'a intmap * 'a\index{remove@\verb,remove,!value (\verb,Intmap,)}
val numItems  : 'a intmap \verb"-"\verb">"  int\index{numItems@\verb,numItems,!value (\verb,Intmap,)}
val listItems : 'a intmap \verb"-"\verb">" (int * 'a) list\index{listItems@\verb,listItems,!value (\verb,Intmap,)}
val app       : (int * 'a \verb"-"\verb">" unit) \verb"-"\verb">" 'a intmap \verb"-"\verb">" unit\index{app@\verb,app,!value (\verb,Intmap,)}
val revapp    : (int * 'a \verb"-"\verb">" unit) \verb"-"\verb">" 'a intmap \verb"-"\verb">" unit\index{revapp@\verb,revapp,!value (\verb,Intmap,)}
val foldr     : (int * 'a * 'b \verb"-"\verb">" 'b) \verb"-"\verb">" 'b \verb"-"\verb">" 'a intmap \verb"-"\verb">" 'b\index{foldr@\verb,foldr,!value (\verb,Intmap,)}
val foldl     : (int * 'a * 'b \verb"-"\verb">" 'b) \verb"-"\verb">" 'b \verb"-"\verb">" 'a intmap \verb"-"\verb">" 'b\index{foldl@\verb,foldl,!value (\verb,Intmap,)}
val map       : (int * 'a \verb"-"\verb">" 'b) \verb"-"\verb">" 'a intmap \verb"-"\verb">" 'b intmap\index{map@\verb,map,!value (\verb,Intmap,)}
val transform : ('a \verb"-"\verb">" 'b) \verb"-"\verb">" 'a intmap \verb"-"\verb">" 'b intmap\index{transform@\verb,transform,!value (\verb,Intmap,)}

\separatingline
   ['a intmap] is the type of applicative maps from int to 'a.\index{intmap@\verb,intmap,!type (\verb,Intmap,)}

   [empty] creates a new empty map.\index{empty@\verb,empty,!value (\verb,Intmap,)}

   [insert(m, i, v)] extends (or modifies) map m to map i to v.\index{insert@\verb,insert,!value (\verb,Intmap,)}

   [retrieve(m, i)] returns v if m maps i to v; otherwise raises\index{retrieve@\verb,retrieve,!value (\verb,Intmap,)}
   NotFound.

   [peek(m, i)] returns SOME v if m maps i to v; otherwise NONE.\index{peek@\verb,peek,!value (\verb,Intmap,)}

   [remove(m, i)] removes i from the domain of m and returns the\index{remove@\verb,remove,!value (\verb,Intmap,)}
   modified map and the element v corresponding to i.  Raises NotFound
   if i is not in the domain of m.

   [numItems m] returns the number of entries in m (that is, the size\index{numItems@\verb,numItems,!value (\verb,Intmap,)}
   of the domain of m).

   [listItems m] returns a list of the entries (i, v) of integers i and\index{listItems@\verb,listItems,!value (\verb,Intmap,)}
   the corresponding values v in m, in increasing order of i.

   [app f m] applies function f to the entries (i, v) in m, in\index{app@\verb,app,!value (\verb,Intmap,)}
   increasing order of i.

   [revapp f m] applies function f to the entries (i, v) in m, in\index{revapp@\verb,revapp,!value (\verb,Intmap,)}
   decreasing order of i.

   [foldl f e m] applies the folding function f to the entries (i, v)\index{foldl@\verb,foldl,!value (\verb,Intmap,)}
   in m, in increasing order of i.

   [foldr f e m] applies the folding function f to the entries (i, v)\index{foldr@\verb,foldr,!value (\verb,Intmap,)}
   in m, in decreasing order of i.

   [map f m] returns a new map whose entries have form (i, f(i,v)),\index{map@\verb,map,!value (\verb,Intmap,)}
   where (i, v) is an entry in m.

   [transform f m] returns a new map whose entries have form (i, f(i,v)),\index{transform@\verb,transform,!value (\verb,Intmap,)}
   where (i, v) is an entry in m.
\end{longprogram}
\index{Intmap@\verb,Intmap, (structure)|)}\newpage

\section*{Module Intset}
\index{Intset@\verb,Intset, (structure)|(}
\markboth{\MakeUppercase{Intset}}{\MakeUppercase{Intset}}
\addcontentsline{toc}{section}{Intset}
\begin{longprogram}
{\itshape{}Intset \verb"-"\verb"-" applicative sets of integers                        }
{\itshape{}From SML/NJ lib 0.2, copyright 1993 by AT\&T Bell Laboratories }
{\itshape{}Original implementation due to Stephen Adams, Southampton, UK }

type intset\index{intset@\verb,intset,!type (\verb,Intset,)}

exception NotFound\index{NotFound@\verb,NotFound,!exception (\verb,Intset,)}

val empty        : intset\index{empty@\verb,empty,!value (\verb,Intset,)}
val singleton    : int \verb"-"\verb">" intset\index{singleton@\verb,singleton,!value (\verb,Intset,)}
val add          : intset * int \verb"-"\verb">" intset\index{add@\verb,add,!value (\verb,Intset,)}
val addList      : intset * int list \verb"-"\verb">" intset\index{addList@\verb,addList,!value (\verb,Intset,)}
val isEmpty      : intset \verb"-"\verb">" bool\index{isEmpty@\verb,isEmpty,!value (\verb,Intset,)}
val equal        : intset * intset \verb"-"\verb">" bool\index{equal@\verb,equal,!value (\verb,Intset,)}
val isSubset     : intset * intset \verb"-"\verb">" bool\index{isSubset@\verb,isSubset,!value (\verb,Intset,)}
val member       : intset * int \verb"-"\verb">" bool\index{member@\verb,member,!value (\verb,Intset,)}
val delete       : intset * int \verb"-"\verb">" intset\index{delete@\verb,delete,!value (\verb,Intset,)}
val numItems     : intset \verb"-"\verb">"  int\index{numItems@\verb,numItems,!value (\verb,Intset,)}
val union        : intset * intset \verb"-"\verb">" intset\index{union@\verb,union,!value (\verb,Intset,)}
val intersection : intset * intset \verb"-"\verb">" intset\index{intersection@\verb,intersection,!value (\verb,Intset,)}
val difference   : intset * intset \verb"-"\verb">" intset\index{difference@\verb,difference,!value (\verb,Intset,)}
val listItems    : intset \verb"-"\verb">" int list\index{listItems@\verb,listItems,!value (\verb,Intset,)}
val app          : (int \verb"-"\verb">" unit) \verb"-"\verb">" intset \verb"-"\verb">" unit\index{app@\verb,app,!value (\verb,Intset,)}
val revapp       : (int \verb"-"\verb">" unit) \verb"-"\verb">" intset \verb"-"\verb">" unit\index{revapp@\verb,revapp,!value (\verb,Intset,)}
val foldr        : (int * 'b \verb"-"\verb">" 'b) \verb"-"\verb">" 'b \verb"-"\verb">" intset \verb"-"\verb">" 'b\index{foldr@\verb,foldr,!value (\verb,Intset,)}
val foldl        : (int * 'b \verb"-"\verb">" 'b) \verb"-"\verb">" 'b \verb"-"\verb">" intset \verb"-"\verb">" 'b\index{foldl@\verb,foldl,!value (\verb,Intset,)}
val find         : (int \verb"-"\verb">" bool) \verb"-"\verb">" intset \verb"-"\verb">" int option\index{find@\verb,find,!value (\verb,Intset,)}

\separatingline
   [intset] is the type of sets of integers.  \index{intset@\verb,intset,!type (\verb,Intset,)}

   [empty] is the empty set of integers.\index{empty@\verb,empty,!value (\verb,Intset,)}

   [singleton i] is the singleton set containing i.\index{singleton@\verb,singleton,!value (\verb,Intset,)}

   [add(s, i)] adds item i to set s.  \index{add@\verb,add,!value (\verb,Intset,)}

   [addList(s, xs)] adds all items from the list xs to the set s.\index{addList@\verb,addList,!value (\verb,Intset,)}

   [isEmpty s] returns true if and only if the set is empty.\index{isEmpty@\verb,isEmpty,!value (\verb,Intset,)}

   [equal(s1, s2)] returns true if and only if the two sets have the\index{equal@\verb,equal,!value (\verb,Intset,)}
   same elements.

   [isSubset(s1, s2)] returns true if and only if s1 is a subset of s2.\index{isSubset@\verb,isSubset,!value (\verb,Intset,)}

   [member(s, i)] returns true if and only if i is in s.\index{member@\verb,member,!value (\verb,Intset,)}

   [delete(s, i)] removes item i from s.  Raises NotFound if i is not in s.\index{delete@\verb,delete,!value (\verb,Intset,)}
   
   [numItems s] returns the number of items in set s.\index{numItems@\verb,numItems,!value (\verb,Intset,)}

   [union(s1, s2)] returns the union of s1 and s2.  \index{union@\verb,union,!value (\verb,Intset,)}

   [intersection(s1, s2)] returns the intersectionof s1 and s2.\index{intersection@\verb,intersection,!value (\verb,Intset,)}

   [difference(s1, s2)] returns the difference between s1 and s2 (that\index{difference@\verb,difference,!value (\verb,Intset,)}
   is, the set of elements in s1 but not in s2).

   [listItems s] returns a list of the items in set s, in increasing \index{listItems@\verb,listItems,!value (\verb,Intset,)}
   order.

   [app f s] applies function f to the elements of s, in increasing\index{app@\verb,app,!value (\verb,Intset,)}
   order.

   [revapp f s] applies function f to the elements of s, in decreasing\index{revapp@\verb,revapp,!value (\verb,Intset,)}
   order. 

   [foldl f e s] applies the folding function f to the entries of the\index{foldl@\verb,foldl,!value (\verb,Intset,)}
   set in increasing order.

   [foldr f e s] applies the folding function f to the entries of the\index{foldr@\verb,foldr,!value (\verb,Intset,)}
   set in decreasing order. 

   [find p s] returns SOME i, where i is an item in s which satisfies\index{find@\verb,find,!value (\verb,Intset,)}
   p, if one exists; otherwise returns NONE.
\end{longprogram}
\index{Intset@\verb,Intset, (structure)|)}\newpage

\section*{Module Lexing}
\index{Lexing@\verb,Lexing, (structure)|(}
\markboth{\MakeUppercase{Lexing}}{\MakeUppercase{Lexing}}
\addcontentsline{toc}{section}{Lexing}
\begin{longprogram}
{\itshape{}Lexing \verb"-"\verb"-" run\verb"-"time library for lexers generated by mosmllex             }
{\itshape{}Closely based on the library for camllex.  Copyright 1993 INRIA, France }

local open Obj in

type lexbuf\index{lexbuf@\verb,lexbuf,!type (\verb,Lexing,)}

val createLexerString : string \verb"-"\verb">" lexbuf\index{createLexerString@\verb,createLexerString,!value (\verb,Lexing,)}
val createLexer       : (CharArray.array \verb"-"\verb">" int \verb"-"\verb">" int) \verb"-"\verb">" lexbuf\index{createLexer@\verb,createLexer,!value (\verb,Lexing,)}

val getLexeme         : lexbuf \verb"-"\verb">" string\index{getLexeme@\verb,getLexeme,!value (\verb,Lexing,)}
val getLexemeChar     : lexbuf \verb"-"\verb">" int \verb"-"\verb">" char\index{getLexemeChar@\verb,getLexemeChar,!value (\verb,Lexing,)}
val getLexemeStart    : lexbuf \verb"-"\verb">" int\index{getLexemeStart@\verb,getLexemeStart,!value (\verb,Lexing,)}
val getLexemeEnd      : lexbuf \verb"-"\verb">" int\index{getLexemeEnd@\verb,getLexemeEnd,!value (\verb,Lexing,)}

{\itshape{}For internal use in generated lexers: }

val dummyAction       : lexbuf \verb"-"\verb">" obj\index{dummyAction@\verb,dummyAction,!value (\verb,Lexing,)}
val backtrack         : lexbuf \verb"-"\verb">" 'a\index{backtrack@\verb,backtrack,!value (\verb,Lexing,)}
prim_val getNextChar  : lexbuf \verb"-"\verb">" char = 1 "get_next_char"

prim_val getLexBuffer     : lexbuf \verb"-"\verb">" string           = 1 "field1"
prim_val getLexAbsPos     : lexbuf \verb"-"\verb">" int              = 1 "field2"
prim_val getLexStartPos   : lexbuf \verb"-"\verb">" int              = 1 "field3"
prim_val getLexCurrPos    : lexbuf \verb"-"\verb">" int              = 1 "field4"
prim_val getLexLastPos    : lexbuf \verb"-"\verb">" int              = 1 "field5"
prim_val getLexLastAction : lexbuf \verb"-"\verb">" (lexbuf \verb"-"\verb">" obj)  = 1 "field6"

prim_val setLexAbsPos     : lexbuf \verb"-"\verb">" int \verb"-"\verb">" unit             = 2 "setfield2"
prim_val setLexStartPos   : lexbuf \verb"-"\verb">" int \verb"-"\verb">" unit             = 2 "setfield3"
prim_val setLexCurrPos    : lexbuf \verb"-"\verb">" int \verb"-"\verb">" unit             = 2 "setfield4"
prim_val setLexLastPos    : lexbuf \verb"-"\verb">" int \verb"-"\verb">" unit             = 2 "setfield5"
prim_val setLexLastAction : lexbuf \verb"-"\verb">" (lexbuf \verb"-"\verb">" obj) \verb"-"\verb">" unit = 2 "setfield6"
end

\separatingline
   These functions are for use in mosmllex\verb"-"generated lexers.  For
   further information, see the Moscow ML Owner's Manual.  For
   examples, see mosml/examples/lexyacc and mosml/examples/calc.

   [lexbuf] is the type of lexer buffers.  A lexer buffer is the\index{lexbuf@\verb,lexbuf,!type (\verb,Lexing,)}
   argument passed to the scanning functions defined by the
   mosmllex\verb"-"generated scanners.  The lexer buffer holds the current
   state of the scanner, plus a function to refill the buffer from the
   input.

   [createLexerString s] returns a lexer buffer which reads from the\index{createLexerString@\verb,createLexerString,!value (\verb,Lexing,)}
   given string s. Reading starts from the first character in the
   string.  An end\verb"-"of\verb"-"input condition is generated when the end of the
   string is reached.

   [createLexer f] returns a lexer buffer that will use the given\index{createLexer@\verb,createLexer,!value (\verb,Lexing,)}
   function f for reading additional input.  When the lexer needs more
   characters, it will call the given function as (f carr n), where
   carr is a character array, and n is an integer.  The function
   should put at most characters or in carr, starting at character
   number 0, and return the number of characters actually stored.  A
   return value of 0 means end of input. 

   A lexer definition (input to mosmllex) consists of fragments of
   this form

      parse
          lhs1   \verb"{" rhs1 \verb"}"
        | lhs2   \verb"{" rhs2 \verb"}"
        | lhs3   \verb"{" rhs3 \verb"}"
        | ...

   where the lhs are regular expressions matching some string of
   characters, and the rhs are corresponding semantic actions, written
   in ML.  The following functions can be used in the semantic actions:

   [getLexeme lexbuf] returns the string matched by the left\verb"-"hand side\index{getLexeme@\verb,getLexeme,!value (\verb,Lexing,)}
   regular expression.

   [getLexemeChar lexbuf i] returns character number i in the matched\index{getLexemeChar@\verb,getLexemeChar,!value (\verb,Lexing,)}
   string. 

   [getLexemeStart lexbuf] returns the start position of the matched\index{getLexemeStart@\verb,getLexemeStart,!value (\verb,Lexing,)}
   string (in the input stream).  The first character in the stream
   has position 0.

   [getLexemeEnd lexbuf] returns the end position, plus one, of the\index{getLexemeEnd@\verb,getLexemeEnd,!value (\verb,Lexing,)}
   matched string (in the input stream).  The first character in the
   stream has position 0.  
\end{longprogram}
\index{Lexing@\verb,Lexing, (structure)|)}\newpage

\section*{Module List}
\index{List@\verb,List, (structure)|(}
\markboth{\MakeUppercase{List}}{\MakeUppercase{List}}
\addcontentsline{toc}{section}{List}
\begin{longprogram}
{\itshape{}List \verb"-"\verb"-" SML Basis Library }

datatype list = datatype list\index{list@\verb,list,!type (\verb,List,)}

exception Empty\index{Empty@\verb,Empty,!exception (\verb,List,)}

val null       : 'a list \verb"-"\verb">" bool\index{null@\verb,null,!value (\verb,List,)}
val hd         : 'a list \verb"-"\verb">" 'a                          {\itshape{}Empty     }\index{hd@\verb,hd,!value (\verb,List,)}
val tl         : 'a list \verb"-"\verb">" 'a list                     {\itshape{}Empty     }\index{tl@\verb,tl,!value (\verb,List,)}
val last       : 'a list \verb"-"\verb">" 'a                          {\itshape{}Empty     }\index{last@\verb,last,!value (\verb,List,)}

val nth        : 'a list * int \verb"-"\verb">" 'a                    {\itshape{}Subscript }\index{nth@\verb,nth,!value (\verb,List,)}
val take       : 'a list * int \verb"-"\verb">" 'a list               {\itshape{}Subscript }\index{take@\verb,take,!value (\verb,List,)}
val drop       : 'a list * int \verb"-"\verb">" 'a list               {\itshape{}Subscript }\index{drop@\verb,drop,!value (\verb,List,)}

val length     : 'a list \verb"-"\verb">" int \index{length@\verb,length,!value (\verb,List,)}

val rev        : 'a list \verb"-"\verb">" 'a list \index{rev@\verb,rev,!value (\verb,List,)}

val @          : 'a list * 'a list \verb"-"\verb">" 'a list\index{"@@\verb,"@,!value (\verb,List,)}
val concat     : 'a list list \verb"-"\verb">" 'a list\index{concat@\verb,concat,!value (\verb,List,)}
val revAppend  : 'a list * 'a list \verb"-"\verb">" 'a list\index{revAppend@\verb,revAppend,!value (\verb,List,)}

val app        : ('a \verb"-"\verb">" unit) \verb"-"\verb">" 'a list \verb"-"\verb">" unit\index{app@\verb,app,!value (\verb,List,)}
val map        : ('a \verb"-"\verb">" 'b) \verb"-"\verb">" 'a list \verb"-"\verb">" 'b list\index{map@\verb,map,!value (\verb,List,)}
val mapPartial : ('a \verb"-"\verb">" 'b option) \verb"-"\verb">" 'a list \verb"-"\verb">" 'b list\index{mapPartial@\verb,mapPartial,!value (\verb,List,)}

val find       : ('a \verb"-"\verb">" bool) \verb"-"\verb">" 'a list \verb"-"\verb">" 'a option\index{find@\verb,find,!value (\verb,List,)}
val filter     : ('a \verb"-"\verb">" bool) \verb"-"\verb">" 'a list \verb"-"\verb">" 'a list\index{filter@\verb,filter,!value (\verb,List,)}
val partition  : ('a \verb"-"\verb">" bool ) \verb"-"\verb">" 'a list \verb"-"\verb">" ('a list * 'a list)\index{partition@\verb,partition,!value (\verb,List,)}

val foldr      : ('a * 'b \verb"-"\verb">" 'b) \verb"-"\verb">" 'b \verb"-"\verb">" 'a list \verb"-"\verb">" 'b\index{foldr@\verb,foldr,!value (\verb,List,)}
val foldl      : ('a * 'b \verb"-"\verb">" 'b) \verb"-"\verb">" 'b \verb"-"\verb">" 'a list \verb"-"\verb">" 'b\index{foldl@\verb,foldl,!value (\verb,List,)}

val exists     : ('a \verb"-"\verb">" bool) \verb"-"\verb">" 'a list \verb"-"\verb">" bool\index{exists@\verb,exists,!value (\verb,List,)}
val all        : ('a \verb"-"\verb">" bool) \verb"-"\verb">" 'a list \verb"-"\verb">" bool\index{all@\verb,all,!value (\verb,List,)}

val tabulate   : int * (int \verb"-"\verb">" 'a) \verb"-"\verb">" 'a list           {\itshape{}Size      }\index{tabulate@\verb,tabulate,!value (\verb,List,)}

val getItem    : 'a list \verb"-"\verb">" ('a * 'a list) option\index{getItem@\verb,getItem,!value (\verb,List,)}

\separatingline
   ['a list] is the type of lists of elements of type 'a.\index{list@\verb,list,!type (\verb,List,)}

   [null xs] is true iff xs is nil.\index{null@\verb,null,!value (\verb,List,)}

   [hd xs] returns the first element of xs.  Raises Empty if xs is nil.\index{hd@\verb,hd,!value (\verb,List,)}

   [tl xs] returns all but the first element of xs.  \index{tl@\verb,tl,!value (\verb,List,)}
   Raises Empty if xs is nil.

   [last xs] returns the last element of xs.  Raises Empty if xs is nil.\index{last@\verb,last,!value (\verb,List,)}

   [nth(xs, i)] returns the i'th element of xs, counting from 0.\index{nth@\verb,nth,!value (\verb,List,)}
   Raises Subscript if i\verb"<"0 or i\verb">"=length xs.

   [take(xs, i)] returns the first i elements of xs.  Raises Subscript\index{take@\verb,take,!value (\verb,List,)}
   if i\verb"<"0 or i\verb">"length xs.

   [drop(xs, i)] returns what is left after dropping the first i\index{drop@\verb,drop,!value (\verb,List,)}
   elements of xs.  Raises Subscript if i\verb"<"0 or i\verb">"length xs.  
   It holds that take(xs, i) @ drop(xs, i) = xs when 0 \verb"<"= i \verb"<"= length xs.

   [length xs] returns the number of elements in xs.\index{length@\verb,length,!value (\verb,List,)}

   [rev xs] returns the list of xs's elements, reversed.\index{rev@\verb,rev,!value (\verb,List,)}

   [xs @ ys] returns the list which is the concatenation of xs and ys.

   [concat xss] returns the list which is the concatenation of all the\index{concat@\verb,concat,!value (\verb,List,)}
   lists in xss.

   [revAppend(xs, ys)] is equivalent to rev xs @ ys, but more efficient. \index{revAppend@\verb,revAppend,!value (\verb,List,)}

   [app f xs] applies f to the elements of xs, from left to right.\index{app@\verb,app,!value (\verb,List,)}

   [map f xs] applies f to each element x of xs, from left to\index{map@\verb,map,!value (\verb,List,)}
   right, and returns the list of f's results.
 
   [mapPartial f xs] applies f to each element x of xs, from left\index{mapPartial@\verb,mapPartial,!value (\verb,List,)}
   to right, and returns the list of those y's for which f(x)
   evaluated to SOME y.

   [find p xs] applies f to each element x of xs, from left to\index{find@\verb,find,!value (\verb,List,)}
   right until p(x) evaluates to true; returns SOME x if such an x
   exists otherwise NONE.

   [filter p xs] applies p to each element x of xs, from left to\index{filter@\verb,filter,!value (\verb,List,)}
   right, and returns the sublist of those x for which p(x) evaluated
   to true.

   [partition p xs] applies p to each element x of xs, from left\index{partition@\verb,partition,!value (\verb,List,)}
   to right, and returns a pair (pos, neg) where pos is the sublist
   of those x for which p(x) evaluated to true, and neg is the sublist of
   those for which p(x) evaluated to false.

   [foldr op\verb"%" e xs] evaluates x1 \verb"%" (x2 \verb"%" ( ... \verb"%" (x(n\verb"-"1) \verb"%" (xn \verb"%" e)) ... ))\index{foldr@\verb,foldr,!value (\verb,List,)}
   where xs = [x1, x2, ..., x(n\verb"-"1), xn], and \verb"%" is taken to be infixed.

   [foldl op\verb"%" e xs] evaluates xn \verb"%" (x(n\verb"-"1) \verb"%" ( ... \verb"%" (x2 \verb"%" (x1 \verb"%" e))))\index{foldl@\verb,foldl,!value (\verb,List,)}
   where xs = [x1, x2, ..., x(n\verb"-"1), xn], and \verb"%" is taken to be infixed.

   [exists p xs] applies p to each element x of xs, from left to\index{exists@\verb,exists,!value (\verb,List,)}
   right until p(x) evaluates to true; returns true if such an x
   exists, otherwise false.

   [all p xs] applies p to each element x of xs, from left to\index{all@\verb,all,!value (\verb,List,)}
   right until p(x) evaluates to false; returns false if such an x
   exists, otherwise true.

   [tabulate(n, f)] returns a list of length n whose elements are\index{tabulate@\verb,tabulate,!value (\verb,List,)}
   f(0), f(1), ..., f(n\verb"-"1), created from left to right.  Raises Size
   if n\verb"<"0.

   [getItem xs] attempts to extract an element from the list xs.  It\index{getItem@\verb,getItem,!value (\verb,List,)}
   returns NONE if xs is empty, and returns SOME (x, xr) if xs=x::xr.
   This can be used for scanning booleans, integers, reals, and so on
   from a list of characters.  For instance, to scan a decimal integer
   from a list cs of characters, compute 
        Int.scan StringCvt.DEC List.getItem cs
\end{longprogram}
\index{List@\verb,List, (structure)|)}\newpage

\section*{Module ListPair}
\index{ListPair@\verb,ListPair, (structure)|(}
\markboth{\MakeUppercase{ListPair}}{\MakeUppercase{ListPair}}
\addcontentsline{toc}{section}{ListPair}
\begin{longprogram}
{\itshape{}ListPair \verb"-"\verb"-" SML Basis Library }

val zip    : 'a list * 'b list \verb"-"\verb">" ('a * 'b) list\index{zip@\verb,zip,!value (\verb,ListPair,)}
val unzip  : ('a * 'b) list \verb"-"\verb">" 'a list * 'b list\index{unzip@\verb,unzip,!value (\verb,ListPair,)}
val map    : ('a * 'b \verb"-"\verb">" 'c)   \verb"-"\verb">" 'a list * 'b list \verb"-"\verb">" 'c list\index{map@\verb,map,!value (\verb,ListPair,)}
val app    : ('a * 'b \verb"-"\verb">" unit) \verb"-"\verb">" 'a list * 'b list \verb"-"\verb">" unit\index{app@\verb,app,!value (\verb,ListPair,)}
val all    : ('a * 'b \verb"-"\verb">" bool) \verb"-"\verb">" 'a list * 'b list \verb"-"\verb">" bool\index{all@\verb,all,!value (\verb,ListPair,)}
val exists : ('a * 'b \verb"-"\verb">" bool) \verb"-"\verb">" 'a list * 'b list \verb"-"\verb">" bool\index{exists@\verb,exists,!value (\verb,ListPair,)}
val foldr  : ('a * 'b * 'c \verb"-"\verb">" 'c) \verb"-"\verb">" 'c \verb"-"\verb">" 'a list * 'b list \verb"-"\verb">" 'c\index{foldr@\verb,foldr,!value (\verb,ListPair,)}
val foldl  : ('a * 'b * 'c \verb"-"\verb">" 'c) \verb"-"\verb">" 'c \verb"-"\verb">" 'a list * 'b list \verb"-"\verb">" 'c\index{foldl@\verb,foldl,!value (\verb,ListPair,)}

\separatingline
   These functions process pairs of lists.  No exception is raised
   when the lists are found to be of unequal length.  Instead the
   excess elements from the longer list are disregarded.

   [zip (xs, ys)] returns the list of pairs of corresponding elements\index{zip@\verb,zip,!value (\verb,ListPair,)}
   from xs and ys.  

   [unzip xys] returns a pair (xs, ys), where xs is the list of first\index{unzip@\verb,unzip,!value (\verb,ListPair,)}
   components of xys, and ys is the list of second components from
   xys.  Hence zip (unzip xys) has the same result and effect as xys.

   [map f (xs, ys)] applies function f to the pairs of corresponding\index{map@\verb,map,!value (\verb,ListPair,)}
   elements of xs and ys and returns the list of results.  Hence 
   map f (xs, ys) has the same result and effect as List.map f (zip (xs, ys)).

   [app f (xs, ys)] applies function f to the pairs of corresponding\index{app@\verb,app,!value (\verb,ListPair,)}
   elements of xs and ys and returns ().  Hence app f (xs, ys) has the
   same result and effect as List.app f (zip (xs, ys)).

   [all p (xs, ys)] applies predicate p to the pairs of corresponding\index{all@\verb,all,!value (\verb,ListPair,)}
   elements of xs and ys until p evaluates to false or one or both
   lists is exhausted; returns true if p is true of all such pairs;
   otherwise false.  Hence all p (xs, ys) has the same result and
   effect as Lisp.all p (zip (xs, ys)).

   [exists p (xs, ys)] applies predicate p to the pairs of corresponding\index{exists@\verb,exists,!value (\verb,ListPair,)}
   elements of xs and ys until p evaluates to true or one or both
   lists is exhausted; returns true if p is true of any such pair;
   otherwise false.  Hence exists p (xs, ys) has the same result and
   effect as Lisp.exists p (zip (xs, ys)).

   [foldr f e (xs, ys)] evaluates f(x1, y1, f(x2, y2, f(..., f(xn, yn, e))))\index{foldr@\verb,foldr,!value (\verb,ListPair,)}
   where xs = [x1, x2, ..., x(n\verb"-"1), xn, ...],
         ys = [y1, y2, ..., y(n\verb"-"1), yn, ...], 
   and    n = min(length xs, length ys).
   Equivalent to List.foldr (fn ((x, y), r) =\verb">" f(x, y, r)) e (zip(xs, ys)).

   [foldl f e (xs, ys)] evaluates f(xn, yn, f( ..., f(x2, y2, f(x1, y1, e))))\index{foldl@\verb,foldl,!value (\verb,ListPair,)}
   where xs = [x1, x2, ..., x(n\verb"-"1), xn, ...], 
         ys = [y1, y2, ..., y(n\verb"-"1), yn, ...], 
   and    n = min(length xs, length ys).
   Equivalent to List.foldl (fn ((x, y), r) =\verb">" f(x, y, r)) e (zip(xs, ys)).
\end{longprogram}
\index{ListPair@\verb,ListPair, (structure)|)}\newpage

\section*{Module Listsort}
\index{Listsort@\verb,Listsort, (structure)|(}
\markboth{\MakeUppercase{Listsort}}{\MakeUppercase{Listsort}}
\addcontentsline{toc}{section}{Listsort}
\begin{longprogram}
{\itshape{}Listsort }

val sort   : ('a * 'a \verb"-"\verb">" order) \verb"-"\verb">" 'a list \verb"-"\verb">" 'a list\index{sort@\verb,sort,!value (\verb,Listsort,)}
val sorted : ('a * 'a \verb"-"\verb">" order) \verb"-"\verb">" 'a list \verb"-"\verb">" bool\index{sorted@\verb,sorted,!value (\verb,Listsort,)}

\separatingline
   [sort ordr xs] sorts the list xs in nondecreasing order, using the\index{sort@\verb,sort,!value (\verb,Listsort,)}
   given ordering.  Uses Richard O'Keefe's smooth applicative merge
   sort.

   [sorted ordr xs] checks that the list xs is sorted in nondecreasing\index{sorted@\verb,sorted,!value (\verb,Listsort,)}
   order, in the given ordering.
\end{longprogram}
\index{Listsort@\verb,Listsort, (structure)|)}\newpage

\section*{Module Location}
\index{Location@\verb,Location, (structure)|(}
\markboth{\MakeUppercase{Location}}{\MakeUppercase{Location}}
\addcontentsline{toc}{section}{Location}
\begin{longprogram}
{\itshape{}Location \verb"-"\verb"-" error reporting for mosmllex and mosmlyac               }
{\itshape{}Based on src/compiler/location from the Caml Light 0.6 distribution }

datatype Location =  {\itshape{}Source file positions                            }\index{Location@\verb,Location,!type (\verb,Location,)}
    Loc of int       {\itshape{}Position of the first character                  }
         * int       {\itshape{}Position of the character following the last one }

val errLocation : string * BasicIO.instream * Lexing.lexbuf \verb"-"\verb">" Location\index{errLocation@\verb,errLocation,!value (\verb,Location,)}
                  \verb"-"\verb">" unit
val errMsg      : string * BasicIO.instream * Lexing.lexbuf \verb"-"\verb">" Location\index{errMsg@\verb,errMsg,!value (\verb,Location,)}
                  \verb"-"\verb">" string \verb"-"\verb">" 'a
val errPrompt   : string \verb"-"\verb">" unit; \index{errPrompt@\verb,errPrompt,!value (\verb,Location,)}
val nilLocation : Location\index{nilLocation@\verb,nilLocation,!value (\verb,Location,)}
val getCurrentLocation : unit \verb"-"\verb">" Location\index{getCurrentLocation@\verb,getCurrentLocation,!value (\verb,Location,)}
val mkLoc : 'a \verb"-"\verb">" Location * 'a\index{mkLoc@\verb,mkLoc,!value (\verb,Location,)}
val xLR   : Location * 'a \verb"-"\verb">" Location\index{xLR@\verb,xLR,!value (\verb,Location,)}
val xL    : Location * 'a \verb"-"\verb">" int\index{xL@\verb,xL,!value (\verb,Location,)}
val xR    : Location * 'a \verb"-"\verb">" int\index{xR@\verb,xR,!value (\verb,Location,)}
val xxLR  : Location * 'a \verb"-"\verb">" Location * 'b \verb"-"\verb">" Location\index{xxLR@\verb,xxLR,!value (\verb,Location,)}
val xxRL  : Location * 'a \verb"-"\verb">" Location * 'b \verb"-"\verb">" Location\index{xxRL@\verb,xxRL,!value (\verb,Location,)}

\separatingline
   These functions support error reporting in lexers and parsers
   generated with mosmllex and mosmlyac.  The directory
   mosml/examples/lexyacc/ contains an example of their use.
 
   [errLocation (file, stream, lexbuf) loc] prints the part of the lexer \index{errLocation@\verb,errLocation,!value (\verb,Location,)}
   input which is indicated by location loc.  
   
   If file \verb"<"\verb">" "" then it is assumed to be the name of the file from
   which the lexer reads, the stream is assumed to be an open input
   stream associated with this file, and lexbuf is the lexer buffer
   used to read from the stream.  Under MS DOS (and presumably
   Windows, OS/2, and MacOS), the stream must have been opened in
   binary mode (with Nonstdio.open_in_bin), or else the positioning in
   the file will be wrong (due to the translation of CRLF into
   newline in text files).

   If file = "" then the lexer is assumed to read from some source
   other than a stream, and the lexbuf (rather than the instream) is
   used to obtain the location indicated, if possible.  In this case
   the stream is immaterial; it will not be used.

   [errMsg (file, stream, lexbuf) loc msg] calls errLocation to print\index{errMsg@\verb,errMsg,!value (\verb,Location,)}
   the indicated part of the lexer input, then prints the error
   message msg and raises exception Fail.

   [errPrompt msg] prints "! ", the string msg, and a newline on\index{errPrompt@\verb,errPrompt,!value (\verb,Location,)}
   standard output.  

   [nilLocation] is the undefined location.\index{nilLocation@\verb,nilLocation,!value (\verb,Location,)}

   [getCurrentLocation ()] can be called within the semantic action\index{getCurrentLocation@\verb,getCurrentLocation,!value (\verb,Location,)}
   part of a grammar rule (only) and returns the location of the
   string matching the left\verb"-"hand side of the rule.

   [mkLoc a] can be called within the semantic action part of a\index{mkLoc@\verb,mkLoc,!value (\verb,Location,)}
   grammar rule (only), and returns a pair (loc, a) of the current
   location and the value a.  This is typically used to decorate
   abstract syntax tree nodes with location information, for use in
   subsequent error reports.

   [xLR loc_a] returns the location of the decorated value loc_a.\index{xLR@\verb,xLR,!value (\verb,Location,)}

   [xL loc_a] returns the left end position of loc_a.\index{xL@\verb,xL,!value (\verb,Location,)}

   [xR loc_a] returns the right end position of loc_a.\index{xR@\verb,xR,!value (\verb,Location,)}

   [xxLR loc_a loc_b] returns the location extending from the left end\index{xxLR@\verb,xxLR,!value (\verb,Location,)}
   of loc_a to the right end of loc_b.

   [xxRL loc_a loc_b] returns the location extending from the right end\index{xxRL@\verb,xxRL,!value (\verb,Location,)}
   of loc_a to the left end of loc_b.
\end{longprogram}
\index{Location@\verb,Location, (structure)|)}\newpage

\section*{Module Math}
\index{Math@\verb,Math, (structure)|(}
\markboth{\MakeUppercase{Math}}{\MakeUppercase{Math}}
\addcontentsline{toc}{section}{Math}
\begin{longprogram}
{\itshape{}Math \verb"-"\verb"-" SML Basis Library }

type real = real\index{real@\verb,real,!type (\verb,Math,)}

val pi    : real\index{pi@\verb,pi,!value (\verb,Math,)}
val e     : real\index{e@\verb,e,!value (\verb,Math,)}

val sqrt  : real \verb"-"\verb">" real\index{sqrt@\verb,sqrt,!value (\verb,Math,)}
val sin   : real \verb"-"\verb">" real\index{sin@\verb,sin,!value (\verb,Math,)}
val cos   : real \verb"-"\verb">" real\index{cos@\verb,cos,!value (\verb,Math,)}
val tan   : real \verb"-"\verb">" real\index{tan@\verb,tan,!value (\verb,Math,)}
val atan  : real \verb"-"\verb">" real\index{atan@\verb,atan,!value (\verb,Math,)}
val asin  : real \verb"-"\verb">" real\index{asin@\verb,asin,!value (\verb,Math,)}
val acos  : real \verb"-"\verb">" real\index{acos@\verb,acos,!value (\verb,Math,)}
val atan2 : real * real \verb"-"\verb">" real\index{atan2@\verb,atan2,!value (\verb,Math,)}
val exp   : real \verb"-"\verb">" real\index{exp@\verb,exp,!value (\verb,Math,)}
val pow   : real * real \verb"-"\verb">" real\index{pow@\verb,pow,!value (\verb,Math,)}
val ln    : real \verb"-"\verb">" real\index{ln@\verb,ln,!value (\verb,Math,)}
val log10 : real \verb"-"\verb">" real\index{log10@\verb,log10,!value (\verb,Math,)}
val sinh  : real \verb"-"\verb">" real\index{sinh@\verb,sinh,!value (\verb,Math,)}
val cosh  : real \verb"-"\verb">" real\index{cosh@\verb,cosh,!value (\verb,Math,)}
val tanh  : real \verb"-"\verb">" real\index{tanh@\verb,tanh,!value (\verb,Math,)}

\separatingline
   [pi] is the circumference of the circle with diameter 1, that is,\index{pi@\verb,pi,!value (\verb,Math,)}
   3.14159265358979323846.

   [e] is the base of the natural logarithm: 2.7182818284590452354.\index{e@\verb,e,!value (\verb,Math,)}

   [sqrt x] is the square root of x.  Raises Domain if x \verb"<" 0.0.\index{sqrt@\verb,sqrt,!value (\verb,Math,)}

   [sin r] is the sine of r, where r is in radians.\index{sin@\verb,sin,!value (\verb,Math,)}

   [cos r] is the cosine of r, where r is in radians.\index{cos@\verb,cos,!value (\verb,Math,)}

   [tan r] is the tangent of r, where r is in radians.  Raises Domain if \index{tan@\verb,tan,!value (\verb,Math,)}
   r is a multiple of pi/2.

   [atan t] is the arc tangent of t, in the open interval ] ~pi/2, pi/2 [.\index{atan@\verb,atan,!value (\verb,Math,)}

   [asin t] is the arc sine of t, in the closed interval [ ~pi/2, pi/2 ].  \index{asin@\verb,asin,!value (\verb,Math,)}
   Raises Domain if abs x \verb">" 1.

   [acos t] is the arc cosine of t, in the closed interval [ 0, pi ].\index{acos@\verb,acos,!value (\verb,Math,)}
   Raises Domain if abs x \verb">" 1.

   [atan2(y, x)] is the arc tangent of y/x, in the interval ] ~pi, pi ],\index{atan2@\verb,atan2,!value (\verb,Math,)}
   except that atan2(y, 0) = sign y * pi/2.  The quadrant of the result
   is the same as the quadrant of the point (x, y).
   Hence sign(cos(atan2(y, x))) = sign x 
   and   sign(sin(atan2(y, x))) = sign y. 

   [exp x] is e to the x'th power.\index{exp@\verb,exp,!value (\verb,Math,)}

   [pow (x, y)] is x it the y'th power, defined when \index{pow@\verb,pow,!value (\verb,Math,)}
      y \verb">"= 0 and (y integral or x \verb">"= 0)
   or y \verb"<" 0 and ((y integral and x \verb"<"\verb">" 0.0) or x \verb">" 0).

   We define pow(0, 0) = 1.

   [ln x] is the natural logarithm of x (that is, with base e).\index{ln@\verb,ln,!value (\verb,Math,)}
   Raises Domain if x \verb"<"= 0.0.

   [log10 x] is the base\verb"-"10 logarithm of x.  Raises Domain if x \verb"<"= 0.0.\index{log10@\verb,log10,!value (\verb,Math,)}

   [sinh x] returns the hyperbolic sine of x, mathematically defined as\index{sinh@\verb,sinh,!value (\verb,Math,)}
   (exp x \verb"-" exp (~x)) / 2.  Raises Overflow if x is too large.

   [cosh x] returns the hyperbolic cosine of x, mathematically defined as\index{cosh@\verb,cosh,!value (\verb,Math,)}
   (exp x + exp (~x)) / 2.  Raises Overflow if x is too large.

   [tanh x] returns the hyperbolic tangent of x, mathematically defined \index{tanh@\verb,tanh,!value (\verb,Math,)}
   as (sinh x) / (cosh x).  Raises Domain if x is too large.
\end{longprogram}
\index{Math@\verb,Math, (structure)|)}\newpage

\section*{Module Mosml}
\index{Mosml@\verb,Mosml, (structure)|(}
\markboth{\MakeUppercase{Mosml}}{\MakeUppercase{Mosml}}
\addcontentsline{toc}{section}{Mosml}
\begin{longprogram}
{\itshape{}Mosml \verb"-"\verb"-" some Moscow ML specific functions }

val argv      : unit \verb"-"\verb">" string list\index{argv@\verb,argv,!value (\verb,Mosml,)}
val time      : ('a \verb"-"\verb">" 'b) \verb"-"\verb">" ('a \verb"-"\verb">" 'b)\index{time@\verb,time,!value (\verb,Mosml,)}
val listDir   : string \verb"-"\verb">" string list\index{listDir@\verb,listDir,!value (\verb,Mosml,)}
val doubleVec : real \verb"-"\verb">" Word8Vector.vector\index{doubleVec@\verb,doubleVec,!value (\verb,Mosml,)}
val vecDouble : Word8Vector.vector \verb"-"\verb">" real\index{vecDouble@\verb,vecDouble,!value (\verb,Mosml,)}
val floatVec  : real \verb"-"\verb">" Word8Vector.vector\index{floatVec@\verb,floatVec,!value (\verb,Mosml,)}
val vecFloat  : Word8Vector.vector \verb"-"\verb">" real\index{vecFloat@\verb,vecFloat,!value (\verb,Mosml,)}
val md5sum    : string \verb"-"\verb">" string\index{md5sum@\verb,md5sum,!value (\verb,Mosml,)}

datatype runresult = \index{runresult@\verb,runresult,!type (\verb,Mosml,)}
    Success of string
  | Failure of string

val run : string \verb"-"\verb">" string list \verb"-"\verb">" string \verb"-"\verb">" runresult\index{run@\verb,run,!value (\verb,Mosml,)}

\separatingline
   [argv ()] returns the command line strings of the current process.\index{argv@\verb,argv,!value (\verb,Mosml,)}
   Hence List.nth(argv (), 0) is the command used to invoke the SML
   process, List.nth(argv (), 1) is its first argument, and so on.
   We recommend using the SML Basis Library CommandLine structure instead.

   [time f arg] applies f to arg and returns the result; as a side\index{time@\verb,time,!value (\verb,Mosml,)}
   effect, it prints the time (cpu, system, and real time) consumed by
   the evaluation.

   [listDir path] returns the list of all files and subdirectories of\index{listDir@\verb,listDir,!value (\verb,Mosml,)}
   the directory indicated by path.  Raises OS.SysErr in case of failure.

   [doubleVec r] returns an eight\verb"-"element vector of Word8.word, which\index{doubleVec@\verb,doubleVec,!value (\verb,Mosml,)}
   contains the real number in the IEEE 754 floating\verb"-"point `double
   format' bit layout stored in big\verb"-"endian (high byte first) order. 

   [vecDouble v] accepts an eight\verb"-"element vector v of Word8.word, and\index{vecDouble@\verb,vecDouble,!value (\verb,Mosml,)}
   returns the real number obtained by taking v to be an IEEE 754
   floating\verb"-"point `double format' number stored in big\verb"-"endian (high
   byte first) order.  Raises Fail if v is not en eight\verb"-"element
   vector.

   [floatVec r] returns a four\verb"-"element vector of Word8.word, which\index{floatVec@\verb,floatVec,!value (\verb,Mosml,)}
   contains the real number in the IEEE 754 floating\verb"-"point `float
   format' bit layout stored in big\verb"-"endian (high byte first) order.
   Raises Fail if r is not representable as a 32\verb"-"bit float.

   [vecFloat v] accepts a four\verb"-"element vector v of Word8.word, and\index{vecFloat@\verb,vecFloat,!value (\verb,Mosml,)}
   returns the real obtained by taking v to be an IEEE 754
   floating\verb"-"point `float format' number stored in big\verb"-"endian (high
   byte first) order.  Raises Fail if v is not a four\verb"-"element vector.

   [md5sum s] computes the 128\verb"-"bit MD5 checksum of string s and\index{md5sum@\verb,md5sum,!value (\verb,Mosml,)}
   returns it as a 22 character base64 string.  

   [run cmd args inp] executes the program cmd with command\verb"-"line\index{run@\verb,run,!value (\verb,Mosml,)}
   arguments args and standard input inp.  Returns Success s where s
   is the program's (standard and error) output as a string, if it
   executed successfully; otherwise returns Failure s where s is its
   (standard and error) output as a string.
\end{longprogram}
\index{Mosml@\verb,Mosml, (structure)|)}\newpage

\section*{Module Mosmlcgi}
\index{Mosmlcgi@\verb,Mosmlcgi, (structure)|(}
\markboth{\MakeUppercase{Mosmlcgi}}{\MakeUppercase{Mosmlcgi}}
\addcontentsline{toc}{section}{Mosmlcgi}
\begin{longprogram}
{\itshape{}Mosmlcgi \verb"-"\verb"-" support for writing CGI scripts in Moscow ML }

{\itshape{}1. Accessing the fields or parameters of a CGI call }

val cgi_fieldnames     : string list\index{cgi_fieldnames@\verb,cgi_fieldnames,!value (\verb,Mosmlcgi,)}
val cgi_field_strings  : string \verb"-"\verb">" string list;\index{cgi_field_strings@\verb,cgi_field_strings,!value (\verb,Mosmlcgi,)}
val cgi_field_string   : string \verb"-"\verb">" string option;\index{cgi_field_string@\verb,cgi_field_string,!value (\verb,Mosmlcgi,)}
val cgi_field_integer  : string * int \verb"-"\verb">" int;\index{cgi_field_integer@\verb,cgi_field_integer,!value (\verb,Mosmlcgi,)}

{\itshape{}2. Accessing parts in multipart/form\verb"-"data; form\verb"-"based file upload }

val cgi_partnames      : string list\index{cgi_partnames@\verb,cgi_partnames,!value (\verb,Mosmlcgi,)}

type part\index{part@\verb,part,!type (\verb,Mosmlcgi,)}
val cgi_part           : string \verb"-"\verb">" part option\index{cgi_part@\verb,cgi_part,!value (\verb,Mosmlcgi,)}
val cgi_parts          : string \verb"-"\verb">" part list\index{cgi_parts@\verb,cgi_parts,!value (\verb,Mosmlcgi,)}

val part_fieldnames    : part \verb"-"\verb">" string list\index{part_fieldnames@\verb,part_fieldnames,!value (\verb,Mosmlcgi,)}
val part_type          : part \verb"-"\verb">" string option\index{part_type@\verb,part_type,!value (\verb,Mosmlcgi,)}
val part_data          : part \verb"-"\verb">" string\index{part_data@\verb,part_data,!value (\verb,Mosmlcgi,)}
val part_field_strings : part \verb"-"\verb">" string \verb"-"\verb">" string list\index{part_field_strings@\verb,part_field_strings,!value (\verb,Mosmlcgi,)}
val part_field_string  : part \verb"-"\verb">" string \verb"-"\verb">" string option\index{part_field_string@\verb,part_field_string,!value (\verb,Mosmlcgi,)}
val part_field_integer : part \verb"-"\verb">" string * int \verb"-"\verb">" int\index{part_field_integer@\verb,part_field_integer,!value (\verb,Mosmlcgi,)}

{\itshape{}3. Administrative information }

val cgi_server_software       : string option\index{cgi_server_software@\verb,cgi_server_software,!value (\verb,Mosmlcgi,)}
val cgi_server_name           : string option\index{cgi_server_name@\verb,cgi_server_name,!value (\verb,Mosmlcgi,)}
val cgi_gateway_interface     : string option\index{cgi_gateway_interface@\verb,cgi_gateway_interface,!value (\verb,Mosmlcgi,)}
val cgi_server_protocol       : string option\index{cgi_server_protocol@\verb,cgi_server_protocol,!value (\verb,Mosmlcgi,)}
val cgi_server_port           : string option\index{cgi_server_port@\verb,cgi_server_port,!value (\verb,Mosmlcgi,)}
val cgi_request_method        : string option\index{cgi_request_method@\verb,cgi_request_method,!value (\verb,Mosmlcgi,)}
val cgi_http_accept           : string option\index{cgi_http_accept@\verb,cgi_http_accept,!value (\verb,Mosmlcgi,)}
val cgi_http_user_agent       : string option\index{cgi_http_user_agent@\verb,cgi_http_user_agent,!value (\verb,Mosmlcgi,)}
val cgi_http_referer          : string option\index{cgi_http_referer@\verb,cgi_http_referer,!value (\verb,Mosmlcgi,)}
val cgi_path_info             : string option\index{cgi_path_info@\verb,cgi_path_info,!value (\verb,Mosmlcgi,)}
val cgi_path_translated       : string option\index{cgi_path_translated@\verb,cgi_path_translated,!value (\verb,Mosmlcgi,)}
val cgi_script_name           : string option\index{cgi_script_name@\verb,cgi_script_name,!value (\verb,Mosmlcgi,)}
val cgi_query_string          : string option\index{cgi_query_string@\verb,cgi_query_string,!value (\verb,Mosmlcgi,)}
val cgi_remote_host           : string option\index{cgi_remote_host@\verb,cgi_remote_host,!value (\verb,Mosmlcgi,)}
val cgi_remote_addr           : string option\index{cgi_remote_addr@\verb,cgi_remote_addr,!value (\verb,Mosmlcgi,)}
val cgi_remote_user           : string option\index{cgi_remote_user@\verb,cgi_remote_user,!value (\verb,Mosmlcgi,)}
val cgi_remote_ident          : string option\index{cgi_remote_ident@\verb,cgi_remote_ident,!value (\verb,Mosmlcgi,)}
val cgi_auth_type             : string option\index{cgi_auth_type@\verb,cgi_auth_type,!value (\verb,Mosmlcgi,)}
val cgi_content_type          : string option\index{cgi_content_type@\verb,cgi_content_type,!value (\verb,Mosmlcgi,)}
val cgi_content_length        : string option\index{cgi_content_length@\verb,cgi_content_length,!value (\verb,Mosmlcgi,)}
val cgi_annotation_server     : string option\index{cgi_annotation_server@\verb,cgi_annotation_server,!value (\verb,Mosmlcgi,)}

val cgi_http_cookie           : string option\index{cgi_http_cookie@\verb,cgi_http_cookie,!value (\verb,Mosmlcgi,)}
val cgi_http_forwarded        : string option\index{cgi_http_forwarded@\verb,cgi_http_forwarded,!value (\verb,Mosmlcgi,)}
val cgi_http_host             : string option\index{cgi_http_host@\verb,cgi_http_host,!value (\verb,Mosmlcgi,)}
val cgi_http_proxy_connection : string option\index{cgi_http_proxy_connection@\verb,cgi_http_proxy_connection,!value (\verb,Mosmlcgi,)}
val cgi_script_filename       : string option\index{cgi_script_filename@\verb,cgi_script_filename,!value (\verb,Mosmlcgi,)}
val cgi_document_root         : string option\index{cgi_document_root@\verb,cgi_document_root,!value (\verb,Mosmlcgi,)}
val cgi_server_admin          : string option\index{cgi_server_admin@\verb,cgi_server_admin,!value (\verb,Mosmlcgi,)}
val cgi_api_version           : string option\index{cgi_api_version@\verb,cgi_api_version,!value (\verb,Mosmlcgi,)}
val cgi_the_request           : string option\index{cgi_the_request@\verb,cgi_the_request,!value (\verb,Mosmlcgi,)}
val cgi_request_uri           : string option\index{cgi_request_uri@\verb,cgi_request_uri,!value (\verb,Mosmlcgi,)}
val cgi_request_filename      : string option\index{cgi_request_filename@\verb,cgi_request_filename,!value (\verb,Mosmlcgi,)}
val cgi_is_subreq             : string option\index{cgi_is_subreq@\verb,cgi_is_subreq,!value (\verb,Mosmlcgi,)}

\separatingline
   The Mosmlcgi library is for writing CGI programs in Moscow ML.  A
   CGI program may be installed on a WWW server and is invoked in
   response to HTTP requests sent to the server from a web browser,
   typically from an HTML FORM element.


   1. Obtaining field values sent from an ordinary HTML form
   \verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"

   [cgi_fieldnames] is a list of the names of fields present in the\index{cgi_fieldnames@\verb,cgi_fieldnames,!value (\verb,Mosmlcgi,)}
   CGI call message.  If field name fnm is in cgi_fieldnames, then
   cgi_field_string fnm \verb"<"\verb">" NONE.

   [cgi_field_strings fnm] is a (possibly empty) list of the strings\index{cgi_field_strings@\verb,cgi_field_strings,!value (\verb,Mosmlcgi,)}
   bound to field fnm.

   [cgi_field_string fnm] returns SOME(s) where s is a string bound to\index{cgi_field_string@\verb,cgi_field_string,!value (\verb,Mosmlcgi,)}
   field name fnm, if any; otherwise NONE.  Equivalent to 
        case cgi_field_strings fnm of 
             []     =\verb">" NONE 
           | s :: _ =\verb">" SOME s

   [cgi_field_integer (fnm, deflt)] attempts to parse an integer from\index{cgi_field_integer@\verb,cgi_field_integer,!value (\verb,Mosmlcgi,)}
   field fnm.  Returns i if cgi_field_string(fnm) = SOME(s) and an
   integer i can be parsed from a prefix of s; otherwise returns deflt.


   2. Obtaining field values sent with ENCTYPE="multipart/form\verb"-"data"  
   \verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"

   [cgi_partnames] is a list of the names of the parts of the\index{cgi_partnames@\verb,cgi_partnames,!value (\verb,Mosmlcgi,)}
   multipart/form\verb"-"data message.

   The type part is the abstract type of parts of a message.  Each part
   may have several fields.  In this implementation, the field of a
   part cannot be a another part itself.

   [cgi_parts pnm] is a (possibly empty) list of the parts called pnm.\index{cgi_parts@\verb,cgi_parts,!value (\verb,Mosmlcgi,)}

   [cgi_part pnm] is SOME(prt) where prt is a part called pnm, if any;\index{cgi_part@\verb,cgi_part,!value (\verb,Mosmlcgi,)}
   otherwise NONE.  Equivalent to
        case cgi_parts pnm of 
             []       =\verb">" NONE 
           | prt :: _ =\verb">" SOME prt

   [part_fieldnames prt] is the list of field names in part pnm.\index{part_fieldnames@\verb,part_fieldnames,!value (\verb,Mosmlcgi,)}

   [part_type prt] is SOME(typ) if the part prt contains a specification
   `Context\verb"-"Type: typ'; otherwise NONE.

   [part_data prt] is the data contain in part prt; for instance, the\index{part_data@\verb,part_data,!value (\verb,Mosmlcgi,)}
   contents of a file uploaded via form\verb"-"based file upload.

   [part_field_strings prt fnm] is a (possibly empty) list of the\index{part_field_strings@\verb,part_field_strings,!value (\verb,Mosmlcgi,)}
   strings bound to field fnm in part prt.

   [part_field_string prt fnm] returns SOME(s) where s is a string\index{part_field_string@\verb,part_field_string,!value (\verb,Mosmlcgi,)}
   bound to field name fnm in part prt, if any; otherwise NONE.
   Equivalent to 
        case part_field_strings prt fnm of 
             []     =\verb">" NONE 
           | s :: _ =\verb">" SOME s

   [part_field_integer prt (fnm, deflt)] attempts to parse an integer\index{part_field_integer@\verb,part_field_integer,!value (\verb,Mosmlcgi,)}
   from field fnm of part prt.  Returns i if part_field_string prt fnm
   = SOME(s) and an integer i can be parsed from a prefix of s;
   otherwise returns deflt.


   3. Administrative and server information
   \verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"

   Each of the following variables has the value SOME(s) if the
   corresponding CGI environment variable is bound to string s;
   otherwise NONE:

   [cgi_server_software] is the value of SERVER_SOFTWARE\index{cgi_server_software@\verb,cgi_server_software,!value (\verb,Mosmlcgi,)}

   [cgi_server_name] is the value of SERVER_NAME\index{cgi_server_name@\verb,cgi_server_name,!value (\verb,Mosmlcgi,)}

   [cgi_gateway_interface] is the value of GATEWAY_INTERFACE\index{cgi_gateway_interface@\verb,cgi_gateway_interface,!value (\verb,Mosmlcgi,)}

   [cgi_server_protocol] is the value of SERVER_PROTOCOL\index{cgi_server_protocol@\verb,cgi_server_protocol,!value (\verb,Mosmlcgi,)}

   [cgi_server_port] is the value of SERVER_PORT\index{cgi_server_port@\verb,cgi_server_port,!value (\verb,Mosmlcgi,)}

   [cgi_request_method] is the value of REQUEST_METHOD\index{cgi_request_method@\verb,cgi_request_method,!value (\verb,Mosmlcgi,)}

   [cgi_http_accept] is the value of HTTP_ACCEPT\index{cgi_http_accept@\verb,cgi_http_accept,!value (\verb,Mosmlcgi,)}

   [cgi_http_user_agent] is the value of HTTP_USER_AGENT\index{cgi_http_user_agent@\verb,cgi_http_user_agent,!value (\verb,Mosmlcgi,)}

   [cgi_http_referer] is the value of HTTP_REFERER\index{cgi_http_referer@\verb,cgi_http_referer,!value (\verb,Mosmlcgi,)}

   [cgi_path_info] is the value of PATH_INFO\index{cgi_path_info@\verb,cgi_path_info,!value (\verb,Mosmlcgi,)}

   [cgi_path_translated] is the value of PATH_TRANSLATED\index{cgi_path_translated@\verb,cgi_path_translated,!value (\verb,Mosmlcgi,)}

   [cgi_script_name] is the value of SCRIPT_NAME\index{cgi_script_name@\verb,cgi_script_name,!value (\verb,Mosmlcgi,)}

   [cgi_query_string] is the value of QUERY_STRING\index{cgi_query_string@\verb,cgi_query_string,!value (\verb,Mosmlcgi,)}

   [cgi_remote_host] is the value of REMOTE_HOST\index{cgi_remote_host@\verb,cgi_remote_host,!value (\verb,Mosmlcgi,)}

   [cgi_remote_addr] is the value of REMOTE_ADDR\index{cgi_remote_addr@\verb,cgi_remote_addr,!value (\verb,Mosmlcgi,)}

   [cgi_remote_user] is the value of REMOTE_USER\index{cgi_remote_user@\verb,cgi_remote_user,!value (\verb,Mosmlcgi,)}

   [cgi_remote_ident] is the value of REMOTE_IDENT\index{cgi_remote_ident@\verb,cgi_remote_ident,!value (\verb,Mosmlcgi,)}

   [cgi_auth_type] is the value of AUTH_TYPE

   [cgi_content_type] is the value of CONTENT_TYPE

   [cgi_content_length] is the value of CONTENT_LENGTH, that is, the\index{cgi_content_length@\verb,cgi_content_length,!value (\verb,Mosmlcgi,)}
   length of the data transmitted in the CGI call.

   [cgi_annotation_server] is the value of ANNOTATION_SERVER\index{cgi_annotation_server@\verb,cgi_annotation_server,!value (\verb,Mosmlcgi,)}

   [cgi_http_cookie] is the value of HTTP_COOKIE\index{cgi_http_cookie@\verb,cgi_http_cookie,!value (\verb,Mosmlcgi,)}

   [cgi_http_forwarded] is the value of HTTP_FORWARDED\index{cgi_http_forwarded@\verb,cgi_http_forwarded,!value (\verb,Mosmlcgi,)}

   [cgi_http_host] is the value of HTTP_HOST\index{cgi_http_host@\verb,cgi_http_host,!value (\verb,Mosmlcgi,)}

   [cgi_http_proxy_connection] is the value of HTTP_PROXY_CONNECTION\index{cgi_http_proxy_connection@\verb,cgi_http_proxy_connection,!value (\verb,Mosmlcgi,)}

   [cgi_script_filename] is the value of SCRIPT_FILENAME\index{cgi_script_filename@\verb,cgi_script_filename,!value (\verb,Mosmlcgi,)}

   [cgi_document_root] is the value of DOCUMENT_ROOT\index{cgi_document_root@\verb,cgi_document_root,!value (\verb,Mosmlcgi,)}

   [cgi_server_admin] is the value of SERVER_ADMIN\index{cgi_server_admin@\verb,cgi_server_admin,!value (\verb,Mosmlcgi,)}

   [cgi_api_version] is the value of API_VERSION\index{cgi_api_version@\verb,cgi_api_version,!value (\verb,Mosmlcgi,)}

   [cgi_the_request] is the value of THE_REQUEST\index{cgi_the_request@\verb,cgi_the_request,!value (\verb,Mosmlcgi,)}

   [cgi_request_uri] is the value of REQUEST_URI\index{cgi_request_uri@\verb,cgi_request_uri,!value (\verb,Mosmlcgi,)}

   [cgi_request_filename] is the value of REQUEST_FILENAME\index{cgi_request_filename@\verb,cgi_request_filename,!value (\verb,Mosmlcgi,)}

   [cgi_is_subreq] is the value of IS_SUBREQ\index{cgi_is_subreq@\verb,cgi_is_subreq,!value (\verb,Mosmlcgi,)}
\end{longprogram}
\index{Mosmlcgi@\verb,Mosmlcgi, (structure)|)}\newpage

\section*{Module Mosmlcookie}
\index{Mosmlcookie@\verb,Mosmlcookie, (structure)|(}
\markboth{\MakeUppercase{Mosmlcookie}}{\MakeUppercase{Mosmlcookie}}
\addcontentsline{toc}{section}{Mosmlcookie}
\begin{longprogram}
{\itshape{}Mosmlcookie \verb"-"\verb"-" getting and setting cookies in CGI scripts }

exception CookieError of string\index{CookieError@\verb,CookieError,!exception (\verb,Mosmlcookie,)}

val allCookies     : string list\index{allCookies@\verb,allCookies,!value (\verb,Mosmlcookie,)}
val getCookieValue : string \verb"-"\verb">" string option \index{getCookieValue@\verb,getCookieValue,!value (\verb,Mosmlcookie,)}
val getCookie      : string \verb"-"\verb">" string option \index{getCookie@\verb,getCookie,!value (\verb,Mosmlcookie,)}

type cookiedata = \index{cookiedata@\verb,cookiedata,!type (\verb,Mosmlcookie,)}
    \verb"{" name   : string, 
      value  : string, 
      expiry : Date.date option, 
      domain : string option, 
      path   : string option, 
      secure : bool \verb"}"

val setCookie    : cookiedata \verb"-"\verb">" string\index{setCookie@\verb,setCookie,!value (\verb,Mosmlcookie,)}
val setCookies   : cookiedata list \verb"-"\verb">" string\index{setCookies@\verb,setCookies,!value (\verb,Mosmlcookie,)}

val deleteCookie : \verb"{" name : string, path : string option \verb"}" \verb"-"\verb">" string\index{deleteCookie@\verb,deleteCookie,!value (\verb,Mosmlcookie,)}

\separatingline
   These functions may be used in CGI scripts to get and set cookies.
   (c) Hans Molin, Computing Science Dept., Uppsala University, 1999.

   [getCookieValue ck] returns SOME(v) where v is the value associated\index{getCookieValue@\verb,getCookieValue,!value (\verb,Mosmlcookie,)}
   with the cookie ck, if any; otherwise returns NONE.

   [getCookie ck] returns SOME(nv) where nv is the ck=value string\index{getCookie@\verb,getCookie,!value (\verb,Mosmlcookie,)}
   for the cookie ck, if any; otherwise returns NONE.

   [allCookies] is a list [nv1, nv2, ..., nvm] of all the ck=value\index{allCookies@\verb,allCookies,!value (\verb,Mosmlcookie,)}
   pairs of defined cookies.

   [setCookie \verb"{" name, value, expiry, domain, path, secure \verb"}"] returns a\index{setCookie@\verb,setCookie,!value (\verb,Mosmlcookie,)}
   string which (when transmitted to a browser as part of the HTTP
   response header) sets a cookie with the given name, value, expiry
   date, domain, path, and security.

   [setCookies ckds] returns a string which (when transmitted to a\index{setCookies@\verb,setCookies,!value (\verb,Mosmlcookie,)}
   browser as part of the HTTP response header) sets the specified cookies.

   [deleteCookie \verb"{" name, path \verb"}"] returns a string which (when\index{deleteCookie@\verb,deleteCookie,!value (\verb,Mosmlcookie,)}
   transmitted to a browser as part of the HTTP response header)
   deletes the specified cookie by setting its expiry to some time in
   the past.
\end{longprogram}
\index{Mosmlcookie@\verb,Mosmlcookie, (structure)|)}\newpage

\section*{Module Msp}
\index{Msp@\verb,Msp, (structure)|(}
\markboth{\MakeUppercase{Msp}}{\MakeUppercase{Msp}}
\addcontentsline{toc}{section}{Msp}
\begin{longprogram}
{\itshape{}Msp \verb"-"\verb"-" utilities for CGI scripts and ML Server Pages }

{\itshape{}Efficiently concatenable word sequences }

datatype wseq = \index{wseq@\verb,wseq,!type (\verb,Msp,)}
    Empty                               {\itshape{}The empty sequence         }
  | Nl                                  {\itshape{}Newline                    }
  | \$ of string                         {\itshape{}A string                   }
  | \$\$ of string list                   {\itshape{}A sequence of strings      }
  | \&\& of wseq * wseq;                  {\itshape{}Concatenation of sequences }

{\itshape{}Manipulating wseqs }

val prmap    : ('a \verb"-"\verb">" wseq) \verb"-"\verb">" 'a list \verb"-"\verb">" wseq\index{prmap@\verb,prmap,!value (\verb,Msp,)}
val prsep    : wseq \verb"-"\verb">" ('a \verb"-"\verb">" wseq) \verb"-"\verb">" 'a list \verb"-"\verb">" wseq\index{prsep@\verb,prsep,!value (\verb,Msp,)}
val flatten  : wseq \verb"-"\verb">" string\index{flatten@\verb,flatten,!value (\verb,Msp,)}
val printseq : wseq \verb"-"\verb">" unit\index{printseq@\verb,printseq,!value (\verb,Msp,)}
val vec2list : 'a vector \verb"-"\verb">" 'a list\index{vec2list@\verb,vec2list,!value (\verb,Msp,)}


{\itshape{}Shorthands for accessing CGI parameters }

exception ParamMissing of string\index{ParamMissing@\verb,ParamMissing,!exception (\verb,Msp,)}
exception NotInt of string * string\index{NotInt@\verb,NotInt,!exception (\verb,Msp,)}

val \verb"%"        : string \verb"-"\verb">" string      \index{%@\verb,%,!value (\verb,Msp,)}
val \verb"%"?       : string \verb"-"\verb">" bool\index{%?@\verb,%?,!value (\verb,Msp,)}
val \verb"%"#       : string \verb"-"\verb">" int\index{%#@\verb,%#,!value (\verb,Msp,)}
val \verb"%"\verb"%"       : string * string \verb"-"\verb">" string\index{%%@\verb,%%,!value (\verb,Msp,)}
val \verb"%"\verb"%"#      : string * int \verb"-"\verb">" int\index{%%#@\verb,%%#,!value (\verb,Msp,)}


{\itshape{}HTML generic marks }

val mark0    : string \verb"-"\verb">" wseq\index{mark0@\verb,mark0,!value (\verb,Msp,)}
val mark0a   : string \verb"-"\verb">" string \verb"-"\verb">" wseq\index{mark0a@\verb,mark0a,!value (\verb,Msp,)}
val mark1    : string \verb"-"\verb">" wseq \verb"-"\verb">" wseq\index{mark1@\verb,mark1,!value (\verb,Msp,)}
val mark1a   : string \verb"-"\verb">" string \verb"-"\verb">" wseq \verb"-"\verb">" wseq\index{mark1a@\verb,mark1a,!value (\verb,Msp,)}
val comment  : wseq \verb"-"\verb">" wseq\index{comment@\verb,comment,!value (\verb,Msp,)}

{\itshape{}HTML documents and headers }

val html     : wseq \verb"-"\verb">" wseq\index{html@\verb,html,!value (\verb,Msp,)}
val head     : wseq \verb"-"\verb">" wseq\index{head@\verb,head,!value (\verb,Msp,)}
val title    : wseq \verb"-"\verb">" wseq\index{title@\verb,title,!value (\verb,Msp,)}
val body     : wseq \verb"-"\verb">" wseq\index{body@\verb,body,!value (\verb,Msp,)}
val bodya    : string \verb"-"\verb">" wseq \verb"-"\verb">" wseq\index{bodya@\verb,bodya,!value (\verb,Msp,)}
val htmldoc  : wseq \verb"-"\verb">" wseq \verb"-"\verb">" wseq\index{htmldoc@\verb,htmldoc,!value (\verb,Msp,)}

{\itshape{}HTML headings and vertical format }

val h1       : wseq \verb"-"\verb">" wseq\index{h1@\verb,h1,!value (\verb,Msp,)}
val h2       : wseq \verb"-"\verb">" wseq\index{h2@\verb,h2,!value (\verb,Msp,)}
val h3       : wseq \verb"-"\verb">" wseq\index{h3@\verb,h3,!value (\verb,Msp,)}
val h4       : wseq \verb"-"\verb">" wseq\index{h4@\verb,h4,!value (\verb,Msp,)}
val h5       : wseq \verb"-"\verb">" wseq\index{h5@\verb,h5,!value (\verb,Msp,)}
val h6       : wseq \verb"-"\verb">" wseq\index{h6@\verb,h6,!value (\verb,Msp,)}
val p        : wseq \verb"-"\verb">" wseq\index{p@\verb,p,!value (\verb,Msp,)}
val pa       : string \verb"-"\verb">" wseq \verb"-"\verb">" wseq\index{pa@\verb,pa,!value (\verb,Msp,)}
val br       : wseq\index{br@\verb,br,!value (\verb,Msp,)}
val bra      : string \verb"-"\verb">" wseq\index{bra@\verb,bra,!value (\verb,Msp,)}
val hr       : wseq\index{hr@\verb,hr,!value (\verb,Msp,)}
val hra      : string \verb"-"\verb">" wseq\index{hra@\verb,hra,!value (\verb,Msp,)}

val divi        : wseq \verb"-"\verb">" wseq\index{divi@\verb,divi,!value (\verb,Msp,)}
val divia       : string \verb"-"\verb">" wseq \verb"-"\verb">" wseq\index{divia@\verb,divia,!value (\verb,Msp,)}
val blockquote  : wseq \verb"-"\verb">" wseq\index{blockquote@\verb,blockquote,!value (\verb,Msp,)}
val blockquotea : string \verb"-"\verb">" wseq \verb"-"\verb">" wseq\index{blockquotea@\verb,blockquotea,!value (\verb,Msp,)}
val center      : wseq \verb"-"\verb">" wseq\index{center@\verb,center,!value (\verb,Msp,)}
val address     : wseq \verb"-"\verb">" wseq\index{address@\verb,address,!value (\verb,Msp,)}
val pre         : wseq \verb"-"\verb">" wseq\index{pre@\verb,pre,!value (\verb,Msp,)}

{\itshape{}HTML anchors and hyperlinks }

val ahref    : string \verb"-"\verb">" wseq \verb"-"\verb">" wseq\index{ahref@\verb,ahref,!value (\verb,Msp,)}
val ahrefa   : string \verb"-"\verb">" string \verb"-"\verb">" wseq \verb"-"\verb">" wseq\index{ahrefa@\verb,ahrefa,!value (\verb,Msp,)}
val aname    : string \verb"-"\verb">" wseq \verb"-"\verb">" wseq\index{aname@\verb,aname,!value (\verb,Msp,)}

{\itshape{}HTML text formats and style }

val em       : wseq \verb"-"\verb">" wseq\index{em@\verb,em,!value (\verb,Msp,)}
val strong   : wseq \verb"-"\verb">" wseq\index{strong@\verb,strong,!value (\verb,Msp,)}
val tt       : wseq \verb"-"\verb">" wseq\index{tt@\verb,tt,!value (\verb,Msp,)}
val sub      : wseq \verb"-"\verb">" wseq\index{sub@\verb,sub,!value (\verb,Msp,)}
val sup      : wseq \verb"-"\verb">" wseq\index{sup@\verb,sup,!value (\verb,Msp,)}
val fonta    : string \verb"-"\verb">" wseq \verb"-"\verb">" wseq\index{fonta@\verb,fonta,!value (\verb,Msp,)}

{\itshape{}HTML lists }

val ul       : wseq \verb"-"\verb">" wseq\index{ul@\verb,ul,!value (\verb,Msp,)}
val ula      : string \verb"-"\verb">" wseq \verb"-"\verb">" wseq\index{ula@\verb,ula,!value (\verb,Msp,)}
val ol       : wseq \verb"-"\verb">" wseq\index{ol@\verb,ol,!value (\verb,Msp,)}
val ola      : string \verb"-"\verb">" wseq \verb"-"\verb">" wseq\index{ola@\verb,ola,!value (\verb,Msp,)}
val li       : wseq \verb"-"\verb">" wseq\index{li@\verb,li,!value (\verb,Msp,)}
val dl       : wseq \verb"-"\verb">" wseq\index{dl@\verb,dl,!value (\verb,Msp,)}
val dla      : string \verb"-"\verb">" wseq \verb"-"\verb">" wseq\index{dla@\verb,dla,!value (\verb,Msp,)}
val dt       : wseq \verb"-"\verb">" wseq\index{dt@\verb,dt,!value (\verb,Msp,)}
val dd       : wseq \verb"-"\verb">" wseq\index{dd@\verb,dd,!value (\verb,Msp,)}

{\itshape{}HTML tables }

val table    : wseq \verb"-"\verb">" wseq\index{table@\verb,table,!value (\verb,Msp,)}
val tablea   : string \verb"-"\verb">" wseq \verb"-"\verb">" wseq\index{tablea@\verb,tablea,!value (\verb,Msp,)}
val tr       : wseq \verb"-"\verb">" wseq\index{tr@\verb,tr,!value (\verb,Msp,)}
val tra      : string \verb"-"\verb">" wseq \verb"-"\verb">" wseq\index{tra@\verb,tra,!value (\verb,Msp,)}
val td       : wseq \verb"-"\verb">" wseq\index{td@\verb,td,!value (\verb,Msp,)}
val tda      : string \verb"-"\verb">" wseq \verb"-"\verb">" wseq\index{tda@\verb,tda,!value (\verb,Msp,)}
val th       : wseq \verb"-"\verb">" wseq\index{th@\verb,th,!value (\verb,Msp,)}
val tha      : string \verb"-"\verb">" wseq \verb"-"\verb">" wseq\index{tha@\verb,tha,!value (\verb,Msp,)}
val caption  : wseq \verb"-"\verb">" wseq\index{caption@\verb,caption,!value (\verb,Msp,)}
val captiona : string \verb"-"\verb">" wseq \verb"-"\verb">" wseq\index{captiona@\verb,captiona,!value (\verb,Msp,)}

{\itshape{}HTML images and image maps }

val img      : string \verb"-"\verb">" wseq\index{img@\verb,img,!value (\verb,Msp,)}
val imga     : string \verb"-"\verb">" string \verb"-"\verb">" wseq\index{imga@\verb,imga,!value (\verb,Msp,)}
val map      : string \verb"-"\verb">" wseq \verb"-"\verb">" wseq\index{map@\verb,map,!value (\verb,Msp,)}
val mapa     : string \verb"-"\verb">" string \verb"-"\verb">" wseq \verb"-"\verb">" wseq\index{mapa@\verb,mapa,!value (\verb,Msp,)}
val area     : \verb"{" alt : string option, coords : string, \index{area@\verb,area,!value (\verb,Msp,)}
                 href : string option, shape : string\verb"}" \verb"-"\verb">" wseq

{\itshape{}HTML forms etc }

val form       : string \verb"-"\verb">" wseq \verb"-"\verb">" wseq\index{form@\verb,form,!value (\verb,Msp,)}
val forma      : string \verb"-"\verb">" string \verb"-"\verb">" wseq \verb"-"\verb">" wseq\index{forma@\verb,forma,!value (\verb,Msp,)}
val input      : string \verb"-"\verb">" wseq\index{input@\verb,input,!value (\verb,Msp,)}
val inputa     : string \verb"-"\verb">" string \verb"-"\verb">" wseq\index{inputa@\verb,inputa,!value (\verb,Msp,)}
val intext     : string \verb"-"\verb">" string \verb"-"\verb">" wseq\index{intext@\verb,intext,!value (\verb,Msp,)}
val inpassword : string \verb"-"\verb">" string \verb"-"\verb">" wseq\index{inpassword@\verb,inpassword,!value (\verb,Msp,)}
val incheckbox : \verb"{"name : string, value : string\verb"}" \verb"-"\verb">" string \verb"-"\verb">" wseq\index{incheckbox@\verb,incheckbox,!value (\verb,Msp,)}
val inradio    : \verb"{"name : string, value : string\verb"}" \verb"-"\verb">" string \verb"-"\verb">" wseq\index{inradio@\verb,inradio,!value (\verb,Msp,)}
val inreset    : string \verb"-"\verb">" string \verb"-"\verb">" wseq\index{inreset@\verb,inreset,!value (\verb,Msp,)}
val insubmit   : string \verb"-"\verb">" string \verb"-"\verb">" wseq\index{insubmit@\verb,insubmit,!value (\verb,Msp,)}
val inhidden   : \verb"{"name : string, value : string\verb"}" \verb"-"\verb">" wseq\index{inhidden@\verb,inhidden,!value (\verb,Msp,)}
val textarea   : string \verb"-"\verb">" wseq \verb"-"\verb">" wseq\index{textarea@\verb,textarea,!value (\verb,Msp,)}
val textareaa  : string \verb"-"\verb">" string \verb"-"\verb">" wseq \verb"-"\verb">" wseq\index{textareaa@\verb,textareaa,!value (\verb,Msp,)}
val select     : string \verb"-"\verb">" string \verb"-"\verb">" wseq \verb"-"\verb">" wseq\index{select@\verb,select,!value (\verb,Msp,)}
val option     : string \verb"-"\verb">" wseq\index{option@\verb,option,!value (\verb,Msp,)}

{\itshape{}HTML frames and framesets }

val frameset   : string \verb"-"\verb">" wseq \verb"-"\verb">" wseq\index{frameset@\verb,frameset,!value (\verb,Msp,)}
val frame      : \verb"{" src : string, name : string \verb"}" \verb"-"\verb">" wseq\index{frame@\verb,frame,!value (\verb,Msp,)}
val framea     : \verb"{" src : string, name : string \verb"}" \verb"-"\verb">" string \verb"-"\verb">" wseq\index{framea@\verb,framea,!value (\verb,Msp,)}

{\itshape{}HTML encoding  }

val urlencode  : string \verb"-"\verb">" string\index{urlencode@\verb,urlencode,!value (\verb,Msp,)}
val htmlencode : string \verb"-"\verb">" string\index{htmlencode@\verb,htmlencode,!value (\verb,Msp,)}


\separatingline
   This module provides support functions for writing CGI scripts and
   ML Server Page scripts.

   [wseq] is the type of efficiently concatenable word sequences.\index{wseq@\verb,wseq,!type (\verb,Msp,)}
   Building an HTML page (functionally) as a wseq is more efficient
   than building it (functionally) as a string, and more convenient
   and modular than building it (imperatively) by calling print.

   [Empty] represents the empty string "".\index{Empty@\verb,Empty,!constructor (\verb,Msp,)}

   [Nl] represents the string "\verb"\"n" consisting of a single newline character.\index{Nl@\verb,Nl,!constructor (\verb,Msp,)}

   [\$ s] represents the string s.\index{$@\verb,$,!constructor (\verb,Msp,)}

   [\$\$ ss] represents the string String.concat(ss).\index{$$@\verb,$$,!constructor (\verb,Msp,)}

   [\&\&(ws1, ws2)] represents the concatenation of the strings\index{&&@\verb,&&,!constructor (\verb,Msp,)}
   represented by ws1 and ws2.  The function \&\& should be declared
        infix \&\&

   [prmap f xs] is f x1 \&\& ... \&\& f xn evaluated from left to right, \index{prmap@\verb,prmap,!value (\verb,Msp,)}
   when xs is [x1, ..., xn].

   [prsep sep f xs] is f x1 \&\& sep \&\& ... \&\& sep \&\& f xn, evaluated\index{prsep@\verb,prsep,!value (\verb,Msp,)}
   from left to right, when xs is [x1, ..., xn].

   [flatten ws] is the string represented by ws.\index{flatten@\verb,flatten,!value (\verb,Msp,)}

   [printseq ws] is equivalent to print(flatten ws), but avoids\index{printseq@\verb,printseq,!value (\verb,Msp,)}
   building any new strings.

   [vec2list vec] is a list of the elements of vector vec.  Use it to\index{vec2list@\verb,vec2list,!value (\verb,Msp,)}
   convert e.g. the results of a database query into a list, for
   processing with prmap or prsep.


   Shorthands for accessing CGI parameters:

   [\verb"%"? fnm] returns true if there is a string associated with CGI\index{%?@\verb,%?,!value (\verb,Msp,)}
   parameter fnm; otherwise returns false.

   [\verb"%" fnm] returns a string associated with CGI parameter fnm if there\index{%@\verb,%,!value (\verb,Msp,)}
   is any; raises ParamMissing(fnm) if no strings are associated with
   fnm.  Equivalent to
       case Mosmlcgi.cgi_field_string fnm of 
           NONE   =\verb">" raise ParamMissing "fnm"
         | SOME v =\verb">" v
   In general, multiple strings may be associated with a CGI parameter; 
   use Mosmlcgi.cgi_field_strings if you need to access all of them.

   [\verb"%"# fnm] returns the integer i if there is a string associated with\index{%#@\verb,%#,!value (\verb,Msp,)}
   CGI parameter fnm, and that string is parsable as ML integer i.
   Raises ParamMissing(fnm) if no string is associated with fnm.
   Raises NotInt(fnm, s) if there is a string but it is not parsable
   as an ML int.

   [\verb"%"\verb"%"(fnm, dflt)] returns a string associated with CGI parameter fnm\index{%%@\verb,%%,!value (\verb,Msp,)}
   if there is any; otherwise returns the string dflt.

   [\verb"%"\verb"%"#(fnm, dflt)] returns the integer i if there is a string\index{%%#@\verb,%%#,!value (\verb,Msp,)}
   associated with CGI parameter fnm, and that string is parsable as
   an ML int; otherwise returns the string dflt.


   HTML generic marks:

   [mark0 t] generates the HTML tag \verb"<"t\verb">" as a wseq.\index{mark0@\verb,mark0,!value (\verb,Msp,)}

   [mark0a attr t] generates the attributed HTML tag \verb"<"t attr\verb">" as a wseq.\index{mark0a@\verb,mark0a,!value (\verb,Msp,)}

   [mark1 t ws] generates  \verb"<"t\verb">"ws\verb"<"/t\verb">"  as a wseq.\index{mark1@\verb,mark1,!value (\verb,Msp,)}

   [mark1a attr t ws] generates  \verb"<"t attr\verb">"ws\verb"<"/t\verb">" as a wseq.\index{mark1a@\verb,mark1a,!value (\verb,Msp,)}

   [comment ws] generates  \verb"<"!\verb"-"\verb"-"ws\verb"-"\verb"-"\verb">"  as a wseq.\index{comment@\verb,comment,!value (\verb,Msp,)}


   HTML documents and headers:

   [html ws] generates \verb"<"HTML\verb">"ws\verb"<"/HTML\verb">".\index{html@\verb,html,!value (\verb,Msp,)}

   [head ws] generates \verb"<"HEAD\verb">"ws\verb"<"/HEAD\verb">".\index{head@\verb,head,!value (\verb,Msp,)}

   [title ws] generates \verb"<"TITLE\verb">"ws\verb"<"/TITLE\verb">".\index{title@\verb,title,!value (\verb,Msp,)}

   [body ws] generates \verb"<"BODY\verb">"ws\verb"<"/BODY\verb">".\index{body@\verb,body,!value (\verb,Msp,)}

   [bodya attr ws] generates \verb"<"BODY attr\verb">"ws\verb"<"/BODY\verb">".\index{bodya@\verb,bodya,!value (\verb,Msp,)}

   [htmldoc titl ws] generates \index{htmldoc@\verb,htmldoc,!value (\verb,Msp,)}
   \verb"<"HTML\verb">"\verb"<"HEAD\verb">"\verb"<"TITLE\verb">"titl\verb"<"/TITLE\verb">"\verb"<"/HEAD\verb">"\verb"<"BODY\verb">"ws\verb"<"/BODY\verb">"\verb"<"/HTML\verb">".

   
   HTML headings and vertical format:

   [h1 ws] generates \verb"<"H1\verb">"ws\verb"<"/H1\verb">".\index{h1@\verb,h1,!value (\verb,Msp,)}

   [p ws] generates \verb"<"P\verb">"ws\verb"<"/P\verb">".\index{p@\verb,p,!value (\verb,Msp,)}

   [pa attr ws] generates \verb"<"P attr\verb">"ws\verb"<"/P\verb">".\index{pa@\verb,pa,!value (\verb,Msp,)}

   [br] generates \verb"<"BR\verb">".\index{br@\verb,br,!value (\verb,Msp,)}

   [bra attr] generates \verb"<"BR attr\verb">".\index{bra@\verb,bra,!value (\verb,Msp,)}

   [hr] generates \verb"<"HR\verb">".\index{hr@\verb,hr,!value (\verb,Msp,)}

   [hra attr] generates \verb"<"HR attr\verb">".\index{hra@\verb,hra,!value (\verb,Msp,)}

   [divi ws] generates \verb"<"DIV\verb">"ws\verb"<"/DIV\verb">".\index{divi@\verb,divi,!value (\verb,Msp,)}

   [divia attr ws] generates \verb"<"DIV attr\verb">"ws\verb"<"/DIV\verb">".\index{divia@\verb,divia,!value (\verb,Msp,)}

   [blockquote ws] generates \verb"<"BLOCKQUOTE\verb">"ws\verb"<"/BLOCKQUOTE\verb">".\index{blockquote@\verb,blockquote,!value (\verb,Msp,)}

   [blockquotea attr ws] generates \verb"<"BLOCKQUOTE attr\verb">"ws\verb"<"/BLOCKQUOTE\verb">" \index{blockquotea@\verb,blockquotea,!value (\verb,Msp,)}

   [center ws] generates \verb"<"CENTER\verb">"ws\verb"<"/CENTER\verb">".\index{center@\verb,center,!value (\verb,Msp,)}

   [address ws] generates \verb"<"ADDRESS\verb">"ws\verb"<"/ADDRESS\verb">".\index{address@\verb,address,!value (\verb,Msp,)}

   [pre ws] generates \verb"<"PRE\verb">"ws\verb"<"/PRE\verb">".\index{pre@\verb,pre,!value (\verb,Msp,)}


   HTML anchors and hyperlinks:

   [ahref link ws] generates \verb"<"A HREF="link"\verb">"ws\verb"<"/A\verb">".\index{ahref@\verb,ahref,!value (\verb,Msp,)}

   [ahrefa link attr ws] generates \verb"<"A HREF="link" attr\verb">"ws\verb"<"/A\verb">".\index{ahrefa@\verb,ahrefa,!value (\verb,Msp,)}

   [aname nam ws] generates \verb"<"A NAME="name"\verb">"ws\verb"<"/A\verb">".\index{aname@\verb,aname,!value (\verb,Msp,)}


   HTML text formats and style:

   [em ws] generates \verb"<"EM\verb">"ws\verb"<"/EM\verb">".\index{em@\verb,em,!value (\verb,Msp,)}

   [strong ws] generates \verb"<"STRONG\verb">"ws\verb"<"/STRONG\verb">".\index{strong@\verb,strong,!value (\verb,Msp,)}

   [tt ws] generates \verb"<"TT\verb">"ws\verb"<"/TT\verb">".\index{tt@\verb,tt,!value (\verb,Msp,)}

   [sub ws] generates \verb"<"SUB\verb">"ws\verb"<"/SUB\verb">".\index{sub@\verb,sub,!value (\verb,Msp,)}

   [sup ws] generates \verb"<"SUP\verb">"ws\verb"<"/SUP\verb">".\index{sup@\verb,sup,!value (\verb,Msp,)}

   [fonta attr ws] generates \verb"<"FONT attr\verb">"ws\verb"<"/FONT\verb">".\index{fonta@\verb,fonta,!value (\verb,Msp,)}


   HTML lists:

   [ul ws] generates \verb"<"UL\verb">"ws\verb"<"/UL\verb">".\index{ul@\verb,ul,!value (\verb,Msp,)}

   [ula attr ws] generates \verb"<"UL attr\verb">"ws\verb"<"/UL\verb">".\index{ula@\verb,ula,!value (\verb,Msp,)}

   [ol ws] generates \verb"<"OL\verb">"ws\verb"<"/OL\verb">".\index{ol@\verb,ol,!value (\verb,Msp,)}

   [ola attr ws] generates \verb"<"OL attr\verb">"ws\verb"<"/OL\verb">".\index{ola@\verb,ola,!value (\verb,Msp,)}

   [li ws] generates \verb"<"LI\verb">"ws\verb"<"/LI\verb">".\index{li@\verb,li,!value (\verb,Msp,)}

   [dl ws] generates \verb"<"DL\verb">"ws\verb"<"/DL\verb">".\index{dl@\verb,dl,!value (\verb,Msp,)}

   [dla attr ws] generates \verb"<"DL attr\verb">"ws\verb"<"/DL\verb">".\index{dla@\verb,dla,!value (\verb,Msp,)}

   [dt ws] generates \verb"<"DT\verb">"ws\verb"<"/DT\verb">".\index{dt@\verb,dt,!value (\verb,Msp,)}

   [dd ws] generates \verb"<"DD\verb">"ws\verb"<"/DD\verb">".\index{dd@\verb,dd,!value (\verb,Msp,)}


   HTML tables:

   [table ws] generates \verb"<"TABLE\verb">"ws\verb"<"/TABLE\verb">".\index{table@\verb,table,!value (\verb,Msp,)}

   [tablea attr ws] generates \verb"<"TABLE attr\verb">"ws\verb"<"/TABLE\verb">".\index{tablea@\verb,tablea,!value (\verb,Msp,)}

   [tr ws] generates \verb"<"TR\verb">"ws\verb"<"/TR\verb">".\index{tr@\verb,tr,!value (\verb,Msp,)}

   [tra attr ws] generates \verb"<"TR attr\verb">"ws\verb"<"/TR\verb">".\index{tra@\verb,tra,!value (\verb,Msp,)}

   [td ws] generates \verb"<"TD\verb">"ws\verb"<"/TD\verb">".\index{td@\verb,td,!value (\verb,Msp,)}

   [tda attr ws] generates \verb"<"TD attr\verb">"ws\verb"<"/TD\verb">".\index{tda@\verb,tda,!value (\verb,Msp,)}

   [th ws] generates \verb"<"TH\verb">"ws\verb"<"/TH\verb">".\index{th@\verb,th,!value (\verb,Msp,)}

   [tha attr ws] generates \verb"<"TH attr\verb">"ws\verb"<"/TH\verb">".\index{tha@\verb,tha,!value (\verb,Msp,)}

   [caption ws] generates \verb"<"CAPTION\verb">"ws\verb"<"/CAPTION\verb">".\index{caption@\verb,caption,!value (\verb,Msp,)}

   [captiona attr ws] generates \verb"<"CAPTION attr\verb">"ws\verb"<"/CAPTION\verb">".\index{captiona@\verb,captiona,!value (\verb,Msp,)}


   HTML images and image maps:

   [img s] generates \verb"<"IMG SRC="s"\verb">".\index{img@\verb,img,!value (\verb,Msp,)}

   [imga s attr] generates \verb"<"IMG SRC="s" attr\verb">".\index{imga@\verb,imga,!value (\verb,Msp,)}

   [map nam ws] generates \verb"<"MAP NAME="name"\verb">"ws\verb"<"/MAP\verb">".\index{map@\verb,map,!value (\verb,Msp,)}

   [mapa nam attr ws] generates \verb"<"MAP NAME="name" attr\verb">"ws\verb"<"/MAP\verb">".\index{mapa@\verb,mapa,!value (\verb,Msp,)}

   [area \verb"{" alt, coords, href, shape\verb"}"] generates\index{area@\verb,area,!value (\verb,Msp,)}
       \verb"<"AREA SHAPE="shape" COORDS="coords" HREF="link" ALT="desc"\verb">" 
   when href is SOME link (where HREF is replaced by NOHREF otherwise)
   and  alt  is SOME desc (where ALT is omitted otherwise).


   HTML forms etc:

   [form act ws] generates \verb"<"FORM ACTION="act"\verb">"ws\verb"<"/FORM\verb">".\index{form@\verb,form,!value (\verb,Msp,)}

   [forma act attr ws] generates \verb"<"FORM ACTION="act" attr\verb">"ws\verb"<"/FORM\verb">".\index{forma@\verb,forma,!value (\verb,Msp,)}

   [input typ] generates \verb"<"INPUT TYPE=typ\verb">".\index{input@\verb,input,!value (\verb,Msp,)}

   [inputa typ attr] generates \verb"<"INPUT TYPE=typ attr\verb">".\index{inputa@\verb,inputa,!value (\verb,Msp,)}

   [intext name attr] generates \verb"<"INPUT TYPE=TEXT NAME="name" attr\verb">".\index{intext@\verb,intext,!value (\verb,Msp,)}

   [inpassword name attr] generates \verb"<"INPUT TYPE=PASSWORD NAME="name" attr\verb">".\index{inpassword@\verb,inpassword,!value (\verb,Msp,)}

   [incheckbox \verb"{"name, value\verb"}" attr] generates \index{incheckbox@\verb,incheckbox,!value (\verb,Msp,)}
   \verb"<"INPUT TYPE=CHECKBOX NAME="name" VALUE="value" attr\verb">".

   [inradio \verb"{"name, value\verb"}" attr] generates \index{inradio@\verb,inradio,!value (\verb,Msp,)}
   \verb"<"INPUT TYPE=RADIO NAME="name" VALUE="value" attr\verb">".

   [inreset value attr] generates \verb"<"INPUT TYPE=RESET VALUE="value" attr\verb">".\index{inreset@\verb,inreset,!value (\verb,Msp,)}

   [insubmit value attr] generates \verb"<"INPUT TYPE=SUBMIT VALUE="value" attr\verb">".\index{insubmit@\verb,insubmit,!value (\verb,Msp,)}

   [inhidden \verb"{"name, value\verb"}"] generates\index{inhidden@\verb,inhidden,!value (\verb,Msp,)}
   \verb"<"INPUT TYPE=HIDDEN NAME="name" VALUE="value"\verb">".

   [textarea name ws] generates \verb"<"TEXTAREA NAME="name"\verb">"ws\verb"<"/TEXTAREA\verb">".\index{textarea@\verb,textarea,!value (\verb,Msp,)}

   [textareaa name attr ws] generates \index{textareaa@\verb,textareaa,!value (\verb,Msp,)}
   \verb"<"TEXTAREA NAME="name" attr\verb">"ws\verb"<"/TEXTAREA\verb">".

   [select name attr ws] generates \verb"<"SELECT NAME="name" attr\verb">"ws\verb"<"/SELECT\verb">".\index{select@\verb,select,!value (\verb,Msp,)}

   [option value] generates \verb"<"OPTION VALUE="value"\verb">".\index{option@\verb,option,!value (\verb,Msp,)}


   HTML frames and framesets:

   [frameset attr ws] generates \verb"<"FRAMESET attr\verb">"ws\verb"<"/FRAMESET\verb">".\index{frameset@\verb,frameset,!value (\verb,Msp,)}

   [frame \verb"{" src, name \verb"}"] generates \verb"<"FRAME SRC="src" NAME="name"\verb">".\index{frame@\verb,frame,!value (\verb,Msp,)}

   [framea \verb"{" src, name \verb"}" attr] generates \verb"<"FRAME SRC="src" NAME="name" attr\verb">".\index{framea@\verb,framea,!value (\verb,Msp,)}


   HTML encoding functions:

   [urlencode s] returns the url\verb"-"encoding of s.  That is, space (ASCII 32) \index{urlencode@\verb,urlencode,!value (\verb,Msp,)}
   is replaced by `+' and every non\verb"-"alphanumeric character c except 
   the characters \verb"-" _ . is replaced by \verb"%"hh, where hh is the hexadecimal 
   representation of the ASCII code of c.

   [htmlencode s] returns the html\verb"-"encoding of s.  That is, \verb"<" and \verb">"\index{htmlencode@\verb,htmlencode,!value (\verb,Msp,)}
   are replaced by \&lt; and \&gt; respectively, and \& is replaced by 
   \&amp;
\end{longprogram}
\index{Msp@\verb,Msp, (structure)|)}\newpage

\section*{Module Mysql}
\index{Mysql@\verb,Mysql, (structure)|(}
\markboth{\MakeUppercase{Mysql}}{\MakeUppercase{Mysql}}
\addcontentsline{toc}{section}{Mysql}
\begin{longprogram}
{\itshape{}Mysql \verb"-"\verb"-" interface to the MySQL database server \verb"-"\verb"-" requires Dynlib }

type dbconn                                   {\itshape{}Connection to server }\index{dbconn@\verb,dbconn,!type (\verb,Mysql,)}
type dbresult                                 {\itshape{}Result of a query    }\index{dbresult@\verb,dbresult,!type (\verb,Mysql,)}

exception Closed                              {\itshape{}Connection is closed }\index{Closed@\verb,Closed,!exception (\verb,Mysql,)}
exception Null                                {\itshape{}Field value is NULL  }\index{Null@\verb,Null,!exception (\verb,Mysql,)}

{\itshape{}Opening, closing, and maintaining database connections }

val openbase : \verb"{" dbhost    : string option,   {\itshape{}database server host }\index{openbase@\verb,openbase,!value (\verb,Mysql,)}
                 dbname    : string option,   {\itshape{}database name        }
                 dboptions : string option,   {\itshape{}(not used by MySQL)  }
                 dbport    : string option,   {\itshape{}database server port }
                 dbpwd     : string option,   {\itshape{}user passwd          }
                 dbtty     : string option,   {\itshape{}(not used by MySQL)  }
                 dbuser    : string option    {\itshape{}database user        }
               \verb"}" \verb"-"\verb">" dbconn

val closebase    : dbconn \verb"-"\verb">" unit\index{closebase@\verb,closebase,!value (\verb,Mysql,)}
val db           : dbconn \verb"-"\verb">" string\index{db@\verb,db,!value (\verb,Mysql,)}
val host         : dbconn \verb"-"\verb">" string option\index{host@\verb,host,!value (\verb,Mysql,)}
val options      : dbconn \verb"-"\verb">" string\index{options@\verb,options,!value (\verb,Mysql,)}
val port         : dbconn \verb"-"\verb">" string\index{port@\verb,port,!value (\verb,Mysql,)}
val tty          : dbconn \verb"-"\verb">" string\index{tty@\verb,tty,!value (\verb,Mysql,)}

val status       : dbconn \verb"-"\verb">" bool\index{status@\verb,status,!value (\verb,Mysql,)}
val reset        : dbconn \verb"-"\verb">" unit\index{reset@\verb,reset,!value (\verb,Mysql,)}
val errormessage : dbconn \verb"-"\verb">" string option\index{errormessage@\verb,errormessage,!value (\verb,Mysql,)}

{\itshape{}Query execution and result set information }

datatype dbresultstatus =\index{dbresultstatus@\verb,dbresultstatus,!type (\verb,Mysql,)}
    Bad_response            {\itshape{}(not used by mysql)                    }
  | Command_ok              {\itshape{}The query was a command                }
  | Copy_in                 {\itshape{}(not used by mysql)                    }
  | Copy_out                {\itshape{}(not used by mysql)                    }
  | Empty_query
  | Fatal_error             {\itshape{}(not used by mysql)                    }
  | Nonfatal_error
  | Tuples_ok               {\itshape{}The query successfully returned tuples }

val execute      : dbconn \verb"-"\verb">" string \verb"-"\verb">" dbresult\index{execute@\verb,execute,!value (\verb,Mysql,)}
val resultstatus : dbresult \verb"-"\verb">" dbresultstatus\index{resultstatus@\verb,resultstatus,!value (\verb,Mysql,)}
val ntuples      : dbresult \verb"-"\verb">" int\index{ntuples@\verb,ntuples,!value (\verb,Mysql,)}
val cmdtuples    : dbresult \verb"-"\verb">" int\index{cmdtuples@\verb,cmdtuples,!value (\verb,Mysql,)}
val nfields      : dbresult \verb"-"\verb">" int\index{nfields@\verb,nfields,!value (\verb,Mysql,)}
val fname        : dbresult \verb"-"\verb">" int \verb"-"\verb">" string\index{fname@\verb,fname,!value (\verb,Mysql,)}
val fnames       : dbresult \verb"-"\verb">" string vector\index{fnames@\verb,fnames,!value (\verb,Mysql,)}
val fnumber      : dbresult \verb"-"\verb">" string \verb"-"\verb">" int option\index{fnumber@\verb,fnumber,!value (\verb,Mysql,)}

{\itshape{}Accessing the fields of a resultset }

val getint       : dbresult \verb"-"\verb">" int \verb"-"\verb">" int \verb"-"\verb">" int\index{getint@\verb,getint,!value (\verb,Mysql,)}
val getreal      : dbresult \verb"-"\verb">" int \verb"-"\verb">" int \verb"-"\verb">" real\index{getreal@\verb,getreal,!value (\verb,Mysql,)}
val getstring    : dbresult \verb"-"\verb">" int \verb"-"\verb">" int \verb"-"\verb">" string\index{getstring@\verb,getstring,!value (\verb,Mysql,)}
val getdate      : dbresult \verb"-"\verb">" int \verb"-"\verb">" int \verb"-"\verb">" int * int * int   {\itshape{}Y M D }\index{getdate@\verb,getdate,!value (\verb,Mysql,)}
val gettime      : dbresult \verb"-"\verb">" int \verb"-"\verb">" int \verb"-"\verb">" int * int * int   {\itshape{}H M S }\index{gettime@\verb,gettime,!value (\verb,Mysql,)}
val getdatetime  : dbresult \verb"-"\verb">" int \verb"-"\verb">" int \verb"-"\verb">" Date.date\index{getdatetime@\verb,getdatetime,!value (\verb,Mysql,)}
val getbool      : dbresult \verb"-"\verb">" int \verb"-"\verb">" int \verb"-"\verb">" bool\index{getbool@\verb,getbool,!value (\verb,Mysql,)}
val isnull       : dbresult \verb"-"\verb">" int \verb"-"\verb">" int \verb"-"\verb">" bool\index{isnull@\verb,isnull,!value (\verb,Mysql,)}

datatype dynval =\index{dynval@\verb,dynval,!type (\verb,Mysql,)}
    Int of int                          {\itshape{}MySQL int4            }
  | Real of real                        {\itshape{}MySQL float8 (float4) }
  | String of string                    {\itshape{}MySQL text (varchar)  }
  | Date of int * int * int             {\itshape{}MySQL date yyyy\verb"-"mm\verb"-"dd }
  | Time of int * int * int             {\itshape{}MySQL time hh:mm:ss   }
  | DateTime of Date.date               {\itshape{}MySQL datetime        }
  | NullVal                             {\itshape{}MySQL NULL value      }

val getdynfield  : dbresult \verb"-"\verb">" int \verb"-"\verb">" int \verb"-"\verb">" dynval\index{getdynfield@\verb,getdynfield,!value (\verb,Mysql,)}
val getdyntup    : dbresult \verb"-"\verb">" int \verb"-"\verb">" dynval vector\index{getdyntup@\verb,getdyntup,!value (\verb,Mysql,)}
val getdyntups   : dbresult \verb"-"\verb">" dynval vector vector \index{getdyntups@\verb,getdyntups,!value (\verb,Mysql,)}
val dynval2s     : dynval \verb"-"\verb">" string\index{dynval2s@\verb,dynval2s,!value (\verb,Mysql,)}

{\itshape{}Bulk copying to or from a table }

val copytableto   : dbconn * string * (string \verb"-"\verb">" unit) \verb"-"\verb">" unit\index{copytableto@\verb,copytableto,!value (\verb,Mysql,)}
val copytablefrom : dbconn * string * ((string \verb"-"\verb">" unit) \verb"-"\verb">" unit) \verb"-"\verb">" unit\index{copytablefrom@\verb,copytablefrom,!value (\verb,Mysql,)}

{\itshape{}Some standard ML and MySQL types: }

datatype dyntype = \index{dyntype@\verb,dyntype,!type (\verb,Mysql,)}
    IntTy               {\itshape{}ML int               MySQL int4              }
  | RealTy              {\itshape{}ML real              MySQL float8, float4    }
  | StringTy            {\itshape{}ML string            MySQL text, varchar     } 
  | DateTy              {\itshape{}ML (yyyy, mth, day)  MySQL date              }
  | TimeTy              {\itshape{}ML (hh, mm, ss)      MySQL time              }
  | DateTimeTy          {\itshape{}ML Date.date         MySQL datetime, abstime }
  | UnknownTy

val fromtag : dyntype \verb"-"\verb">" string\index{fromtag@\verb,fromtag,!value (\verb,Mysql,)}
val ftype   : dbresult \verb"-"\verb">" int \verb"-"\verb">" dyntype\index{ftype@\verb,ftype,!value (\verb,Mysql,)}
val ftypes  : dbresult \verb"-"\verb">" dyntype Vector.vector\index{ftypes@\verb,ftypes,!value (\verb,Mysql,)}

val applyto : 'a \verb"-"\verb">" ('a \verb"-"\verb">" 'b) \verb"-"\verb">" 'b\index{applyto@\verb,applyto,!value (\verb,Mysql,)}

{\itshape{}Formatting the result of a database query as an HTML table }

val formattable : dbresult \verb"-"\verb">" Msp.wseq\index{formattable@\verb,formattable,!value (\verb,Mysql,)}
val showquery   : dbconn \verb"-"\verb">" string \verb"-"\verb">" Msp.wseq\index{showquery@\verb,showquery,!value (\verb,Mysql,)}

\separatingline
   [dbconn] is the type of connections to a MySQL database.\index{dbconn@\verb,dbconn,!type (\verb,Mysql,)}

   [dbresult] is the type of result sets from MySQL queries.\index{dbresult@\verb,dbresult,!type (\verb,Mysql,)}

   [openbase \verb"{" dbhost, dbport, dboptions, dbtty, dbname, dbuser, dbpwd \verb"}"] \index{openbase@\verb,openbase,!value (\verb,Mysql,)}
   opens a connection to a MySQL database server on the given host
   (default the local one) on the given port (default ?), to the given
   database (defaults to the user's login name), for the given user
   name (defaults to the current user's login name), and the given
   password (default none).  The result is a connection which may be
   used in subsequent queries.  In MySQL, unlike PostgreSQL, the
   dboptions and dbtty fields are not used.

   [closebase dbconn] closes the database connection.  No further\index{closebase@\verb,closebase,!value (\verb,Mysql,)}
   queries can be executed.

   [db dbconn] returns the name of the database.\index{db@\verb,db,!value (\verb,Mysql,)}

   [host dbconn] returns SOME h, where h is the database server host\index{host@\verb,host,!value (\verb,Mysql,)}
   name, if the connection uses the Internet; returns NONE if the
   connection is to a socket on the local server.

   [options dbconn] returns the options given when opening the database.\index{options@\verb,options,!value (\verb,Mysql,)}

   [port dbconn] returns the port number of the connection.\index{port@\verb,port,!value (\verb,Mysql,)}

   [tty dbconn] returns the name of the tty used for logging.\index{tty@\verb,tty,!value (\verb,Mysql,)}

   [status dbconn] returns true if the connection is usable, false\index{status@\verb,status,!value (\verb,Mysql,)}
   otherwise.

   [reset dbconn] attempts to close and then reopen the connection to\index{reset@\verb,reset,!value (\verb,Mysql,)}
   the database server.

   [errormessage dbconn] returns NONE if no error occurred, and SOME msg\index{errormessage@\verb,errormessage,!value (\verb,Mysql,)}
   if an error occurred, where msg describes the error.

   [execute dbconn query] sends an SQL query to the database server\index{execute@\verb,execute,!value (\verb,Mysql,)}
   for execution, and returns a resultset dbres.
   
   [resultstatus dbres] returns the status of the result set dbres.\index{resultstatus@\verb,resultstatus,!value (\verb,Mysql,)}
   After a select query that succeeded, it will be Tuples_ok.
   
   [ntuples dbres] returns the number of tuples in the result set\index{ntuples@\verb,ntuples,!value (\verb,Mysql,)}
   after a query.

   [cmdtuples dbres] returns the number of tuples affected by an\index{cmdtuples@\verb,cmdtuples,!value (\verb,Mysql,)}
   insert, update, or delete SQL command.

   [nfields dbres] returns the number of fields in each tuple after a\index{nfields@\verb,nfields,!value (\verb,Mysql,)}
   query.

   [fname dbres fno] returns the name of field number fno (in the\index{fname@\verb,fname,!value (\verb,Mysql,)}
   result set after a query).  The fields are numbered 0, 1,...

   [fnames dbres] returns a vector of the field names (in the result\index{fnames@\verb,fnames,!value (\verb,Mysql,)}
   set after a query).

   [fnumber dbres fname] returns SOME i where i is the number (0, 1,\index{fnumber@\verb,fnumber,!value (\verb,Mysql,)}
   ...) of the field called fname (in the result set after a query),
   if the result set contains such a field name; returns NONE otherwise.

   [ftype dbres fno] returns the dyntype of field number fno (in the
   result set after a query).

   [ftypes dbres] returns a vector of the dyntypes (in the result set
   after a query).

   [fromtag dt] returns the name of the preferred MySQL type used
   to represent values of the dyntype dt.  This may be used when
   building `create table' statements.

   [getint dbres fno tupno] returns the integer value of field number\index{getint@\verb,getint,!value (\verb,Mysql,)}
   fno in tuple tupno of result set dbres.  Raises Null if the value
   is NULL.

   [getreal dbres fno tupno] returns the floating\verb"-"point value of field\index{getreal@\verb,getreal,!value (\verb,Mysql,)}
   number fno in tuple tupno of result set dbres.  Raises Null if the
   value is NULL.

   [getstring dbres fno tupno] returns the string value of field\index{getstring@\verb,getstring,!value (\verb,Mysql,)}
   number fno in tuple tupno of result set dbres.  Raises Null if the
   value is NULL.

   [getdate dbres fno tupno] returns the date (yyyy, mth, day) value\index{getdate@\verb,getdate,!value (\verb,Mysql,)}
   of field number fno in tuple tupno of result set dbres.  Raises
   Null if the value is NULL.  Raises Fail if the field cannot be
   scanned as a date.

   [gettime dbres fno tupno] returns the time\verb"-"of\verb"-"day (hh, mm, ss)\index{gettime@\verb,gettime,!value (\verb,Mysql,)}
   value of field number fno in tuple tupno of result set dbres.
   Raises Null if the value is NULL.  Raises Fail if the field cannot
   be scanned as a time.

   [getdatetime dbres fno tupno] returns the Date.date value of field\index{getdatetime@\verb,getdatetime,!value (\verb,Mysql,)}
   number fno in tuple tupno of result set dbres.  Raises Null if the
   value is NULL.  Raises Fail if the field cannot be scanned as a
   date.

   [getbool dbres fno tupno] returns the boolean value of field number\index{getbool@\verb,getbool,!value (\verb,Mysql,)}
   fno in tuple tupno of result set dbres.  Raises Null if the value
   is NULL.

   [isnull dbres fno tupno] returns true if the value of field number\index{isnull@\verb,isnull,!value (\verb,Mysql,)}
   fno in tuple tupno of result set dbres is NULL; false otherwise.

   [getdynfield dbres fno tupno] returns the value of field number fno\index{getdynfield@\verb,getdynfield,!value (\verb,Mysql,)}
   in tuple tupno of result set dbres as a dynval (a wrapped value).
   A NULL value is returned as NullVal.  Note that the partial
   application  (getdynfield dbres fno)  precomputes the type of the 
   field fno.  Hence it is far more efficient to compute 
        let val getfno = getdynfield dbres fno
        in tabulate(ntuples dbres, getfno) end
   than to compute
        let fun getfno tupno = getdynfield dbres fno tupno
        in tabulate(ntuples dbres, getfno) end
   because the latter repeatedly computes the type of the field.

   [getdyntup dbres tupno] returns the fields of tuple tupno in result\index{getdyntup@\verb,getdyntup,!value (\verb,Mysql,)}
   set dbres as a vector of dynvals.

   [getdyntups dbres] returns all tuples of result set dbres as a\index{getdyntups@\verb,getdyntups,!value (\verb,Mysql,)}
   vector of vectors of dynvals.

   [dynval2s dv] returns a string representing the dynval dv.\index{dynval2s@\verb,dynval2s,!value (\verb,Mysql,)}

   [applyto x f] computes f(x).  This is convenient for applying\index{applyto@\verb,applyto,!value (\verb,Mysql,)}
   several functions (given in a list or vector) to the same value:
      map (applyto 5) (tabulate(3, getdynfield dbres))
   equals 
      [getdynfield dbres 0 5, getdynfield dbres 1 5, getdynfield dbres 2 5]

   [copytableto(dbconn, tablename, put)] simulates a PostgreSQL "COPY\index{copytableto@\verb,copytableto,!value (\verb,Mysql,)}
   TABLE TO" statement, applies the function put to every tuple of the
   table, represented as a line of text (not terminated by newline
   \verb"\"n), and cleans up at the end.  For instance, to copy the contents
   of a table t to a text stream s (one tuple on each line), define
      fun put line = 
          (TextIO.output(s, line); TextIO.output(s, "\verb"\"n"))
   and execute
      copytableto(dbconn, "t", put).

   [copytablefrom(dbconn, tablename, useput)] simulates a PostgreSQL\index{copytablefrom@\verb,copytablefrom,!value (\verb,Mysql,)}
   "COPY TABLE FROM" statement, creates a put function for copying
   lines to the table, passes the put function to useput, and cleans
   up at the end.  The put function may be called multiple times for
   each line (tuple); the end of each line is indicated by the
   newline character "\verb"\"n" as usual.  For instance, to copy the
   contents of a text stream s to a table t, define
      fun useput put = 
          while not (TextIO.endOfStream s) do put(TextIO.inputLine s);
   and execute
      copytablefrom(dbconn, "t", useput).
   Note that TextIO.inputLine preserves the newline at the end of each 
   line.  

   [formattable dbresult] returns a wseq representing an HTML table.\index{formattable@\verb,formattable,!value (\verb,Mysql,)}
   The HTML table has a column for every field in the dbresult.  The
   first row is a table header giving the names of the fields in the
   dbresult.  The remaining rows correspond to the tuples in the
   dbresult, in the order they are provided by the database server.
   Null fields are shown as NULL.

   [showquery dbconn query] sends the SQL query to the database\index{showquery@\verb,showquery,!value (\verb,Mysql,)}
   server, then uses formattable to format the result of the query.
\end{longprogram}
\index{Mysql@\verb,Mysql, (structure)|)}\newpage

\section*{Module NJ93}
\index{NJ93@\verb,NJ93, (structure)|(}
\markboth{\MakeUppercase{NJ93}}{\MakeUppercase{NJ93}}
\addcontentsline{toc}{section}{NJ93}
\begin{longprogram}
{\itshape{}NJ93 \verb"-"\verb"-" compatibility SML/NJ 0.93 top\verb"-"level environment }

val print     : string \verb"-"\verb">" unit\index{print@\verb,print,!value (\verb,NJ93,)}

{\itshape{}NJ93 Integer }

val max       : int * int \verb"-"\verb">" int\index{max@\verb,max,!value (\verb,NJ93,)}
val min       : int * int \verb"-"\verb">" int\index{min@\verb,min,!value (\verb,NJ93,)}

{\itshape{}NJ93 List }

exception Hd and Tl and Nth and NthTail\index{Hd@\verb,Hd,!exception (\verb,NJ93,)}

val hd        : 'a list \verb"-"\verb">" 'a             {\itshape{}Hd }\index{hd@\verb,hd,!value (\verb,NJ93,)}
val tl        : 'a list \verb"-"\verb">" 'a list        {\itshape{}Tl }\index{tl@\verb,tl,!value (\verb,NJ93,)}
val nth       : 'a list * int \verb"-"\verb">" 'a       {\itshape{}Nth }\index{nth@\verb,nth,!value (\verb,NJ93,)}
val nthtail   : 'a list * int \verb"-"\verb">" 'a list  {\itshape{}NthTail }\index{nthtail@\verb,nthtail,!value (\verb,NJ93,)}
val app       : ('a \verb"-"\verb">" 'b) \verb"-"\verb">" 'a list \verb"-"\verb">" unit\index{app@\verb,app,!value (\verb,NJ93,)}
val revapp    : ('a \verb"-"\verb">" 'b) \verb"-"\verb">" 'a list \verb"-"\verb">" unit\index{revapp@\verb,revapp,!value (\verb,NJ93,)}
val fold      : ('a * 'b \verb"-"\verb">" 'b) \verb"-"\verb">" 'a list \verb"-"\verb">" 'b \verb"-"\verb">" 'b\index{fold@\verb,fold,!value (\verb,NJ93,)}
val revfold   : ('a * 'b \verb"-"\verb">" 'b) \verb"-"\verb">" 'a list \verb"-"\verb">" 'b \verb"-"\verb">" 'b\index{revfold@\verb,revfold,!value (\verb,NJ93,)}

{\itshape{}NJ93 Real }

val ceiling   : real \verb"-"\verb">" int\index{ceiling@\verb,ceiling,!value (\verb,NJ93,)}
val truncate  : real \verb"-"\verb">" int \index{truncate@\verb,truncate,!value (\verb,NJ93,)}

{\itshape{}NJ93 Ref }

val inc       : int ref \verb"-"\verb">" unit\index{inc@\verb,inc,!value (\verb,NJ93,)}
val dec       : int ref \verb"-"\verb">" unit\index{dec@\verb,dec,!value (\verb,NJ93,)}

{\itshape{}NJ93 String }

exception Substring\index{Substring@\verb,Substring,!exception (\verb,NJ93,)}

val ordof     : string * int \verb"-"\verb">" int\index{ordof@\verb,ordof,!value (\verb,NJ93,)}
val ord       : string \verb"-"\verb">" int                   {\itshape{}Ord }\index{ord@\verb,ord,!value (\verb,NJ93,)}
val chr       : int \verb"-"\verb">" string                   {\itshape{}Chr }\index{chr@\verb,chr,!value (\verb,NJ93,)}
val substring : string * int * int \verb"-"\verb">" string    {\itshape{}Substring }\index{substring@\verb,substring,!value (\verb,NJ93,)}
val explode   : string \verb"-"\verb">" string list\index{explode@\verb,explode,!value (\verb,NJ93,)}
val implode   : string list \verb"-"\verb">" string\index{implode@\verb,implode,!value (\verb,NJ93,)}

{\itshape{}NJ93 top\verb"-"level math functions }

val sqrt      : real \verb"-"\verb">" real\index{sqrt@\verb,sqrt,!value (\verb,NJ93,)}
val sin       : real \verb"-"\verb">" real\index{sin@\verb,sin,!value (\verb,NJ93,)}
val cos       : real \verb"-"\verb">" real\index{cos@\verb,cos,!value (\verb,NJ93,)}
val arctan    : real \verb"-"\verb">" real\index{arctan@\verb,arctan,!value (\verb,NJ93,)}
val exp       : real \verb"-"\verb">" real\index{exp@\verb,exp,!value (\verb,NJ93,)}
val ln        : real \verb"-"\verb">" real\index{ln@\verb,ln,!value (\verb,NJ93,)}

{\itshape{}NJ93 top\verb"-"level input/output, standard }

type instream and outstream\index{instream@\verb,instream,!type (\verb,NJ93,)}

val std_in        : instream\index{std_in@\verb,std_in,!value (\verb,NJ93,)}
val open_in       : string \verb"-"\verb">" instream\index{open_in@\verb,open_in,!value (\verb,NJ93,)}
val input         : instream * int \verb"-"\verb">" string\index{input@\verb,input,!value (\verb,NJ93,)}
val lookahead     : instream \verb"-"\verb">" string\index{lookahead@\verb,lookahead,!value (\verb,NJ93,)}
val close_in      : instream \verb"-"\verb">" unit\index{close_in@\verb,close_in,!value (\verb,NJ93,)}
val end_of_stream : instream \verb"-"\verb">" bool\index{end_of_stream@\verb,end_of_stream,!value (\verb,NJ93,)}

val std_out       : outstream\index{std_out@\verb,std_out,!value (\verb,NJ93,)}
val open_out      : string \verb"-"\verb">" outstream\index{open_out@\verb,open_out,!value (\verb,NJ93,)}
val output        : outstream * string \verb"-"\verb">" unit\index{output@\verb,output,!value (\verb,NJ93,)}
val close_out     : outstream \verb"-"\verb">" unit\index{close_out@\verb,close_out,!value (\verb,NJ93,)}

{\itshape{}NJ93 top\verb"-"level input/output, non\verb"-"standard }

val open_in_bin   : string \verb"-"\verb">" instream\index{open_in_bin@\verb,open_in_bin,!value (\verb,NJ93,)}
val open_out_bin  : string \verb"-"\verb">" outstream\index{open_out_bin@\verb,open_out_bin,!value (\verb,NJ93,)}
val inputc        : instream \verb"-"\verb">" int \verb"-"\verb">" string\index{inputc@\verb,inputc,!value (\verb,NJ93,)}
val std_err       : outstream\index{std_err@\verb,std_err,!value (\verb,NJ93,)}
val outputc       : outstream \verb"-"\verb">" string \verb"-"\verb">" unit\index{outputc@\verb,outputc,!value (\verb,NJ93,)}
val flush_out     : outstream \verb"-"\verb">" unit\index{flush_out@\verb,flush_out,!value (\verb,NJ93,)}
val input_line    : instream \verb"-"\verb">" string\index{input_line@\verb,input_line,!value (\verb,NJ93,)}
val can_input     : instream * int \verb"-"\verb">" bool\index{can_input@\verb,can_input,!value (\verb,NJ93,)}
val open_append   : string \verb"-"\verb">" outstream\index{open_append@\verb,open_append,!value (\verb,NJ93,)}
\end{longprogram}
\index{NJ93@\verb,NJ93, (structure)|)}\newpage

\section*{Module Nonstdio}
\index{Nonstdio@\verb,Nonstdio, (structure)|(}
\markboth{\MakeUppercase{Nonstdio}}{\MakeUppercase{Nonstdio}}
\addcontentsline{toc}{section}{Nonstdio}
\begin{longprogram}
{\itshape{}Nonstdio \verb"-"\verb"-" non\verb"-"standard I/O \verb"-"\verb"-" use BinIO and TextIO instead }

local open BasicIO in

val open_in_bin       : string \verb"-"\verb">" instream\index{open_in_bin@\verb,open_in_bin,!value (\verb,Nonstdio,)}
val buff_input        : instream \verb"-"\verb">" CharArray.array \verb"-"\verb">" int \verb"-"\verb">" int \verb"-"\verb">" int\index{buff_input@\verb,buff_input,!value (\verb,Nonstdio,)}
val input_char        : instream \verb"-"\verb">" char		{\itshape{}Raises Size }\index{input_char@\verb,input_char,!value (\verb,Nonstdio,)}
val input_binary_int  : instream \verb"-"\verb">" int\index{input_binary_int@\verb,input_binary_int,!value (\verb,Nonstdio,)}
val input_value       : instream \verb"-"\verb">" 'a\index{input_value@\verb,input_value,!value (\verb,Nonstdio,)}
val seek_in           : instream \verb"-"\verb">" int \verb"-"\verb">" unit\index{seek_in@\verb,seek_in,!value (\verb,Nonstdio,)}
val pos_in            : instream \verb"-"\verb">" int\index{pos_in@\verb,pos_in,!value (\verb,Nonstdio,)}
val in_stream_length  : instream \verb"-"\verb">" int\index{in_stream_length@\verb,in_stream_length,!value (\verb,Nonstdio,)}
val fast_really_input : instream \verb"-"\verb">" string \verb"-"\verb">" int \verb"-"\verb">"  int \verb"-"\verb">" unit\index{fast_really_input@\verb,fast_really_input,!value (\verb,Nonstdio,)}

val open_out_bin      : string \verb"-"\verb">" outstream\index{open_out_bin@\verb,open_out_bin,!value (\verb,Nonstdio,)}
val open_out_exe      : string \verb"-"\verb">" outstream\index{open_out_exe@\verb,open_out_exe,!value (\verb,Nonstdio,)}
val output_char       : outstream \verb"-"\verb">" Char.char \verb"-"\verb">" unit\index{output_char@\verb,output_char,!value (\verb,Nonstdio,)}
val output_byte       : outstream \verb"-"\verb">" int \verb"-"\verb">" unit\index{output_byte@\verb,output_byte,!value (\verb,Nonstdio,)}
val buff_output       : outstream \verb"-"\verb">" CharArray.array \verb"-"\verb">" int \verb"-"\verb">" int \verb"-"\verb">" unit\index{buff_output@\verb,buff_output,!value (\verb,Nonstdio,)}
val output_binary_int : outstream \verb"-"\verb">" int \verb"-"\verb">" unit\index{output_binary_int@\verb,output_binary_int,!value (\verb,Nonstdio,)}
val output_value      : outstream \verb"-"\verb">" 'a \verb"-"\verb">" unit\index{output_value@\verb,output_value,!value (\verb,Nonstdio,)}
val seek_out          : outstream \verb"-"\verb">" int \verb"-"\verb">" unit\index{seek_out@\verb,seek_out,!value (\verb,Nonstdio,)}
val pos_out           : outstream \verb"-"\verb">" int\index{pos_out@\verb,pos_out,!value (\verb,Nonstdio,)}

val file_exists       : string \verb"-"\verb">" bool\index{file_exists@\verb,file_exists,!value (\verb,Nonstdio,)}

end
\end{longprogram}
\index{Nonstdio@\verb,Nonstdio, (structure)|)}\newpage

\section*{Module OS}
\index{OS@\verb,OS, (structure)|(}
\markboth{\MakeUppercase{OS}}{\MakeUppercase{OS}}
\addcontentsline{toc}{section}{OS}
\begin{longprogram}
{\itshape{}OS \verb"-"\verb"-" SML Basis Library }

signature OS = sig

type syserror = syserror\index{syserror@\verb,syserror,!type (\verb,OS,)}

exception SysErr of string * syserror option\index{SysErr@\verb,SysErr,!exception (\verb,OS,)}

val errorMsg      : syserror \verb"-"\verb">" string\index{errorMsg@\verb,errorMsg,!value (\verb,OS,)}

structure FileSys : FileSys
structure Path    : Path
structure Process : Process

end

\separatingline

   [errorMsg err] returns a string explaining the error message system\index{errorMsg@\verb,errorMsg,!value (\verb,OS,)}
   error code err, as found in a SysErr exception.  The precise form
   of the string depends on the operating system.  
\end{longprogram}
\index{OS@\verb,OS, (structure)|)}\newpage

\section*{Module Option}
\index{Option@\verb,Option, (structure)|(}
\markboth{\MakeUppercase{Option}}{\MakeUppercase{Option}}
\addcontentsline{toc}{section}{Option}
\begin{longprogram}
{\itshape{}Option \verb"-"\verb"-" SML Basis Library }

exception Option\index{Option@\verb,Option,!exception (\verb,Option,)}

datatype option = datatype option\index{option@\verb,option,!type (\verb,Option,)}

val getOpt         : 'a option * 'a \verb"-"\verb">" 'a \index{getOpt@\verb,getOpt,!value (\verb,Option,)}
val isSome         : 'a option \verb"-"\verb">" bool \index{isSome@\verb,isSome,!value (\verb,Option,)}
val valOf          : 'a option \verb"-"\verb">" 'a \index{valOf@\verb,valOf,!value (\verb,Option,)}
val filter         : ('a \verb"-"\verb">" bool) \verb"-"\verb">" 'a \verb"-"\verb">" 'a option \index{filter@\verb,filter,!value (\verb,Option,)}
val map            : ('a \verb"-"\verb">" 'b) \verb"-"\verb">" 'a option \verb"-"\verb">" 'b option\index{map@\verb,map,!value (\verb,Option,)}
val app            : ('a \verb"-"\verb">" unit) \verb"-"\verb">" 'a option \verb"-"\verb">" unit\index{app@\verb,app,!value (\verb,Option,)}
val join           : 'a option option \verb"-"\verb">" 'a option\index{join@\verb,join,!value (\verb,Option,)}
val compose        : ('a \verb"-"\verb">" 'b) * ('c \verb"-"\verb">" 'a option) \verb"-"\verb">" ('c \verb"-"\verb">" 'b option)\index{compose@\verb,compose,!value (\verb,Option,)}
val mapPartial     : ('a \verb"-"\verb">" 'b option) \verb"-"\verb">" ('a option \verb"-"\verb">" 'b option)\index{mapPartial@\verb,mapPartial,!value (\verb,Option,)}
val composePartial : ('a \verb"-"\verb">" 'b option) * ('c \verb"-"\verb">" 'a option) \verb"-"\verb">" ('c \verb"-"\verb">" 'b option)\index{composePartial@\verb,composePartial,!value (\verb,Option,)}

\separatingline
   [getOpt (xopt, d)] returns x if xopt is SOME x; returns d otherwise.\index{getOpt@\verb,getOpt,!value (\verb,Option,)}

   [isSome vopt] returns true if xopt is SOME x; returns false otherwise.\index{isSome@\verb,isSome,!value (\verb,Option,)}

   [valOf vopt] returns x if xopt is SOME x; raises Option otherwise.\index{valOf@\verb,valOf,!value (\verb,Option,)}

   [filter p x] returns SOME x if p x is true; returns NONE otherwise.\index{filter@\verb,filter,!value (\verb,Option,)}

   [map f xopt] returns SOME (f x) if xopt is SOME x; returns NONE otherwise.\index{map@\verb,map,!value (\verb,Option,)}

   [app f xopt] applies f to x if xopt is SOME x; does nothing otherwise.\index{app@\verb,app,!value (\verb,Option,)}

   [join xopt] returns x if xopt is SOME x; returns NONE otherwise.\index{join@\verb,join,!value (\verb,Option,)}

   [compose (f, g) x] returns SOME (f y) if g x is SOME y; returns NONE \index{compose@\verb,compose,!value (\verb,Option,)}
   otherwise.  It holds that compose (f, g) = map f o g.

   [mapPartial f xopt] returns f x if xopt is SOME x; returns NONE otherwise.  \index{mapPartial@\verb,mapPartial,!value (\verb,Option,)}
   It holds that mapPartial f = join o map f.

   [composePartial (f, g) x] returns f y if g x is SOME y; returns NONE \index{composePartial@\verb,composePartial,!value (\verb,Option,)}
   otherwise.  It holds that composePartial (f, g) = mapPartial f o g.

   The operators (map, join, SOME) form a monad.
\end{longprogram}
\index{Option@\verb,Option, (structure)|)}\newpage

\section*{Module PP}
\index{PP@\verb,PP, (structure)|(}
\markboth{\MakeUppercase{PP}}{\MakeUppercase{PP}}
\addcontentsline{toc}{section}{PP}
\begin{longprogram}
{\itshape{}PP \verb"-"\verb"-" pretty\verb"-"printing \verb"-"\verb"-" from the SML/NJ library }

type ppconsumer = \verb"{" consumer  : string \verb"-"\verb">" unit,\index{ppconsumer@\verb,ppconsumer,!type (\verb,PP,)}
                    linewidth : int,
                    flush     : unit \verb"-"\verb">" unit \verb"}"

datatype break_style = \index{break_style@\verb,break_style,!type (\verb,PP,)}
    CONSISTENT
  | INCONSISTENT

val mk_ppstream    : ppconsumer \verb"-"\verb">" ppstream\index{mk_ppstream@\verb,mk_ppstream,!value (\verb,PP,)}
val dest_ppstream  : ppstream \verb"-"\verb">" ppconsumer\index{dest_ppstream@\verb,dest_ppstream,!value (\verb,PP,)}
val add_break      : ppstream \verb"-"\verb">" int * int \verb"-"\verb">" unit\index{add_break@\verb,add_break,!value (\verb,PP,)}
val add_newline    : ppstream \verb"-"\verb">" unit\index{add_newline@\verb,add_newline,!value (\verb,PP,)}
val add_string     : ppstream \verb"-"\verb">" string \verb"-"\verb">" unit\index{add_string@\verb,add_string,!value (\verb,PP,)}
val begin_block    : ppstream \verb"-"\verb">" break_style \verb"-"\verb">" int \verb"-"\verb">" unit\index{begin_block@\verb,begin_block,!value (\verb,PP,)}
val end_block      : ppstream \verb"-"\verb">" unit\index{end_block@\verb,end_block,!value (\verb,PP,)}
val clear_ppstream : ppstream \verb"-"\verb">" unit\index{clear_ppstream@\verb,clear_ppstream,!value (\verb,PP,)}
val flush_ppstream : ppstream \verb"-"\verb">" unit\index{flush_ppstream@\verb,flush_ppstream,!value (\verb,PP,)}
val with_pp        : ppconsumer \verb"-"\verb">" (ppstream \verb"-"\verb">" unit) \verb"-"\verb">" unit\index{with_pp@\verb,with_pp,!value (\verb,PP,)}
val pp_to_string   : int \verb"-"\verb">" (ppstream \verb"-"\verb">" 'a \verb"-"\verb">" unit) \verb"-"\verb">" 'a \verb"-"\verb">" string\index{pp_to_string@\verb,pp_to_string,!value (\verb,PP,)}

\separatingline
   This structure provides tools for creating customized Oppen\verb"-"style
   pretty\verb"-"printers, based on the type ppstream.  A ppstream is an
   output stream that contains prettyprinting commands.  The commands
   are placed in the stream by various function calls listed below.

   There following primitives add commands to the stream:
   begin_block, end_block, add_string, add_break, and add_newline.
   All calls to add_string, add_break, and add_newline must happen
   between a pair of calls to begin_block and end_block must be
   properly nested dynamically.  All calls to begin_block and
   end_block must be properly nested (dynamically).

   [ppconsumer] is the type of sinks for pretty\verb"-"printing.  A value of \index{ppconsumer@\verb,ppconsumer,!type (\verb,PP,)}
   type ppconsumer is a record \index{ppconsumer@\verb,ppconsumer,!type (\verb,PP,)}
                 \verb"{" consumer  : string \verb"-"\verb">" unit,
                   linewidth : int,
                   flush     : unit \verb"-"\verb">" unit \verb"}"
   of a string consumer, a specified linewidth, and a flush function
   which is called whenever flush_ppstream is called.

   A prettyprinter can be called outright to print a value.  In
   addition, a prettyprinter for a base type or nullary datatype ty
   can be installed in the top\verb"-"level system.  Then the installed
   prettyprinter will be invoked automatically whenever a value of
   type ty is to be printed.

   [break_style] is the type of line break styles for blocks:\index{break_style@\verb,break_style,!type (\verb,PP,)}

   [CONSISTENT] specifies that if any line break occurs inside the\index{CONSISTENT@\verb,CONSISTENT,!constructor (\verb,PP,)}
   block, then all indicated line breaks occur.

   [INCONSISTENT] specifies that breaks will be inserted to only to\index{INCONSISTENT@\verb,INCONSISTENT,!constructor (\verb,PP,)}
   avoid overfull lines.

   [mk_ppstream \verb"{"consumer, linewidth, flush\verb"}"] creates a new ppstream\index{mk_ppstream@\verb,mk_ppstream,!value (\verb,PP,)}
   which invokes the consumer to output text, putting at most
   linewidth characters on each line.

   [dest_ppstream ppstrm] extracts the linewidth, flush function, and\index{dest_ppstream@\verb,dest_ppstream,!value (\verb,PP,)}
   consumer from a ppstream.

   [add_break ppstrm (size, offset)] notifies the pretty\verb"-"printer that\index{add_break@\verb,add_break,!value (\verb,PP,)}
   a line break is possible at this point.  
   * When the current block style is CONSISTENT:
      ** if the entire block fits on the remainder of the line, then
         output size spaces; else
      ** increase the current indentation by the block offset;
         further indent every item of the block by offset, and add
         one newline at every add_break in the block.
   * When the current block style is INCONSISTENT:
      ** if the next component of the block fits on the remainder of
         the line, then output size spaces; else
      ** issue a newline and indent to the current indentation level
         plus the block offset plus the offset.

   [add_newline ppstrm] issues a newline.\index{add_newline@\verb,add_newline,!value (\verb,PP,)}

   [add_string ppstrm str] outputs the string str to the ppstream.\index{add_string@\verb,add_string,!value (\verb,PP,)}

   [begin_block ppstrm style blockoffset] begins a new block and\index{begin_block@\verb,begin_block,!value (\verb,PP,)}
   level of indentation, with the given style and block offset.

   [end_block ppstrm] closes the current block.  \index{end_block@\verb,end_block,!value (\verb,PP,)}

   [clear_ppstream ppstrm] restarts the stream, without affecting the\index{clear_ppstream@\verb,clear_ppstream,!value (\verb,PP,)}
   underlying consumer.

   [flush_ppstream ppstrm] executes any remaining commands in the\index{flush_ppstream@\verb,flush_ppstream,!value (\verb,PP,)}
   ppstream (that is, flushes currently accumulated output to the
   consumer associated with ppstrm); executes the flush function
   associated with the consumer; and calls clear_ppstream.

   [with_pp consumer f] makes a new ppstream from the consumer and\index{with_pp@\verb,with_pp,!value (\verb,PP,)}
   applies f (which can be thought of as a producer) to that
   ppstream, then flushed the ppstream and returns the value of f.

   [pp_to_string linewidth printit x] constructs a new ppstream\index{pp_to_string@\verb,pp_to_string,!value (\verb,PP,)}
   ppstrm whose consumer accumulates the output in a string s.  Then
   evaluates (printit ppstrm x) and finally returns the string s.

   
   Example 1: A simple prettyprinter for Booleans:

       load "PP";
       fun ppbool pps d = 
           let open PP
           in
               begin_block pps INCONSISTENT 6; 
               add_string pps (if d then "right" else "wrong");
               end_block pps
           end;

   Now one may define a ppstream to print to, and exercise it:

       val ppstrm = PP.mk_ppstream \verb"{"consumer  = 
                                    fn s =\verb">" TextIO.output(TextIO.stdOut, s), 
                                    linewidth = 72,
                                    flush     = 
                                     fn () =\verb">" TextIO.flushOut TextIO.stdOut\verb"}";

       fun ppb b = (ppbool ppstrm b; PP.flush_ppstream ppstrm);

       \verb"-" ppb false;
       wrong\verb">" val it = () : unit   

   The prettyprinter may also be installed in the toplevel system;
   then it will be used to print all expressions of type bool
   subsequently computed:

       \verb"-" installPP ppbool;
       \verb">" val it = () : unit
       \verb"-" 1=0;
       \verb">" val it = wrong : bool
       \verb"-" 1=1;
       \verb">" val it = right : bool

   See library Meta for a description of installPP.


   Example 2: Prettyprinting simple expressions (examples/pretty/ppexpr.sml):

       datatype expr = 
           Cst of int 
         | Neg of expr
         | Plus of expr * expr

       fun ppexpr pps e0 = 
           let open PP
               fun ppe (Cst i)        = add_string pps (Int.toString i)
                 | ppe (Neg e)        = (add_string pps "~"; ppe e)
                 | ppe (Plus(e1, e2)) = (begin_block pps CONSISTENT 0;
                                         add_string pps "(";
                                         ppe e1; 
                                         add_string pps " + ";
                                         add_break pps (0, 1);
                                         ppe e2; 
                                         add_string pps ")";
                                         end_block pps)
           in
               begin_block pps INCONSISTENT 0; 
               ppe e0;
               end_block pps
           end

       val _ = installPP ppexpr;

       {\itshape{}Some example values: }

       val e1 = Cst 1;
       val e2 = Cst 2;
       val e3 = Plus(e1, Neg e2);
       val e4 = Plus(Neg e3, e3);
       val e5 = Plus(Neg e4, e4);
       val e6 = Plus(e5, e5);
       val e7 = Plus(e6, e6);
       val e8 = 
           Plus(e3, Plus(e3, Plus(e3, Plus(e3, Plus(e3, Plus(e3, e7))))));
\end{longprogram}
\index{PP@\verb,PP, (structure)|)}\newpage

\section*{Module Parsing}
\index{Parsing@\verb,Parsing, (structure)|(}
\markboth{\MakeUppercase{Parsing}}{\MakeUppercase{Parsing}}
\addcontentsline{toc}{section}{Parsing}
\begin{longprogram}
{\itshape{}Parsing \verb"-"\verb"-" runtime library for parsers generated by mosmlyac            }
{\itshape{}Based on the runtime library for camlyacc; copyright 1993 INRIA, France }

local open Vector Obj Lexing in

val symbolStart : unit \verb"-"\verb">" int\index{symbolStart@\verb,symbolStart,!value (\verb,Parsing,)}
val symbolEnd   : unit \verb"-"\verb">" int\index{symbolEnd@\verb,symbolEnd,!value (\verb,Parsing,)}
val itemStart   : int \verb"-"\verb">" int\index{itemStart@\verb,itemStart,!value (\verb,Parsing,)}
val itemEnd     : int \verb"-"\verb">" int\index{itemEnd@\verb,itemEnd,!value (\verb,Parsing,)}
val clearParser : unit \verb"-"\verb">" unit\index{clearParser@\verb,clearParser,!value (\verb,Parsing,)}

{\itshape{}For internal use in generated parsers: }

type parseTables =\index{parseTables@\verb,parseTables,!type (\verb,Parsing,)}
    {\itshape{}actions }    (unit \verb"-"\verb">" obj) vector  *
    {\itshape{}transl }     int vector *
    {\itshape{}lhs }        string *
    {\itshape{}len }        string *
    {\itshape{}defred }     string *
    {\itshape{}dgoto }      string *
    {\itshape{}sindex }     string *
    {\itshape{}rindex }     string *
    {\itshape{}gindex }     string *
    {\itshape{}tablesize }  int *
    {\itshape{}table }      string *
    {\itshape{}check }      string

exception yyexit of obj\index{yyexit@\verb,yyexit,!exception (\verb,Parsing,)}
exception ParseError of (obj \verb"-"\verb">" bool)\index{ParseError@\verb,ParseError,!exception (\verb,Parsing,)}

val yyparse : parseTables \verb"-"\verb">" int \verb"-"\verb">" (lexbuf \verb"-"\verb">" 'a) \verb"-"\verb">" lexbuf \verb"-"\verb">" 'b\index{yyparse@\verb,yyparse,!value (\verb,Parsing,)}
val peekVal : int \verb"-"\verb">" 'a\index{peekVal@\verb,peekVal,!value (\verb,Parsing,)}

end

\separatingline
   These functions are for use in mosmlyac\verb"-"generated parsers.  For
   further information, see the Moscow ML Owner's Manual.  For
   examples, see mosml/examples/lexyacc and mosml/examples/calc.

   A grammar definition (input to mosmlyac) consists of fragments of
   this form

       nonterm :
          grsyms1   \verb"{" action1 \verb"}"
        | grsyms2   \verb"{" action2 \verb"}"
        | grsyms3   \verb"{" action3 \verb"}"
        | ...

   where the grsyms are sequences of grammar symbols, matching some
   string of characters, and the actions are corresponding semantic
   actions, written in ML.  The following functions can be used in the
   semantic actions:

   [symbolStart ()] returns the start position of the string that\index{symbolStart@\verb,symbolStart,!value (\verb,Parsing,)}
   matches the sequence of grammar symbols.  The first character in
   the input stream has position 0.  May be called in a semantic
   action only.

   [symbolEnd ()] returns the end position, plus one, of the string\index{symbolEnd@\verb,symbolEnd,!value (\verb,Parsing,)}
   that matches the sequence of grammar symbols.  The first character
   in the input stream has position 0.  May be called in a semantic
   action only.

   [itemStart i] returns the start position of the string that matches\index{itemStart@\verb,itemStart,!value (\verb,Parsing,)}
   the i'th grammar symbol in the sequence.  The first grammar symbol
   has number 1.  The first character in the input stream has position
   0.  May be called in a semantic action only.

   [itemEnd i] returns the end position, plus one, of the string that\index{itemEnd@\verb,itemEnd,!value (\verb,Parsing,)}
   matches the i'th grammar symbol in the sequence.  The first grammar
   symbols has number 1.  The first character in the input stream has
   position 0.  May be called in a semantic action only.

   [clearParser ()] clears the parser stack.  It may be called after a\index{clearParser@\verb,clearParser,!value (\verb,Parsing,)}
   parsing function has returned, to remove all pointers from the
   parser stack to structures that were built by semantic actions
   during parsing.  This is not strict necessary, but reduces the
   memory requirements of the program.
\end{longprogram}
\index{Parsing@\verb,Parsing, (structure)|)}\newpage

\section*{Module Path}
\index{Path@\verb,Path, (structure)|(}
\markboth{\MakeUppercase{Path}}{\MakeUppercase{Path}}
\addcontentsline{toc}{section}{Path}
\begin{longprogram}
{\itshape{}OS.Path \verb"-"\verb"-" SML Basis Library }

exception Path\index{Path@\verb,Path,!exception (\verb,Path,)}

val parentArc    : string\index{parentArc@\verb,parentArc,!value (\verb,Path,)}
val currentArc   : string\index{currentArc@\verb,currentArc,!value (\verb,Path,)}

val fromString   : string \verb"-"\verb">" \verb"{"isAbs : bool, vol : string, arcs : string list\verb"}"\index{fromString@\verb,fromString,!value (\verb,Path,)}
val toString     : \verb"{"isAbs : bool, vol : string, arcs : string list\verb"}" \verb"-"\verb">" string\index{toString@\verb,toString,!value (\verb,Path,)}

val getVolume    : string \verb"-"\verb">" string \index{getVolume@\verb,getVolume,!value (\verb,Path,)}
val validVolume  : \verb"{"isAbs : bool, vol : string\verb"}" \verb"-"\verb">" bool\index{validVolume@\verb,validVolume,!value (\verb,Path,)}
val getParent    : string \verb"-"\verb">" string\index{getParent@\verb,getParent,!value (\verb,Path,)}

val isAbsolute   : string \verb"-"\verb">" bool\index{isAbsolute@\verb,isAbsolute,!value (\verb,Path,)}
val isRelative   : string \verb"-"\verb">" bool\index{isRelative@\verb,isRelative,!value (\verb,Path,)}
val mkAbsolute   : string * string \verb"-"\verb">" string\index{mkAbsolute@\verb,mkAbsolute,!value (\verb,Path,)}
val mkRelative   : string * string \verb"-"\verb">" string\index{mkRelative@\verb,mkRelative,!value (\verb,Path,)}

val concat       : string * string \verb"-"\verb">" string\index{concat@\verb,concat,!value (\verb,Path,)}

val mkCanonical  : string \verb"-"\verb">" string\index{mkCanonical@\verb,mkCanonical,!value (\verb,Path,)}
val isCanonical  : string \verb"-"\verb">" bool\index{isCanonical@\verb,isCanonical,!value (\verb,Path,)}

val splitDirFile : string \verb"-"\verb">" \verb"{"dir : string, file : string\verb"}"\index{splitDirFile@\verb,splitDirFile,!value (\verb,Path,)}
val joinDirFile  : \verb"{"dir : string, file : string\verb"}" \verb"-"\verb">" string\index{joinDirFile@\verb,joinDirFile,!value (\verb,Path,)}
val dir          : string \verb"-"\verb">" string\index{dir@\verb,dir,!value (\verb,Path,)}
val file         : string \verb"-"\verb">" string\index{file@\verb,file,!value (\verb,Path,)}

val splitBaseExt : string \verb"-"\verb">" \verb"{"base : string, ext : string option\verb"}"\index{splitBaseExt@\verb,splitBaseExt,!value (\verb,Path,)}
val joinBaseExt  : \verb"{"base : string, ext: string option\verb"}" \verb"-"\verb">" string\index{joinBaseExt@\verb,joinBaseExt,!value (\verb,Path,)}
val base         : string \verb"-"\verb">" string    \index{base@\verb,base,!value (\verb,Path,)}
val ext          : string \verb"-"\verb">" string option\index{ext@\verb,ext,!value (\verb,Path,)}

\separatingline
   This module provides OS\verb"-"independent functions for manipulating
   strings that represent file names and paths in a directory
   structure.  None of these functions accesses the actual filesystem.
   
   Definitions: 

   * An arc denotes a directory or file.  Under Unix or DOS, an arc may
   have form "..", ".", "", or "abc", or similar.

   * An absolute path has a root: Unix examples include "/", "/a/b";
   DOS examples include "\verb"\"", "\verb"\"a\verb"\"b", "A:\verb"\"a\verb"\"b".  

   * A relative path is one without a root: Unix examples include
   "..", "a/b"; DOS examples include "..", "a\verb"\"b", "A:a\verb"\"b".

   * A path has an associated volume.  Under Unix, there is only one
   volume, whose name is "".  Under DOS, the volume names are "",
   "A:", "C:", and similar.

   * A canonical path contains no occurrences of the empty arc "" or
   the current arc ".", and contains or the parent arc ".." only at
   the beginning and only if the path is relative.  

   * All functions (except concat) preserve canonical paths.  That is,
   if all arguments are canonical, then so will the result be.

   * All functions are defined so that they work sensibly on canonical 
   paths.

   * There are three groups of functions, corresponding to three ways
   to look at paths, exemplified by the following paths:

        Unix:    d/e/f/a.b.c       and     /d/e/f/a.b.c 
        DOS:     A:d\verb"\"e\verb"\"f\verb"\"a.b.c     and     A:d\verb"\"e\verb"\"f\verb"\"a.b.c     

   (1) A path consists of a sequence of arcs, possibly preceded by a
       volume and a root:

                          vol  [\verb"-"\verb"-"\verb"-" arcs \verb"-"\verb"-"\verb"-"]        vol  root  [\verb"-"\verb"-"\verb"-" arcs \verb"-"\verb"-"\verb"-"]
        \verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-" 
        Unix examples:         d  e  f  a.b.c               /   d  e  f  a.b.c
        DOS examples:     A:   d  e  f  a.b          A:     \verb"\"   d  e  f  a.b

   (2) A path consists of a directory part and a (last) file name part:

                          directory   file            directory  file 
        \verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"
        Unix examples:    d/e/f       a.b.c           /d/e/f     a.b.c
        DOS examples:     A:d\verb"\"e\verb"\"f     a.b             A:\verb"\"d\verb"\"e\verb"\"f   a.b

   (3) A path consists of a base and an extension:

                          base       extension       base        extension
        \verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"
        Unix examples:    d/e/f/a.b      c           /d/e/f/a.b      c
        DOS examples:     A:d\verb"\"e\verb"\"f\verb"\"a      b           A:\verb"\"d\verb"\"e\verb"\"f\verb"\"a      b


   GROUP 0: General functions on paths:

   [parentArc] is the arc denoting a parent directory: ".." under \index{parentArc@\verb,parentArc,!value (\verb,Path,)}
   DOS and Unix.

   [currentArc] is the arc denoting the current directory: "." under \index{currentArc@\verb,currentArc,!value (\verb,Path,)}
   DOS and Unix.

   [isRelative p] returns true if p is a relative path.\index{isRelative@\verb,isRelative,!value (\verb,Path,)}

   [isAbsolute p] returns true if p is an absolute path.  \index{isAbsolute@\verb,isAbsolute,!value (\verb,Path,)}
   Equals not (isRelative p).

   [validVolume \verb"{"isAbs, vol\verb"}"] returns true if vol is a valid volume\index{validVolume@\verb,validVolume,!value (\verb,Path,)}
   name for an absolute path (if isAbs=true) resp. for a relative path
   (if isAbs=false).  Under Unix, the only valid volume name is "";
   under MS DOS and MS Windows the valid volume names are "", "a:",
   "b:", ..., and "A:", "B:", ...

   [getParent p] returns a string denoting the parent directory of p.\index{getParent@\verb,getParent,!value (\verb,Path,)}
   It holds that getParent p = p if and only if p is a root. 

   [concat (p1, p2)] returns the path consisting of p1 followed by p2.\index{concat@\verb,concat,!value (\verb,Path,)}
   Does not preserve canonical paths: concat("a/b", "../c") equals
   "a/b/../c".  This is because "a/b/../c" and "a/c" may not be
   equivalent in the presence of symbolic links.  Raises Path if p2 is
   not a relative path.

   [mkAbsolute(p1, p2)] returns the absolute path made by taking path\index{mkAbsolute@\verb,mkAbsolute,!value (\verb,Path,)}
   p2, then p1.  That is, returns p1 if p1 is absolute; otherwise
   returns the canonicalized concatenation of p2 and p1.  Raises Path
   if p2 is not absolute (even if p1 is absolute).

   [mkRelative(p1, p2)] returns p1 relative to p2.  That is, returns\index{mkRelative@\verb,mkRelative,!value (\verb,Path,)}
   p1 if p1 is already relative; otherwise returns the relative path
   leading from p2 to p1.  Raises Path if p2 is not absolute (and even
   if p1 is relative), or if p1 and p2 are both absolute but have
   different roots.

   [mkCanonical p] returns a canonical path which is equivalent to p.\index{mkCanonical@\verb,mkCanonical,!value (\verb,Path,)}
   Redundant occurrences of the parent arc, the current arc, and the
   empty arc are removed.  The canonical path will never be the empty
   string; the empty path is converted to the current directory path
   ("." under Unix and DOS).  

   [isCanonical p] is equal to (p = mkCanonical p).\index{isCanonical@\verb,isCanonical,!value (\verb,Path,)}


   GROUP 1: Manipulating volumes and arcs:

   [fromString p] returns \verb"{"isAbs=false, vol, arcs\verb"}" if the path p is\index{fromString@\verb,fromString,!value (\verb,Path,)}
   relative, and \verb"{"isAbs=true, vol, arcs\verb"}" if the path p is absolute.
   In both cases vol is the volume name and arcs is the list of
   (possibly empty) arcs of the path.  Under Unix, the volume name is
   always the empty string ""; under DOS it will have form "A:", "C:",
   or similar.

   [toString path] reconstitutes a path from its root (if any) and\index{toString@\verb,toString,!value (\verb,Path,)}
   arcs.  Raises Path if applied to a relative path whose first arc is
   empty.  It holds that toString(fromString p) = p, except that in MS
   DOS, slashes "/" in p will be replaced by backslashes "\verb"\"".  It
   holds that fromString (toString p) = p when no exception is raised.
   It holds that isRelative(toString \verb"{"isAbs=false, vol, arcs\verb"}") = true
   when no exception is raised.

   [getVolume p] returns the volume name of the path p, if given.\index{getVolume@\verb,getVolume,!value (\verb,Path,)}
   Under Unix and MacOS, this is always the empty string "", and under
   MS DOS and MS Windows, it may have form "A:", "B:", ...


   GROUP 2: Manipulating directory paths and file names:

   [splitDirFile p] returns \verb"{"dir, file\verb"}" where file is the last arc in\index{splitDirFile@\verb,splitDirFile,!value (\verb,Path,)}
   p, and dir is the path preceding that arc.  A typical use is to
   split a path into the directory part (dir) and the filename (file).

   [joinDirFile \verb"{"dir, file\verb"}"] returns the path p obtained by extending\index{joinDirFile@\verb,joinDirFile,!value (\verb,Path,)}
   the path dir with the arc file.

   [dir p] equals #dir (splitDirFile p).\index{dir@\verb,dir,!value (\verb,Path,)}

   [file p] equals #file (splitDirFile p).\index{file@\verb,file,!value (\verb,Path,)}


   GROUP 3: Manipulating file names and extensions:

   [splitBaseExt s] returns \verb"{"base, ext\verb"}" where ext = NONE if s has no\index{splitBaseExt@\verb,splitBaseExt,!value (\verb,Path,)}
   extension, and ext = SOME e if s has extension e; base is the part
   of s preceding the extension.  A path s is considered having no
   extension if its last arc contains no extension separator
   (typically ".") or contains an extension separator only as its
   leftmost character, or contains an extension separator as its
   right\verb"-"most character.  Hence none of "a.b/cd", "a/.login", "a.",
   "..", "." and "." has an extension.

   [joinBaseExt \verb"{"base, ext\verb"}"] returns an arc composed of the base name\index{joinBaseExt@\verb,joinBaseExt,!value (\verb,Path,)}
   and the extension (if different from NONE).  It is a left inverse
   of splitBaseExt, so joinBaseExt (splitBaseExt s) = s, but the
   opposite does not hold (since the extension may be empty, or may
   contain extension separators).

   [ext s] equals #ext (splitBaseExt s).\index{ext@\verb,ext,!value (\verb,Path,)}

   [base s] equals #base (splitBaseExt s).\index{base@\verb,base,!value (\verb,Path,)}
\end{longprogram}
\index{Path@\verb,Path, (structure)|)}\newpage

\section*{Module Polygdbm}
\index{Polygdbm@\verb,Polygdbm, (structure)|(}
\markboth{\MakeUppercase{Polygdbm}}{\MakeUppercase{Polygdbm}}
\addcontentsline{toc}{section}{Polygdbm}
\begin{longprogram}
{\itshape{}Polygdbm \verb"-"\verb"-" GNU gdbm persistent polymorphic hashtables \verb"-"\verb"-" requires Dynlib }

type ('key, 'data) table \index{table@\verb,table,!type (\verb,Polygdbm,)}

exception NotFound\index{NotFound@\verb,NotFound,!exception (\verb,Polygdbm,)}
exception AlreadyThere\index{AlreadyThere@\verb,AlreadyThere,!exception (\verb,Polygdbm,)}
exception NotWriter\index{NotWriter@\verb,NotWriter,!exception (\verb,Polygdbm,)}
exception Closed\index{Closed@\verb,Closed,!exception (\verb,Polygdbm,)}
exception GdbmError of string\index{GdbmError@\verb,GdbmError,!exception (\verb,Polygdbm,)}

val withtable  : string * Gdbm.openmode \verb"-"\verb">" (('key, 'data) table \verb"-"\verb">" 'a) \verb"-"\verb">" 'a\index{withtable@\verb,withtable,!value (\verb,Polygdbm,)}
val add        : ('key, 'data) table \verb"-"\verb">" 'key * 'data \verb"-"\verb">" unit \index{add@\verb,add,!value (\verb,Polygdbm,)}
val insert     : ('key, 'data) table \verb"-"\verb">" 'key * 'data \verb"-"\verb">" unit\index{insert@\verb,insert,!value (\verb,Polygdbm,)}
val find       : ('key, 'data) table \verb"-"\verb">" 'key \verb"-"\verb">" 'data\index{find@\verb,find,!value (\verb,Polygdbm,)}
val peek       : ('key, 'data) table \verb"-"\verb">" 'key \verb"-"\verb">" 'data option\index{peek@\verb,peek,!value (\verb,Polygdbm,)}
val hasKey     : ('key, 'data) table \verb"-"\verb">" 'key \verb"-"\verb">" bool\index{hasKey@\verb,hasKey,!value (\verb,Polygdbm,)}
val remove     : ('key, 'data) table \verb"-"\verb">" 'key \verb"-"\verb">" unit\index{remove@\verb,remove,!value (\verb,Polygdbm,)}
val listKeys   : ('key, 'data) table \verb"-"\verb">" 'key list\index{listKeys@\verb,listKeys,!value (\verb,Polygdbm,)}
val numItems   : ('key, 'data) table \verb"-"\verb">" int\index{numItems@\verb,numItems,!value (\verb,Polygdbm,)}
val listItems  : ('key, 'data) table \verb"-"\verb">" ('key * 'data) list\index{listItems@\verb,listItems,!value (\verb,Polygdbm,)}
val app        : ('key * 'data \verb"-"\verb">" unit) \verb"-"\verb">" ('key, 'data) table \verb"-"\verb">" unit\index{app@\verb,app,!value (\verb,Polygdbm,)}
val map        : ('key * 'data \verb"-"\verb">" 'a) \verb"-"\verb">" ('key, 'data) table \verb"-"\verb">" 'a list\index{map@\verb,map,!value (\verb,Polygdbm,)}
val fold       : ('key * 'data * 'a \verb"-"\verb">" 'a) \verb"-"\verb">" 'a \verb"-"\verb">" ('key, 'data) table \verb"-"\verb">" 'a\index{fold@\verb,fold,!value (\verb,Polygdbm,)}
val fastwrite  : bool ref    \index{fastwrite@\verb,fastwrite,!value (\verb,Polygdbm,)}
val reorganize : ('key, 'data) table \verb"-"\verb">" unit\index{reorganize@\verb,reorganize,!value (\verb,Polygdbm,)}

\separatingline
   [('key, 'data) table] is the type of an opened table with keys of\index{table@\verb,table,!type (\verb,Polygdbm,)}
   type 'key and associated values of type 'data.  The actual values
   of type 'key and 'data cannot contain function closures or abstract
   values.  Values involving references (even circular values) can be
   stored, but the identity of references is preserved only with every
   single key or value stored, not across several different values.

   The Polygdbm table files of are not portable across platforms,
   because word size and endianness affects the lay\verb"-"out of values.

   A value of type table can be used only in the argument f to the
   withtable function.  This makes sure that the table is closed after
   use.

   [withtable (nam, mod) f] first opens the table db in file nam with\index{withtable@\verb,withtable,!value (\verb,Polygdbm,)}
   mode mod, then applies f to db, then closes db.  Makes sure to
   close db even if an exception is raised during the evaluation of
   f(db).  Raises GdbmError with an informative message in case the
   table cannot be opened.  E.g. the table cannot be opened for
   reading if already opened for writing, and cannot be opened for
   writing if already opened for reading.

   [add db (k,v)] adds the pair (k, v) to db.  Raises AlreadyThere if\index{add@\verb,add,!value (\verb,Polygdbm,)}
   there is a pair (k, _) in db already.  Raises NotWriter if db is
   not opened in write mode.

   [insert db (k, v)] adds the pair (k, v) to db, replacing any pair\index{insert@\verb,insert,!value (\verb,Polygdbm,)}
   (k, _) at k if present.  Raises NotWriter if db is not opened in
   write mode.

   [find(db, k)] returns v if the pair (k, v) is in db; otherwise\index{find@\verb,find,!value (\verb,Polygdbm,)}
   raises NotFound.

   [peek db k] returns SOME v if the pair (k, v) is in db; otherwise\index{peek@\verb,peek,!value (\verb,Polygdbm,)}
   returns NONE.

   [hasKey(db, k)] returns true if there is a pair (k, _) in db;\index{hasKey@\verb,hasKey,!value (\verb,Polygdbm,)}
   otherwise returns false.

   [remove db k] deletes the pair (k, _) from the table if present;\index{remove@\verb,remove,!value (\verb,Polygdbm,)}
   otherwise raises NotFound.  Raises NotWriter if db is not opened in
   write mode.

   [listKeys db] returns a list of all keys in db in an unspecified\index{listKeys@\verb,listKeys,!value (\verb,Polygdbm,)}
   order.  

   [numItems db] is the number of (key, value) pairs in db.\index{numItems@\verb,numItems,!value (\verb,Polygdbm,)}
   Equivalent to length(listKeys db).

   [listItems db] returns a list of all (key, value) pairs in db in some \index{listItems@\verb,listItems,!value (\verb,Polygdbm,)}
   order.  Equivalent to 
        List.map (fn key =\verb">" (key, find(db,key))) (listKeys db)

   [app f db] is equivalent to List.app f (listItems db), provided the\index{app@\verb,app,!value (\verb,Polygdbm,)}
   function f does not change the set of keys in the table.
   Otherwise the effect is unpredictable.

   [map f db] is equivalent to List.map f (listItems db), provided the\index{map@\verb,map,!value (\verb,Polygdbm,)}
   function f does not change the set of keys in the table.
   Otherwise the result and effect are unpredictable.
   
   [fold f a db] is equivalent to \index{fold@\verb,fold,!value (\verb,Polygdbm,)}
        List.foldr (fn ((k, v), r) =\verb">" f(k, v, r)) a (listItems db)
   provided the function f does not change the set of keys in the 
   table. Otherwise the result and effect are unpredictable.

   [fastwrite] can be set to speed up writes to a table.  By default,\index{fastwrite@\verb,fastwrite,!value (\verb,Polygdbm,)}
   !fastwrite is false and every write to a table will be followed by
   file system synchronization.  This is safe, but slow if you perform
   thousands of writes.  However, if !fastwrite is true when calling
   withtable, then writes may not be followed by synchronization,
   which may speed up writes considerably.  In any case, the file
   system is synchronized before withtable returns.

   [reorganize db] has no visible effect, but may be called after a\index{reorganize@\verb,reorganize,!value (\verb,Polygdbm,)}
   lot of deletions to shrink the size of the table file.
\end{longprogram}
\index{Polygdbm@\verb,Polygdbm, (structure)|)}\newpage

\section*{Module Polyhash}
\index{Polyhash@\verb,Polyhash, (structure)|(}
\markboth{\MakeUppercase{Polyhash}}{\MakeUppercase{Polyhash}}
\addcontentsline{toc}{section}{Polyhash}
\begin{longprogram}
{\itshape{}Polyhash \verb"-"\verb"-" polymorphic hashtables as in the SML/NJ Library }

type ('key, 'data) hash_table\index{hash_table@\verb,hash_table,!type (\verb,Polyhash,)}

val mkTable     : ('_key \verb"-"\verb">" int) * ('_key * '_key \verb"-"\verb">" bool) \verb"-"\verb">" int * exn \index{mkTable@\verb,mkTable,!value (\verb,Polyhash,)}
                  \verb"-"\verb">" ('_key, '_data) hash_table
val numItems    : ('key, 'data) hash_table \verb"-"\verb">" int\index{numItems@\verb,numItems,!value (\verb,Polyhash,)}
val insert      : ('_key, '_data) hash_table \verb"-"\verb">" '_key * '_data \verb"-"\verb">" unit\index{insert@\verb,insert,!value (\verb,Polyhash,)}
val peekInsert  : ('_key, '_data) hash_table \verb"-"\verb">" '_key * '_data \index{peekInsert@\verb,peekInsert,!value (\verb,Polyhash,)}
                  \verb"-"\verb">" '_data option
val find        : ('key, 'data) hash_table \verb"-"\verb">" 'key \verb"-"\verb">" 'data\index{find@\verb,find,!value (\verb,Polyhash,)}
val peek        : ('key, 'data) hash_table \verb"-"\verb">" 'key \verb"-"\verb">" 'data option\index{peek@\verb,peek,!value (\verb,Polyhash,)}
val remove      : ('key, 'data) hash_table \verb"-"\verb">" 'key \verb"-"\verb">" 'data\index{remove@\verb,remove,!value (\verb,Polyhash,)}
val listItems   : ('key, 'data) hash_table \verb"-"\verb">" ('key * 'data) list\index{listItems@\verb,listItems,!value (\verb,Polyhash,)}
val apply       : ('key * 'data \verb"-"\verb">" unit) \verb"-"\verb">" ('key, 'data) hash_table \verb"-"\verb">" unit\index{apply@\verb,apply,!value (\verb,Polyhash,)}
val map         : ('_key * 'data \verb"-"\verb">" '_res) \verb"-"\verb">" ('_key, 'data) hash_table \index{map@\verb,map,!value (\verb,Polyhash,)}
                  \verb"-"\verb">" ('_key, '_res) hash_table
val filter      : ('key * 'data \verb"-"\verb">" bool) \verb"-"\verb">" ('key, 'data) hash_table \verb"-"\verb">" unit\index{filter@\verb,filter,!value (\verb,Polyhash,)}
val transform   : ('data \verb"-"\verb">" '_res) \verb"-"\verb">" ('_key, 'data) hash_table \index{transform@\verb,transform,!value (\verb,Polyhash,)}
                  \verb"-"\verb">" ('_key, '_res) hash_table
val copy        : ('_key, '_data) hash_table \verb"-"\verb">" ('_key, '_data) hash_table\index{copy@\verb,copy,!value (\verb,Polyhash,)}
val bucketSizes : ('key, 'data) hash_table \verb"-"\verb">" int list\index{bucketSizes@\verb,bucketSizes,!value (\verb,Polyhash,)}

{\itshape{}Polymorphic hash primitives from Caml Light }

val hash        : 'key \verb"-"\verb">" int\index{hash@\verb,hash,!value (\verb,Polyhash,)}
val hash_param  : int \verb"-"\verb">" int \verb"-"\verb">" 'key \verb"-"\verb">" int\index{hash_param@\verb,hash_param,!value (\verb,Polyhash,)}
val mkPolyTable : int * exn \verb"-"\verb">" (''_key, '_data) hash_table\index{mkPolyTable@\verb,mkPolyTable,!value (\verb,Polyhash,)}

\separatingline
   [('key, 'data) hash_table] is the type of hashtables with keys of type\index{hash_table@\verb,hash_table,!type (\verb,Polyhash,)}
   'key and data values of type 'data.

   [mkTable (hashVal, sameKey) (sz, exc)] returns a new hashtable,\index{mkTable@\verb,mkTable,!value (\verb,Polyhash,)}
   using hash function hashVal and equality predicate sameKey.  The sz
   is a size hint, and exc is the exception raised by function find.
   It must be the case that sameKey(k1, k2) implies hashVal(k1) =
   hashVal(k2) for all k1,k2.

   [numItems htbl] is the number of items in the hash table.\index{numItems@\verb,numItems,!value (\verb,Polyhash,)}

   [insert htbl (k, d)] inserts data d for key k.  If k already had an\index{insert@\verb,insert,!value (\verb,Polyhash,)}
   item associated with it, then the old item is overwritten.

   [find htbl k] returns d, where d is the data item associated with key k, \index{find@\verb,find,!value (\verb,Polyhash,)}
   or raises the exception (given at creation of htbl) if there is no such d.

   [peek htbl k] returns SOME d, where d is the data item associated with \index{peek@\verb,peek,!value (\verb,Polyhash,)}
   key k, or NONE if there is no such d.

   [peekInsert htbl (k, d)] inserts data d for key k, if k is not\index{peekInsert@\verb,peekInsert,!value (\verb,Polyhash,)}
   already in the table, returning NONE.  If k is already in the
   table, and the associated data value is d', then returns SOME d'
   and leaves the table unmodified.

   [remove htbl k] returns d, where d is the data item associated with key k, \index{remove@\verb,remove,!value (\verb,Polyhash,)}
   removing d from the table; or raises the exception if there is no such d.

   [listItems htbl] returns a list of the (key, data) pairs in the hashtable.\index{listItems@\verb,listItems,!value (\verb,Polyhash,)}

   [apply f htbl] applies function f to all (key, data) pairs in the \index{apply@\verb,apply,!value (\verb,Polyhash,)}
   hashtable, in some order.

   [map f htbl] returns a new hashtable, whose data items have been\index{map@\verb,map,!value (\verb,Polyhash,)}
   obtained by applying f to the (key, data) pairs in htbl.  The new
   tables have the same keys, hash function, equality predicate, and
   exception, as htbl.

   [filter p htbl] deletes from htbl all data items which do not\index{filter@\verb,filter,!value (\verb,Polyhash,)}
   satisfy predicate p.

   [transform f htbl] as map, but only the (old) data values are used\index{transform@\verb,transform,!value (\verb,Polyhash,)}
   when computing the new data values.

   [copy htbl] returns a complete copy of htbl.\index{copy@\verb,copy,!value (\verb,Polyhash,)}

   [bucketSizes htbl] returns a list of the sizes of the buckets.\index{bucketSizes@\verb,bucketSizes,!value (\verb,Polyhash,)}
   This is to allow users to gauge the quality of their hashing
   function.  

   [hash k] returns the hash value of k, as a positive integer. If\index{hash@\verb,hash,!value (\verb,Polyhash,)}
   k1=k2 then hash(k1) = hash(k2), so this function can be used when
   creating hashtables.  The application hash(k) always terminates,
   even on cyclic structures.  (From the Caml Light implementation).

   [hash_param n m k] computes a hash value for k with the same\index{hash_param@\verb,hash_param,!value (\verb,Polyhash,)}
   properties as for hash. The parameters n and m give more precise
   control over hashing.  Hashing performs a depth\verb"-"first,
   right\verb"-"to\verb"-"left traversal of the structure k, stopping after n
   meaningful nodes were encountered, or m nodes, meaningful or not,
   were encountered. Meaningful nodes are: integers, floating\verb"-"point
   numbers, strings, characters, booleans, references, and constant
   constructors. 

   [mkPolyTable (sz, exc)] creates a new hashtable using the\index{mkPolyTable@\verb,mkPolyTable,!value (\verb,Polyhash,)}
   polymorphic hash function (hash) and ML equality (op =); the integer 
   sz is a size hint and the exception exc is to be raised by find.  
\end{longprogram}
\index{Polyhash@\verb,Polyhash, (structure)|)}\newpage

\section*{Module Postgres}
\index{Postgres@\verb,Postgres, (structure)|(}
\markboth{\MakeUppercase{Postgres}}{\MakeUppercase{Postgres}}
\addcontentsline{toc}{section}{Postgres}
\begin{longprogram}
{\itshape{}Postgres \verb"-"\verb"-" interface to PostgreSQL database server \verb"-"\verb"-" requires Dynlib }

type dbconn                                   {\itshape{}Connection to server }\index{dbconn@\verb,dbconn,!type (\verb,Postgres,)}
type dbresult                                 {\itshape{}Result of a query    }\index{dbresult@\verb,dbresult,!type (\verb,Postgres,)}
type oid                                      {\itshape{}Internal object id   }\index{oid@\verb,oid,!type (\verb,Postgres,)}

exception Closed                              {\itshape{}Connection is closed }\index{Closed@\verb,Closed,!exception (\verb,Postgres,)}
exception Null                                {\itshape{}Field value is NULL  }\index{Null@\verb,Null,!exception (\verb,Postgres,)}

{\itshape{}Opening, closing, and maintaining database connections }

val openbase : \verb"{" dbhost    : string option,   {\itshape{}database server host }\index{openbase@\verb,openbase,!value (\verb,Postgres,)}
                 dbname    : string option,   {\itshape{}database name        }
                 dboptions : string option,   {\itshape{}options              }
                 dbport    : string option,   {\itshape{}database server port }
                 dbpwd     : string option,   {\itshape{}user passwd          }
                 dbtty     : string option,   {\itshape{}tty for error log    }
                 dbuser    : string option    {\itshape{}database user        }
               \verb"}" \verb"-"\verb">" dbconn

val closebase    : dbconn \verb"-"\verb">" unit\index{closebase@\verb,closebase,!value (\verb,Postgres,)}
val db           : dbconn \verb"-"\verb">" string\index{db@\verb,db,!value (\verb,Postgres,)}
val host         : dbconn \verb"-"\verb">" string option\index{host@\verb,host,!value (\verb,Postgres,)}
val options      : dbconn \verb"-"\verb">" string\index{options@\verb,options,!value (\verb,Postgres,)}
val port         : dbconn \verb"-"\verb">" string\index{port@\verb,port,!value (\verb,Postgres,)}
val tty          : dbconn \verb"-"\verb">" string\index{tty@\verb,tty,!value (\verb,Postgres,)}

val status       : dbconn \verb"-"\verb">" bool\index{status@\verb,status,!value (\verb,Postgres,)}
val reset        : dbconn \verb"-"\verb">" unit\index{reset@\verb,reset,!value (\verb,Postgres,)}
val errormessage : dbconn \verb"-"\verb">" string option\index{errormessage@\verb,errormessage,!value (\verb,Postgres,)}

{\itshape{}Query execution and result set information }

datatype dbresultstatus =\index{dbresultstatus@\verb,dbresultstatus,!type (\verb,Postgres,)}
    Bad_response            {\itshape{}An unexpected response was received    }
  | Command_ok              {\itshape{}The query was a command                }
  | Copy_in                 {\itshape{}The query was "copy \verb"<"table\verb">" from ..."  }
  | Copy_out                {\itshape{}The query was "copy \verb"<"table\verb">" to ..."    }
  | Empty_query
  | Fatal_error
  | Nonfatal_error
  | Tuples_ok               {\itshape{}The query successfully returned tuples }

val execute      : dbconn \verb"-"\verb">" string \verb"-"\verb">" dbresult\index{execute@\verb,execute,!value (\verb,Postgres,)}
val resultstatus : dbresult \verb"-"\verb">" dbresultstatus\index{resultstatus@\verb,resultstatus,!value (\verb,Postgres,)}
val ntuples      : dbresult \verb"-"\verb">" int\index{ntuples@\verb,ntuples,!value (\verb,Postgres,)}
val cmdtuples    : dbresult \verb"-"\verb">" int\index{cmdtuples@\verb,cmdtuples,!value (\verb,Postgres,)}
val nfields      : dbresult \verb"-"\verb">" int\index{nfields@\verb,nfields,!value (\verb,Postgres,)}
val fname        : dbresult \verb"-"\verb">" int \verb"-"\verb">" string\index{fname@\verb,fname,!value (\verb,Postgres,)}
val fnames       : dbresult \verb"-"\verb">" string vector\index{fnames@\verb,fnames,!value (\verb,Postgres,)}
val fnumber      : dbresult \verb"-"\verb">" string \verb"-"\verb">" int option\index{fnumber@\verb,fnumber,!value (\verb,Postgres,)}

{\itshape{}Accessing the fields of a resultset }

val getint       : dbresult \verb"-"\verb">" int \verb"-"\verb">" int \verb"-"\verb">" int\index{getint@\verb,getint,!value (\verb,Postgres,)}
val getreal      : dbresult \verb"-"\verb">" int \verb"-"\verb">" int \verb"-"\verb">" real\index{getreal@\verb,getreal,!value (\verb,Postgres,)}
val getstring    : dbresult \verb"-"\verb">" int \verb"-"\verb">" int \verb"-"\verb">" string\index{getstring@\verb,getstring,!value (\verb,Postgres,)}
val getdate      : dbresult \verb"-"\verb">" int \verb"-"\verb">" int \verb"-"\verb">" int * int * int {\itshape{}Y M D }\index{getdate@\verb,getdate,!value (\verb,Postgres,)}
val gettime      : dbresult \verb"-"\verb">" int \verb"-"\verb">" int \verb"-"\verb">" int * int * int {\itshape{}H M S }\index{gettime@\verb,gettime,!value (\verb,Postgres,)}
val getdatetime  : dbresult \verb"-"\verb">" int \verb"-"\verb">" int \verb"-"\verb">" Date.date\index{getdatetime@\verb,getdatetime,!value (\verb,Postgres,)}
val getbool      : dbresult \verb"-"\verb">" int \verb"-"\verb">" int \verb"-"\verb">" bool\index{getbool@\verb,getbool,!value (\verb,Postgres,)}
val isnull       : dbresult \verb"-"\verb">" int \verb"-"\verb">" int \verb"-"\verb">" bool\index{isnull@\verb,isnull,!value (\verb,Postgres,)}

datatype dynval =\index{dynval@\verb,dynval,!type (\verb,Postgres,)}
    Bool of bool                        {\itshape{}psql bool            }
  | Int of int                          {\itshape{}psql int4            }
  | Real of real                        {\itshape{}psql float8, float4  }
  | String of string                    {\itshape{}psql text, varchar   }
  | Date of int * int * int             {\itshape{}psql date yyyy\verb"-"mm\verb"-"dd }
  | Time of int * int * int             {\itshape{}psql time hh:mm:ss   }
  | DateTime of Date.date               {\itshape{}psql datetime        }
  | Oid of oid                          {\itshape{}psql oid             }
  | Bytea of Word8Array.array           {\itshape{}psql bytea           }
  | NullVal                             {\itshape{}psql NULL            }

val getdynfield : dbresult \verb"-"\verb">" int \verb"-"\verb">" int \verb"-"\verb">" dynval\index{getdynfield@\verb,getdynfield,!value (\verb,Postgres,)}
val getdyntup   : dbresult \verb"-"\verb">" int \verb"-"\verb">" dynval vector\index{getdyntup@\verb,getdyntup,!value (\verb,Postgres,)}
val getdyntups  : dbresult \verb"-"\verb">" dynval vector vector \index{getdyntups@\verb,getdyntups,!value (\verb,Postgres,)}
val dynval2s    : dynval \verb"-"\verb">" string\index{dynval2s@\verb,dynval2s,!value (\verb,Postgres,)}

{\itshape{}Bulk copying to or from a table }

val copytableto   : dbconn * string * (string \verb"-"\verb">" unit) \verb"-"\verb">" unit\index{copytableto@\verb,copytableto,!value (\verb,Postgres,)}
val copytablefrom : dbconn * string * ((string \verb"-"\verb">" unit) \verb"-"\verb">" unit) \verb"-"\verb">" unit\index{copytablefrom@\verb,copytablefrom,!value (\verb,Postgres,)}

{\itshape{}Some standard ML and Postgres types: }

datatype dyntype = \index{dyntype@\verb,dyntype,!type (\verb,Postgres,)}
    BoolTy              {\itshape{}ML bool              psql bool              }
  | IntTy               {\itshape{}ML int               psql int4              }
  | RealTy              {\itshape{}ML real              psql float8, float4    }
  | StringTy            {\itshape{}ML string            psql text, varchar     } 
  | DateTy              {\itshape{}ML (yyyy, mth, day)  psql date              }
  | TimeTy              {\itshape{}ML (hh, mm, ss)      psql time              }
  | DateTimeTy          {\itshape{}ML Date.date         psql datetime, abstime }
  | OidTy               {\itshape{}ML oid               psql oid               }
  | ByteArrTy           {\itshape{}ML Word8Array.array  psql bytea             }
  | UnknownTy of oid

val fromtag : dyntype \verb"-"\verb">" string\index{fromtag@\verb,fromtag,!value (\verb,Postgres,)}
val ftype   : dbresult \verb"-"\verb">" int \verb"-"\verb">" dyntype\index{ftype@\verb,ftype,!value (\verb,Postgres,)}
val ftypes  : dbresult \verb"-"\verb">" dyntype Vector.vector\index{ftypes@\verb,ftypes,!value (\verb,Postgres,)}

val applyto : 'a \verb"-"\verb">" ('a \verb"-"\verb">" 'b) \verb"-"\verb">" 'b\index{applyto@\verb,applyto,!value (\verb,Postgres,)}

{\itshape{}Formatting the result of a database query as an HTML table }

val formattable : dbresult \verb"-"\verb">" Msp.wseq\index{formattable@\verb,formattable,!value (\verb,Postgres,)}
val showquery   : dbconn \verb"-"\verb">" string \verb"-"\verb">" Msp.wseq\index{showquery@\verb,showquery,!value (\verb,Postgres,)}

\separatingline
   [dbconn] is the type of connections to a PostgreSQL database.\index{dbconn@\verb,dbconn,!type (\verb,Postgres,)}

   [dbresult] is the type of result sets from SQL queries.\index{dbresult@\verb,dbresult,!type (\verb,Postgres,)}

   [oid] is the type of PostgreSQL internal object identifiers.\index{oid@\verb,oid,!constructor (\verb,Postgres,)}\index{oid@\verb,oid,!type (\verb,Postgres,)}

   [openbase \verb"{" dbhost, dbport, dboptions, dbtty, dbname, dbuser, dbpwd  \verb"}"] \index{openbase@\verb,openbase,!value (\verb,Postgres,)}
   opens a connection to a PostgreSQL database server on the given
   host (default the local one) on the given port (default 5432), with
   the given options (default the empty string), with error logging on
   the given tty (default?), to the given database (defaults to the
   user's login name), for the given user name (defaults to the
   current user's login name), and the given password (default none).
   The result is a connection which may be used in subsequent queries.

   [closebase dbconn] closes the database connection.  No further\index{closebase@\verb,closebase,!value (\verb,Postgres,)}
   queries can be executed.

   [db dbconn] returns the name of the database.\index{db@\verb,db,!value (\verb,Postgres,)}

   [host dbconn] returns SOME h, where h is the database server host\index{host@\verb,host,!value (\verb,Postgres,)}
   name, if the connection uses the Internet; returns NONE if the
   connection is to a socket on the local server.

   [options dbconn] returns the options given when opening the database.\index{options@\verb,options,!value (\verb,Postgres,)}

   [port dbconn] returns the port number of the connection.\index{port@\verb,port,!value (\verb,Postgres,)}

   [tty dbconn] returns the name of the tty used for logging.\index{tty@\verb,tty,!value (\verb,Postgres,)}

   [status dbconn] returns true if the connection is usable, false\index{status@\verb,status,!value (\verb,Postgres,)}
   otherwise.

   [reset dbconn] attempts to close and then reopen the connection to\index{reset@\verb,reset,!value (\verb,Postgres,)}
   the database server.

   [errormessage dbconn] returns NONE if no error occurred, and SOME msg\index{errormessage@\verb,errormessage,!value (\verb,Postgres,)}
   if an error occurred, where msg describes the error.

   [execute dbconn query] sends an SQL query to the database server\index{execute@\verb,execute,!value (\verb,Postgres,)}
   for execution, and returns a resultset dbres.
   
   [resultstatus dbres] returns the status of the result set dbres.\index{resultstatus@\verb,resultstatus,!value (\verb,Postgres,)}
   After a select query that succeeded, it will be Tuples_ok.
   
   [ntuples dbres] returns the number of tuples in the result set\index{ntuples@\verb,ntuples,!value (\verb,Postgres,)}
   after a query.

   [cmdtuples dbres] returns the number of tuples affected by an\index{cmdtuples@\verb,cmdtuples,!value (\verb,Postgres,)}
   insert, update, or delete SQL command.

   [nfields dbres] returns the number of fields in each tuple after a\index{nfields@\verb,nfields,!value (\verb,Postgres,)}
   query.

   [fname dbres fno] returns the name of field number fno (in the\index{fname@\verb,fname,!value (\verb,Postgres,)}
   result set after a query).  The fields are numbered 0, 1,...

   [fnames dbres] returns a vector of the field names (in the result\index{fnames@\verb,fnames,!value (\verb,Postgres,)}
   set after a query).

   [fnumber dbres fname] returns SOME i where i is the number (0, 1,\index{fnumber@\verb,fnumber,!value (\verb,Postgres,)}
   ...) of the field called fname (in the result set after a query),
   if the result set contains such a field name; returns NONE otherwise.

   [ftype dbres fno] returns the dyntype of field number fno (in the
   result set after a query).

   [ftypes dbres] returns a vector of the dyntypes (in the result set
   after a query).

   [fromtag dt] returns the name of the preferred PostgreSQL type used
   to represent values of the dyntype dt.  This may be used when
   building `create table' statements.

   [getint dbres fno tupno] returns the integer value of field number\index{getint@\verb,getint,!value (\verb,Postgres,)}
   fno in tuple tupno of result set dbres.  Raises Null if the value
   is NULL.

   [getreal dbres fno tupno] returns the floating\verb"-"point value of field\index{getreal@\verb,getreal,!value (\verb,Postgres,)}
   number fno in tuple tupno of result set dbres.  Raises Null if the
   value is NULL.

   [getstring dbres fno tupno] returns the string value of field\index{getstring@\verb,getstring,!value (\verb,Postgres,)}
   number fno in tuple tupno of result set dbres.  Raises Null if the
   value is NULL.

   [getdate dbres fno tupno] returns the date (yyyy, mth, day) value\index{getdate@\verb,getdate,!value (\verb,Postgres,)}
   of field number fno in tuple tupno of result set dbres.  Raises
   Null if the value is NULL.  Raises Fail if the field cannot be
   scanned as a date.

   [gettime dbres fno tupno] returns the time\verb"-"of\verb"-"day (hh, mm, ss)\index{gettime@\verb,gettime,!value (\verb,Postgres,)}
   value of field number fno in tuple tupno of result set dbres.
   Raises Null if the value is NULL.  Raises Fail if the field cannot
   be scanned as a time.

   [getdatetime dbres fno tupno] returns the Date.date value of field\index{getdatetime@\verb,getdatetime,!value (\verb,Postgres,)}
   number fno in tuple tupno of result set dbres.  Raises Null if the
   value is NULL.  Raises Fail if the field cannot be scanned as a
   date.

   [getbool dbres fno tupno] returns the boolean value of field number\index{getbool@\verb,getbool,!value (\verb,Postgres,)}
   fno in tuple tupno of result set dbres.  Raises Null if the value
   is NULL.

   [isnull dbres fno tupno] returns true if the value of field number\index{isnull@\verb,isnull,!value (\verb,Postgres,)}
   fno in tuple tupno of result set dbres is NULL; false otherwise.

   [getdynfield dbres fno tupno] returns the value of field number fno\index{getdynfield@\verb,getdynfield,!value (\verb,Postgres,)}
   in tuple tupno of result set dbres as a dynval (a wrapped value).
   A NULL value is returned as NullVal.  Note that the partial
   application  (getdynfield dbres fno)  precomputes the type of the 
   field fno.  Hence it is far more efficient to compute 
        let val getfno = getdynfield dbres fno
        in tabulate(ntuples dbres, getfno) end
   than to compute
        let fun getfno tupno = getdynfield dbres fno tupno
        in tabulate(ntuples dbres, getfno) end
   because the latter repeatedly computes the type of the field.

   [getdyntup dbres tupno] returns the fields of tuple tupno in result\index{getdyntup@\verb,getdyntup,!value (\verb,Postgres,)}
   set dbres as a vector of dynvals.

   [getdyntups dbres] returns all tuples of result set dbres as a\index{getdyntups@\verb,getdyntups,!value (\verb,Postgres,)}
   vector of vectors of dynvals.

   [dynval2s dv] returns a string representing the dynval dv.\index{dynval2s@\verb,dynval2s,!value (\verb,Postgres,)}

   [applyto x f] computes f(x).  This is convenient for applying\index{applyto@\verb,applyto,!value (\verb,Postgres,)}
   several functions (given in a list or vector) to the same value:
      map (applyto 5) (tabulate(3, getdynfield dbres))
   equals 
      [getdynfield dbres 0 5, getdynfield dbres 1 5, getdynfield dbres 2 5]

   [copytableto(dbconn, tablename, put)] executes a "COPY TABLE TO"\index{copytableto@\verb,copytableto,!value (\verb,Postgres,)}
   statement, applies the function put to every tuple of the table,
   represented as a line of text (not terminated by newline \verb"\"n), and
   cleans up at the end.  For instance, to copy the contents of a
   table t to a text stream s (one tuple on each line), define
      fun put line = 
          (TextIO.output(s, line); TextIO.output(s, "\verb"\"n"))
   and execute
      copytableto(dbconn, "t", put).

   [copytablefrom(dbconn, tablename, useput)] executes a "COPY TABLE\index{copytablefrom@\verb,copytablefrom,!value (\verb,Postgres,)}
   FROM" statement, creates a put function for copying lines to the
   table, passes the put function to useput, and cleans up at the end.
   The put function may be called multiple times for each line
   (tuple); the end of each line is indicated with the newline
   character "\verb"\"n" as usual.  For instance, to copy the contents of a
   text stream s to a table t, define
      fun useput put = 
          while not (TextIO.endOfStream s) do put(TextIO.inputLine s);
   and execute
      copytablefrom(dbconn, "t", useput).
   Note that TextIO.inputLine preserves the newline at the end of each 
   line.  

   [formattable dbresult] returns a wseq representing an HTML table.\index{formattable@\verb,formattable,!value (\verb,Postgres,)}
   The HTML table has a column for every field in the dbresult.  The
   first row is a table header giving the names of the fields in the
   dbresult.  The remaining rows correspond to the tuples in the
   dbresult, in the order they are provided by the database server.
   Null fields are shown as NULL.

   [showquery dbconn query] sends the SQL query to the database\index{showquery@\verb,showquery,!value (\verb,Postgres,)}
   server, then uses formattable to format the result of the query.
\end{longprogram}
\index{Postgres@\verb,Postgres, (structure)|)}\newpage

\section*{Module Process}
\index{Process@\verb,Process, (structure)|(}
\markboth{\MakeUppercase{Process}}{\MakeUppercase{Process}}
\addcontentsline{toc}{section}{Process}
\begin{longprogram}
{\itshape{}OS.Process \verb"-"\verb"-" SML Basis Library }

eqtype status\index{status@\verb,status,!type (\verb,Process,)}

val success   : status\index{success@\verb,success,!value (\verb,Process,)}
val failure   : status\index{failure@\verb,failure,!value (\verb,Process,)}

val system    : string \verb"-"\verb">" status\index{system@\verb,system,!value (\verb,Process,)}

val atExit    : (unit \verb"-"\verb">" unit) \verb"-"\verb">" unit\index{atExit@\verb,atExit,!value (\verb,Process,)}
val exit      : status \verb"-"\verb">" 'a\index{exit@\verb,exit,!value (\verb,Process,)}
val terminate : status \verb"-"\verb">" 'a\index{terminate@\verb,terminate,!value (\verb,Process,)}

val getEnv    : string \verb"-"\verb">" string option\index{getEnv@\verb,getEnv,!value (\verb,Process,)}

\separatingline
   Portable functions for manipulating processes.

   [success] is the unique status value that signifies successful\index{success@\verb,success,!value (\verb,Process,)}
   termination of a process.  Note: MS DOS (sometimes) believes that
   all processes are successful.

   [failure] is a status value that signifies an error during\index{failure@\verb,failure,!value (\verb,Process,)}
   execution of a process.  Note that in contrast to the success
   value, there may be several distinct failure values.

   [system cmd] asks the operating system to execute command cmd, and\index{system@\verb,system,!value (\verb,Process,)}
   returns a status value.

   [atExit act] registers the action act to be executed when the\index{atExit@\verb,atExit,!value (\verb,Process,)}
   current SML program calls Process.exit.  Actions will be executed
   in reverse order of registration.

   [exit i] executes all registered actions, then terminates the SML\index{exit@\verb,exit,!value (\verb,Process,)}
   process with completion code i.

   [terminate i] terminates the SML process with completion code i \index{terminate@\verb,terminate,!value (\verb,Process,)}
   (but without executing the registered actions).

   [getEnv evar] returns SOME s if the environment variable evar is\index{getEnv@\verb,getEnv,!value (\verb,Process,)}
   defined and is associated with the string s; otherwise NONE.
\end{longprogram}
\index{Process@\verb,Process, (structure)|)}\newpage

\section*{Module Random}
\index{Random@\verb,Random, (structure)|(}
\markboth{\MakeUppercase{Random}}{\MakeUppercase{Random}}
\addcontentsline{toc}{section}{Random}
\begin{longprogram}
{\itshape{}Random \verb"-"\verb"-" random number generator }

type generator\index{generator@\verb,generator,!type (\verb,Random,)}

val newgenseed : real \verb"-"\verb">" generator\index{newgenseed@\verb,newgenseed,!value (\verb,Random,)}
val newgen     : unit \verb"-"\verb">" generator\index{newgen@\verb,newgen,!value (\verb,Random,)}
val random     : generator \verb"-"\verb">" real\index{random@\verb,random,!value (\verb,Random,)}
val randomlist : int * generator \verb"-"\verb">" real list\index{randomlist@\verb,randomlist,!value (\verb,Random,)}
val range      : int * int \verb"-"\verb">" generator \verb"-"\verb">" int\index{range@\verb,range,!value (\verb,Random,)}
val rangelist  : int * int \verb"-"\verb">" int * generator \verb"-"\verb">" int list\index{rangelist@\verb,rangelist,!value (\verb,Random,)}

\separatingline
   [generator] is the type of random number generators, here the\index{generator@\verb,generator,!type (\verb,Random,)}
   linear congruential generators from Paulson 1991, 1996.

   [newgenseed seed] returns a random number generator with the given seed.\index{newgenseed@\verb,newgenseed,!value (\verb,Random,)}

   [newgen ()] returns a random number generator, taking the seed from\index{newgen@\verb,newgen,!value (\verb,Random,)}
   the system clock.

   [random gen] returns a random number in the interval [0..1).\index{random@\verb,random,!value (\verb,Random,)}

   [randomlist (n, gen)] returns a list of n random numbers in the\index{randomlist@\verb,randomlist,!value (\verb,Random,)}
   interval [0,1).

   [range (min, max) gen] returns an integral random number in the\index{range@\verb,range,!value (\verb,Random,)}
   range [min, max).  Raises Fail if min \verb">" max.

   [rangelist (min, max) (n, gen)] returns a list of n integral random\index{rangelist@\verb,rangelist,!value (\verb,Random,)}
   numbers in the range [min, max).  Raises Fail if min \verb">" max.  
\end{longprogram}
\index{Random@\verb,Random, (structure)|)}\newpage

\section*{Module Real}
\index{Real@\verb,Real, (structure)|(}
\markboth{\MakeUppercase{Real}}{\MakeUppercase{Real}}
\addcontentsline{toc}{section}{Real}
\begin{longprogram}
{\itshape{}Real \verb"-"\verb"-" SML Basis Library }

type real = real\index{real@\verb,real,!type (\verb,Real,)}

exception Div\index{Div@\verb,Div,!exception (\verb,Real,)}
and Overflow

val ~           : real \verb"-"\verb">" real\index{~@\verb,~,!value (\verb,Real,)}
val +           : real * real \verb"-"\verb">" real\index{+@\verb,+,!value (\verb,Real,)}
val \verb"-"           : real * real \verb"-"\verb">" real\index{-@\verb,-,!value (\verb,Real,)}
val *           : real * real \verb"-"\verb">" real\index{*@\verb,*,!value (\verb,Real,)}
val /           : real * real \verb"-"\verb">" real\index{/@\verb,/,!value (\verb,Real,)}
val abs         : real \verb"-"\verb">" real\index{abs@\verb,abs,!value (\verb,Real,)}
val min         : real * real \verb"-"\verb">" real\index{min@\verb,min,!value (\verb,Real,)}
val max         : real * real \verb"-"\verb">" real\index{max@\verb,max,!value (\verb,Real,)}
val sign        : real \verb"-"\verb">" int\index{sign@\verb,sign,!value (\verb,Real,)}
val compare     : real * real \verb"-"\verb">" order\index{compare@\verb,compare,!value (\verb,Real,)}

val sameSign    : real * real \verb"-"\verb">" bool\index{sameSign@\verb,sameSign,!value (\verb,Real,)}
val toDefault   : real \verb"-"\verb">" real\index{toDefault@\verb,toDefault,!value (\verb,Real,)}
val fromDefault : real \verb"-"\verb">" real\index{fromDefault@\verb,fromDefault,!value (\verb,Real,)}
val fromInt     : int \verb"-"\verb">" real\index{fromInt@\verb,fromInt,!value (\verb,Real,)}

val floor       : real \verb"-"\verb">" int\index{floor@\verb,floor,!value (\verb,Real,)}
val ceil        : real \verb"-"\verb">" int\index{ceil@\verb,ceil,!value (\verb,Real,)}
val trunc       : real \verb"-"\verb">" int\index{trunc@\verb,trunc,!value (\verb,Real,)}
val round       : real \verb"-"\verb">" int\index{round@\verb,round,!value (\verb,Real,)}

val \verb">"           : real * real \verb"-"\verb">" bool\index{>@\verb,>,!value (\verb,Real,)}
val \verb">"=          : real * real \verb"-"\verb">" bool\index{>=@\verb,>=,!value (\verb,Real,)}
val \verb"<"           : real * real \verb"-"\verb">" bool\index{<@\verb,<,!value (\verb,Real,)}
val \verb"<"=          : real * real \verb"-"\verb">" bool\index{<=@\verb,<=,!value (\verb,Real,)}
val ==          : real * real \verb"-"\verb">" bool\index{==@\verb,==,!value (\verb,Real,)}
val !=          : real * real \verb"-"\verb">" bool\index{"!=@\verb,"!=,!value (\verb,Real,)}
val ?=          : real * real \verb"-"\verb">" bool\index{?=@\verb,?=,!value (\verb,Real,)}

val toString    : real \verb"-"\verb">" string\index{toString@\verb,toString,!value (\verb,Real,)}
val fromString  : string \verb"-"\verb">" real option\index{fromString@\verb,fromString,!value (\verb,Real,)}
val scan        : (char, 'a) StringCvt.reader \verb"-"\verb">" (real, 'a) StringCvt.reader\index{scan@\verb,scan,!value (\verb,Real,)}
val fmt         : StringCvt.realfmt \verb"-"\verb">" real \verb"-"\verb">" string\index{fmt@\verb,fmt,!value (\verb,Real,)}

\separatingline
   [~]\index{~@\verb,~,!value (\verb,Real,)}
   [*]\index{*@\verb,*,!value (\verb,Real,)}
   [/]\index{/@\verb,/,!value (\verb,Real,)}
   [+]\index{+@\verb,+,!value (\verb,Real,)}
   [\verb"-"]\index{-@\verb,-,!value (\verb,Real,)}
   [\verb">"]\index{>@\verb,>,!value (\verb,Real,)}
   [\verb">"=]\index{>=@\verb,>=,!value (\verb,Real,)}
   [\verb"<"]\index{<@\verb,<,!value (\verb,Real,)}
   [\verb"<"=] are the usual operations on defined reals (excluding NaN and Inf).\index{<=@\verb,<=,!value (\verb,Real,)}

   [abs x] is x if x \verb">"= 0, and ~x if x \verb"<" 0, that is, the absolute value of x.\index{abs@\verb,abs,!value (\verb,Real,)}

   [min(x, y)] is the smaller of x and y.\index{min@\verb,min,!value (\verb,Real,)}

   [max(x, y)] is the larger of x and y.\index{max@\verb,max,!value (\verb,Real,)}

   [sign x] is ~1, 0, or 1, according as x is negative, zero, or positive.\index{sign@\verb,sign,!value (\verb,Real,)}

   [compare(x, y)] returns LESS, EQUAL, or GREATER, according \index{compare@\verb,compare,!value (\verb,Real,)}
   as x is less than, equal to, or greater than y.

   [sameSign(x, y)] is true iff sign x = sign y.\index{sameSign@\verb,sameSign,!value (\verb,Real,)}

   [toDefault x] is x.\index{toDefault@\verb,toDefault,!value (\verb,Real,)}

   [fromDefault x] is x.\index{fromDefault@\verb,fromDefault,!value (\verb,Real,)}

   [fromInt i] is the floating\verb"-"point number representing integer i.\index{fromInt@\verb,fromInt,!value (\verb,Real,)}

   [floor r] is the largest integer \verb"<"= r (rounds towards minus infinity).\index{floor@\verb,floor,!value (\verb,Real,)}
   May raise Overflow.

   [ceil r] is the smallest integer \verb">"= r (rounds towards plus infinity).\index{ceil@\verb,ceil,!value (\verb,Real,)}
   May raise Overflow.

   [trunc r] is the numerically largest integer between r and zero\index{trunc@\verb,trunc,!value (\verb,Real,)}
   (rounds towards zero).  May raise Overflow.

   [round r] is the integer nearest to r, using the default rounding\index{round@\verb,round,!value (\verb,Real,)}
   mode.  May raise Overflow.

   [==(x, y)] is equivalent to x=y in Moscow ML (because of the\index{==@\verb,==,!value (\verb,Real,)}
   absence of NaNs and Infs).

   [!=(x, y)] is equivalent to x\verb"<"\verb">"y in Moscow ML (because of the\index{"!=@\verb,"!=,!value (\verb,Real,)}
   absence of NaNs and Infs).

   [?=(x, y)] is false in Moscow ML (because of the absence of NaNs\index{?=@\verb,?=,!value (\verb,Real,)}
   and Infs).

   [fmt spec r] returns a string representing r, in the format\index{fmt@\verb,fmt,!value (\verb,Real,)}
   specified by spec (see below).  The requested number of digits must
   be \verb">"= 0 in the SCI and FIX formats and \verb">" 0 in the GEN format;
   otherwise Size is raised, even in a partial application fmt(spec).

      spec          description                            C printf 
      \verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"
      SCI NONE      scientific,   6 digits after point       \verb"%"e
      SCI (SOME n)  scientific,   n digits after point       \verb"%".ne
      FIX NONE      fixed\verb"-"point,  6 digits after point       \verb"%"f
      FIX (SOME n)  fixed\verb"-"point,  n digits after point       \verb"%".nf
      GEN NONE      auto choice, 12 significant digits       \verb"%".12g
      GEN (SOME n)  auto choice,  n significant digits       \verb"%".ng

   [toString r] returns a string representing r, with automatic choice\index{toString@\verb,toString,!value (\verb,Real,)}
   of format according to the magnitude of r.  
   Equivalent to (fmt (GEN NONE) r).
   
   [fromString s] returns SOME(r) if a floating\verb"-"point numeral can be\index{fromString@\verb,fromString,!value (\verb,Real,)}
   scanned from a prefix of string s, ignoring any initial whitespace;
   returns NONE otherwise.  The valid forms of floating\verb"-"point numerals
   are described by:
        [+~\verb"-"]?(([0\verb"-"9]+(\verb"\".[0\verb"-"9]+)?)|(\verb"\".[0\verb"-"9]+))([eE][+~\verb"-"]?[0\verb"-"9]+)?

   [scan getc charsrc] attempts to scan a floating\verb"-"point number from\index{scan@\verb,scan,!value (\verb,Real,)}
   the character source charsrc, using the accessor getc, and ignoring
   any initial whitespace.  If successful, it returns SOME(r, rest)
   where r is the number scanned, and rest is the unused part of the
   character source.  The valid forms of floating\verb"-"point numerals
   are described by:
        [+~\verb"-"]?(([0\verb"-"9]+(\verb"\".[0\verb"-"9]+)?)|(\verb"\".[0\verb"-"9]+))([eE][+~\verb"-"]?[0\verb"-"9]+)?
\end{longprogram}
\index{Real@\verb,Real, (structure)|)}\newpage

\section*{Module Regex}
\index{Regex@\verb,Regex, (structure)|(}
\markboth{\MakeUppercase{Regex}}{\MakeUppercase{Regex}}
\addcontentsline{toc}{section}{Regex}
\begin{longprogram}
{\itshape{}Regex \verb"-"\verb"-" regular expressions a la POSIX 1003.2 \verb"-"\verb"-" requires Dynlib }

exception Regex of string\index{Regex@\verb,Regex,!exception (\verb,Regex,)}

type regex                      {\itshape{}A compiled regular expression         }\index{regex@\verb,regex,!type (\verb,Regex,)}

datatype cflag = \index{cflag@\verb,cflag,!type (\verb,Regex,)}
    Extended                    {\itshape{}Compile POSIX extended REs            }
  | Icase                       {\itshape{}Compile case\verb"-"insensitive match        }
  | Newline                     {\itshape{}Treat \verb"\"n in target string as new line }

datatype eflag = \index{eflag@\verb,eflag,!type (\verb,Regex,)}
    Notbol                      {\itshape{}Do not match ^ at beginning of string }
  | Noteol                      {\itshape{}Do not match \$ at end of string       }

val regcomp      : string \verb"-"\verb">" cflag list \verb"-"\verb">" regex\index{regcomp@\verb,regcomp,!value (\verb,Regex,)}

val regexec      : regex \verb"-"\verb">" eflag list \verb"-"\verb">" string \verb"-"\verb">" substring vector option\index{regexec@\verb,regexec,!value (\verb,Regex,)}
val regexecBool  : regex \verb"-"\verb">" eflag list \verb"-"\verb">" string \verb"-"\verb">" bool\index{regexecBool@\verb,regexecBool,!value (\verb,Regex,)}

val regnexec     : regex \verb"-"\verb">" eflag list \verb"-"\verb">" substring \index{regnexec@\verb,regnexec,!value (\verb,Regex,)}
                   \verb"-"\verb">" substring vector option
val regnexecBool : regex \verb"-"\verb">" eflag list \verb"-"\verb">" substring \verb"-"\verb">" bool\index{regnexecBool@\verb,regnexecBool,!value (\verb,Regex,)}

val regmatch     : \verb"{" pat : string, tgt : string \verb"}" \verb"-"\verb">" cflag list \index{regmatch@\verb,regmatch,!value (\verb,Regex,)}
                     \verb"-"\verb">" eflag list \verb"-"\verb">" substring vector option
val regmatchBool : \verb"{" pat : string, tgt : string \verb"}" \verb"-"\verb">" cflag list \index{regmatchBool@\verb,regmatchBool,!value (\verb,Regex,)}
                     \verb"-"\verb">" eflag list \verb"-"\verb">" bool

datatype replacer =\index{replacer@\verb,replacer,!type (\verb,Regex,)}
    Str of string                       {\itshape{}A literal string             }
  | Sus of int                          {\itshape{}The i'th parenthesized group }
  | Tr  of (string \verb"-"\verb">" string) * int     {\itshape{}Transformation of i'th group }
  | Trs of substring vector \verb"-"\verb">" string   {\itshape{}Transformation of all groups }

val replace1     : regex \verb"-"\verb">" replacer list \verb"-"\verb">" string \verb"-"\verb">" string\index{replace1@\verb,replace1,!value (\verb,Regex,)}
val replace      : regex \verb"-"\verb">" replacer list \verb"-"\verb">" string \verb"-"\verb">" string\index{replace@\verb,replace,!value (\verb,Regex,)}

val substitute1  : regex \verb"-"\verb">" (string \verb"-"\verb">" string) \verb"-"\verb">" string \verb"-"\verb">" string\index{substitute1@\verb,substitute1,!value (\verb,Regex,)}
val substitute   : regex \verb"-"\verb">" (string \verb"-"\verb">" string) \verb"-"\verb">" string \verb"-"\verb">" string\index{substitute@\verb,substitute,!value (\verb,Regex,)}

val tokens       : regex \verb"-"\verb">" string \verb"-"\verb">" substring list\index{tokens@\verb,tokens,!value (\verb,Regex,)}
val fields       : regex \verb"-"\verb">" string \verb"-"\verb">" substring list\index{fields@\verb,fields,!value (\verb,Regex,)}

val map          : regex \verb"-"\verb">" (substring vector \verb"-"\verb">" 'a) \verb"-"\verb">" string \verb"-"\verb">" 'a list\index{map@\verb,map,!value (\verb,Regex,)}
val app          : regex \verb"-"\verb">" (substring vector \verb"-"\verb">" unit) \verb"-"\verb">" string \verb"-"\verb">" unit\index{app@\verb,app,!value (\verb,Regex,)}
val fold         : regex \index{fold@\verb,fold,!value (\verb,Regex,)}
                   \verb"-"\verb">" (substring * 'a \verb"-"\verb">" 'a) * (substring vector * 'a \verb"-"\verb">" 'a) 
                   \verb"-"\verb">" 'a \verb"-"\verb">" string \verb"-"\verb">" 'a

\separatingline
   This structure provides pattern matching with POSIX 1003.2 regular
   expressions.  

   The form and meaning of Extended and Basic regular expressions are
   described below.  Here R and S denote regular expressions; m and n
   denote natural numbers; L denotes a character list; and d denotes a
   decimal digit:

        Extended    Basic       Meaning
       \verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"
        c           c           Match the character c
        .           .           Match any character
        R*          R*          Match R zero or more times
        R+          R\verb"\"+         Match R one or more times
        R|S         R\verb"\"|S        Match R or S
        R?          R\verb"\"?         Match R or the empty string
        R\verb"{"m\verb"}"        R\verb"\"\verb"{"m\verb"\"\verb"}"      Match R exactly m times
        R\verb"{"m,\verb"}"       R\verb"\"\verb"{"m,\verb"\"\verb"}"     Match R at least m times
        R\verb"{"m,n\verb"}"      R\verb"\"\verb"{"m,n\verb"\"\verb"}"    Match R at least m and at most n times
        [L]         [L]         Match any character in L
        [^L]        [^L]        Match any character not in L
        ^           ^           Match at string's beginning
        \$           \$           Match at string's end
        (R)         \verb"\"(R\verb"\")       Match R as a group; save the match
        \verb"\"d          \verb"\"d          Match the same as previous group d
        \verb"\"\verb"\"          \verb"\"\verb"\"          Match \verb"\" \verb"-"\verb"-"\verb"-" similarly for *.[]^\$
        \verb"\"+          +           Match + \verb"-"\verb"-"\verb"-" similarly for |?\verb"{"\verb"}"()

   Some example character lists L:

        [aeiou]         Match vowel: a or e or i or o or u
        [0\verb"-"9]           Match digit: 0 or 1 or 2 or ... or 9
        [^0\verb"-"9]          Match non\verb"-"digit
        [\verb"-"+*/^]         Match \verb"-" or + or * or / or ^
        [\verb"-"a\verb"-"z]          Match lowercase letter or hyphen (\verb"-")
        [0\verb"-"9a\verb"-"fA\verb"-"F]     Match hexadecimal digit
        [[:alnum:]]     Match letter or digit
        [[:alpha:]]     Match letter 
        [[:cntrl:]]     Match ASCII control character
        [[:digit:]]     Match decimal digit; same as [0\verb"-"9]
        [[:graph:]]     Same as [:print:] but not [:space:]
        [[:lower:]]     Match lowercase letter
        [[:print:]]     Match printable character
        [[:punct:]]     Match punctuation character
        [[:space:]]     Match SML #" ", #"\verb"\"r", #"\verb"\"n", #"\verb"\"t", #"\verb"\"v", #"\verb"\"f"
        [[:upper:]]     Match uppercase letter
        [[:xdigit:]]    Match hexadecimal digit; same as [0\verb"-"9a\verb"-"fA\verb"-"F]
        [[:lower:]]  Match lowercase Danish letters (ISO Latin 1)

   Remember that backslash (\verb"\") must be escaped as "\verb"\"\verb"\"" in SML strings.

   [regcomp pat cflags] returns a compiled representation of the\index{regcomp@\verb,regcomp,!value (\verb,Regex,)}
   regular expression pat.  Raises Regex in case of failure.  

   [cflag] is the type of compilation flags with the following meanings:\index{cflag@\verb,cflag,!type (\verb,Regex,)}

   [Extended] : compile as POSIX extended regular expression.\index{Extended@\verb,Extended,!constructor (\verb,Regex,)}
   [Icase]    : compile case\verb"-"insensitive match.\index{Icase@\verb,Icase,!constructor (\verb,Regex,)}
   [Newline]  : make the newline character \verb"\"n significant, so ^ matches \index{Newline@\verb,Newline,!constructor (\verb,Regex,)}
                just after newline (\verb"\"n), and \$ matches just before \verb"\"n.

   Example: Match SML integer constant:
   regcomp "^~?[0\verb"-"9]+\$" [Extended] 

   Example: Match SML alphanumeric identifier:
   regcomp "^[a\verb"-"zA\verb"-"Z0\verb"-"9][a\verb"-"zA\verb"-"Z0\verb"-"9'_]*\$" [Extended]

   Example: Match SML floating\verb"-"point constant:
   regcomp "^[+~]?[0\verb"-"9]+(\verb"\"\verb"\".[0\verb"-"9]+|(\verb"\"\verb"\".[0\verb"-"9]+)?[eE][+~]?[0\verb"-"9]+)\$" [Extended]

   Example: Match any HTML start tag; make the tag's name into a group:
   regcomp "\verb"<"([[:alnum:]]+)[^\verb">"]*\verb">"" [Extended]

   [regexec regex eflags s] returns SOME(vec) if some substring of s\index{regexec@\verb,regexec,!value (\verb,Regex,)}
   matches regex, NONE otherwise.  In case of success, vec is the
   match vector, a vector of substrings such that vec[0] is the
   (longest leftmost) substring of s matching regex, and vec[1],
   vec[2], ... are substrings matching the parenthesized groups in pat
   (numbered 1, 2, ... from left to right in the order of their
   opening parentheses).  For a group that does not take part in the
   match, such as (ab) in "(ab)|(cd)" when matched against the string
   "xcdy", the corresponding substring is the empty substring at the
   beginning of the underlying string.  For a group that takes part in
   the match repeatedly, such as the group (b+) in "(a(b+))*" when
   matched against "babbabbb", the corresponding substring is the last
   (rightmost) one matched.  

   [eflag] is the type of end flags with the following meaning:\index{eflag@\verb,eflag,!type (\verb,Regex,)}

   [Notbol] : do not match ^ at beginning of string.\index{Notbol@\verb,Notbol,!constructor (\verb,Regex,)}
   [Noteol] : do not match \$ at end of string.\index{Noteol@\verb,Noteol,!constructor (\verb,Regex,)}

   [regexecBool regex eflags s] returns true if some substring of s\index{regexecBool@\verb,regexecBool,!value (\verb,Regex,)}
   matches regex, false otherwise.  Equivalent to, but faster than, 
   Option.isSome(regexec regexec eflags s).

   [regnexec regex eflags sus] returns SOME(vec) if some substring of\index{regnexec@\verb,regnexec,!value (\verb,Regex,)}
   sus matches regex, NONE otherwise.  The substrings returned in the
   vector vec will have the same base string as sus.  Useful e.g. for
   splitting a string into fragments separated by substrings matching
   some regular expression.

   [regnexecBool regex eflags sus] returns true if some substring of\index{regnexecBool@\verb,regnexecBool,!value (\verb,Regex,)}
   sus matches regex, false otherwise.  Equivalent to, but faster than, 
   Option.isSome(regnexec regexec eflags sus).

   [regmatch \verb"{" pat, tgt \verb"}" cflags eflags] is equivalent to \index{regmatch@\verb,regmatch,!value (\verb,Regex,)}
         regexec (regcomp pat cflags) eflags tgt
   but more efficient when the compiled regex is used only once.

   [regmatchBool \verb"{" pat, tgt \verb"}" cflags eflags] is equivalent to \index{regmatchBool@\verb,regmatchBool,!value (\verb,Regex,)}
         regexecBool (regcomp pat cflags) eflags tgt 
   but more efficient when the compiled regex is used only once.

   [replace regex repl s] finds the (disjoint) substrings of s\index{replace@\verb,replace,!value (\verb,Regex,)}
   matching regex from left to right, and returns the string obtained
   from s by applying the replacer list repl to every such substring
   (see below).  Raises Regex if it fails to make progress in
   decomposing s, that is, if regex matches an empty string at the
   head of s or immediately after a previous regex match.
   Example use: delete all HTML tags from s: 
        replace (regcomp "\verb"<"[^\verb">"]+\verb">"" [Extended]) [] s

   [replace1 regex repl s] finds the leftmost substring b1 of s\index{replace1@\verb,replace1,!value (\verb,Regex,)}
   matching regex, and returns the string resulting from s by applying
   the replacer list repl to the match vector vec1 (see below).

   Let x0 be a substring matching the entire regex and xi be the
   substring matching the i'th parenthesized group in regex; thus xi =
   vec[i] where vec is the match vector (see regexec above).  Then a
   single replacer evaluates to a string as follows:

   [Str s]      gives the string  s\index{Str@\verb,Str,!constructor (\verb,Regex,)}
   [Sus i]      gives the string  xi\index{Sus@\verb,Sus,!constructor (\verb,Regex,)}
   [Tr (f, i)]  gives the string  f(xi)\index{Tr@\verb,Tr,!constructor (\verb,Regex,)}
   [Trs f]      gives the string  f(vec)\index{Trs@\verb,Trs,!constructor (\verb,Regex,)}

   A replacer list repl evaluates to the concatenation of the results
   of the replacers.  The replacers are applied from left to right.

   [substitute regex f s] finds the (disjoint) substrings b1, ..., bn\index{substitute@\verb,substitute,!value (\verb,Regex,)}
   of s matching regex from left to right, and returns the string
   obtained from s by replacing every bi by f(bi).  Function f is
   applied to the matching substrings from left to right.  Raises
   Regex if it fails to make progress in decomposing s.  Equivalent to
        replace regex [Tr (f, 0)] s

   [substitute1 regex f s] finds the leftmost substring b of s\index{substitute1@\verb,substitute1,!value (\verb,Regex,)}
   matching regex, and returns the string obtained from s by replacing
   that substring by f(b).  Equivalent to 
        replace1 regex [Tr (f, 0)] s

   [map regex f s] finds the (disjoint) substrings of s matching regex\index{map@\verb,map,!value (\verb,Regex,)}
   from left to right, applies f to the match vectors vec1, ..., vecn,
   and returns the list [f(vec1), ..., f(vecn)].  Raises Regex if it
   fails to make progress in decomposing s.

   [app regex f s] finds the (disjoint) substrings of s matching regex\index{app@\verb,app,!value (\verb,Regex,)}
   from left to right, and applies f to the match vectors vec1, ...,
   vecn.  Raises Regex if the regex fails to make progress in
   decomposing s.

   [fields regex s] returns the list of fields in s, from left to\index{fields@\verb,fields,!value (\verb,Regex,)}
   right.  A field is a (possibly empty) maximal substring of s not
   containing any delimiter.  A delimiter is a maximal substring that
   matches regex.  The eflags Notbol and Noteol are set.  Raises Regex
   if it fails to make progress in decomposing s.
   Example use: 
        fields (regcomp " *; *" []) "56; 23 ; 22;; 89; 99"

   [tokens regex s] returns the list of tokens in s, from left to\index{tokens@\verb,tokens,!value (\verb,Regex,)}
   right.  A token is a non\verb"-"empty maximal substring of s not
   containing any delimiter.  A delimiter is a maximal substring that
   matches regex.  The eflags Notbol and Noteol are set.  Raises Regex
   if it fails to make progress in decomposing s.  Equivalent to 
        List.filter (not o Substring.isEmpty) (fields regex s)

   Two tokens may be separated by more than one delimiter, whereas two
   fields are separated by exactly one delimiter.  If the only delimiter 
   is the character #"|", then
        "abc||def" contains three fields: "abc" and "" and "def"
        "abc||def" contains two tokens:   "abc" and "def"

   [fold regex (fa, fb) e s] finds the (disjoint) substrings b1, ...,\index{fold@\verb,fold,!value (\verb,Regex,)}
   bn of s matching regex from left to right, and splits s into the
   substrings 
        a0, b1, a1, b2, a2, ..., bn, an         
   where n \verb">"= 0 and where a0 is the (possibly empty) substring of s
   preceding the first match, and ai is the (possibly empty) substring
   between the matches bi and b(i+1).  Then it computes and returns
        fa(an, fb(vecn, ..., fa(a1, fb(vec1, fa(a0, e))) ...))  
   where veci is the match vector corresponding to bi.  Raises Regex
   if it fails to make progress in decomposing s.

   If we define the auxiliary functions
        fun fapp f (x, r) = f x :: r
        fun get i vec = Substring.string(Vector.sub(vec, i))
   then 
        map regex f s  = List.rev (fold regex (#2, fapp f) [] s)
        app regex f s  = fold regex (ignore, f o #1) () s
        fields regex s = List.rev (fold regex (op ::, #2) [] s)
        substitute regex f s = 
           Substring.concat(List.rev 
              (fold regex (op ::, fapp (Substring.all o f o get 0)) [] s))
\end{longprogram}
\index{Regex@\verb,Regex, (structure)|)}\newpage

\section*{Module SML90}
\index{SML90@\verb,SML90, (structure)|(}
\markboth{\MakeUppercase{SML90}}{\MakeUppercase{SML90}}
\addcontentsline{toc}{section}{SML90}
\begin{longprogram}
{\itshape{}SML90 \verb"-"\verb"-" part of the initial basis of the 1990 Definition }

{\itshape{}Math }

val sqrt    : real \verb"-"\verb">" real\index{sqrt@\verb,sqrt,!value (\verb,SML90,)}
val sin     : real \verb"-"\verb">" real\index{sin@\verb,sin,!value (\verb,SML90,)}
val cos     : real \verb"-"\verb">" real\index{cos@\verb,cos,!value (\verb,SML90,)}
val arctan  : real \verb"-"\verb">" real\index{arctan@\verb,arctan,!value (\verb,SML90,)}
val exp     : real \verb"-"\verb">" real\index{exp@\verb,exp,!value (\verb,SML90,)}
val ln      : real \verb"-"\verb">" real\index{ln@\verb,ln,!value (\verb,SML90,)}

{\itshape{}Strings }

val chr     : int \verb"-"\verb">" string\index{chr@\verb,chr,!value (\verb,SML90,)}
val ord     : string \verb"-"\verb">" int\index{ord@\verb,ord,!value (\verb,SML90,)}

val explode : string \verb"-"\verb">" string list\index{explode@\verb,explode,!value (\verb,SML90,)}
val implode : string list \verb"-"\verb">" string\index{implode@\verb,implode,!value (\verb,SML90,)}

exception Abs  \index{Abs@\verb,Abs,!exception (\verb,SML90,)}
      and Diff 
      and Exp  
      and Floor
      and Neg  
      and Prod 
      and Sum  
      and Mod  
      and Quot

{\itshape{}Input/output }

type instream and outstream\index{instream@\verb,instream,!type (\verb,SML90,)}

val std_in        : instream\index{std_in@\verb,std_in,!value (\verb,SML90,)}
val open_in       : string \verb"-"\verb">" instream\index{open_in@\verb,open_in,!value (\verb,SML90,)}
val input         : instream * int \verb"-"\verb">" string\index{input@\verb,input,!value (\verb,SML90,)}
val lookahead     : instream \verb"-"\verb">" string\index{lookahead@\verb,lookahead,!value (\verb,SML90,)}
val close_in      : instream \verb"-"\verb">" unit\index{close_in@\verb,close_in,!value (\verb,SML90,)}
val end_of_stream : instream \verb"-"\verb">" bool\index{end_of_stream@\verb,end_of_stream,!value (\verb,SML90,)}

val std_out       : outstream\index{std_out@\verb,std_out,!value (\verb,SML90,)}
val open_out      : string \verb"-"\verb">" outstream\index{open_out@\verb,open_out,!value (\verb,SML90,)}
val output        : outstream * string \verb"-"\verb">" unit\index{output@\verb,output,!value (\verb,SML90,)}
val close_out     : outstream \verb"-"\verb">" unit\index{close_out@\verb,close_out,!value (\verb,SML90,)}
\end{longprogram}
\index{SML90@\verb,SML90, (structure)|)}\newpage

\section*{Module Signal}
\index{Signal@\verb,Signal, (structure)|(}
\markboth{\MakeUppercase{Signal}}{\MakeUppercase{Signal}}
\addcontentsline{toc}{section}{Signal}
\begin{longprogram}
{\itshape{}Signal \verb"-"\verb"-" SML Basis Library }

eqtype signal\index{signal@\verb,signal,!type (\verb,Signal,)}

val abrt : signal \index{abrt@\verb,abrt,!value (\verb,Signal,)}
val alrm : signal \index{alrm@\verb,alrm,!value (\verb,Signal,)}
val bus  : signal \index{bus@\verb,bus,!value (\verb,Signal,)}
val fpe  : signal \index{fpe@\verb,fpe,!value (\verb,Signal,)}
val hup  : signal \index{hup@\verb,hup,!value (\verb,Signal,)}
val ill  : signal \index{ill@\verb,ill,!value (\verb,Signal,)}
val int  : signal \index{int@\verb,int,!value (\verb,Signal,)}
val kill : signal \index{kill@\verb,kill,!value (\verb,Signal,)}
val pipe : signal \index{pipe@\verb,pipe,!value (\verb,Signal,)}
val quit : signal \index{quit@\verb,quit,!value (\verb,Signal,)}
val segv : signal \index{segv@\verb,segv,!value (\verb,Signal,)}
val term : signal \index{term@\verb,term,!value (\verb,Signal,)}
val usr1 : signal \index{usr1@\verb,usr1,!value (\verb,Signal,)}
val usr2 : signal \index{usr2@\verb,usr2,!value (\verb,Signal,)}
val chld : signal \index{chld@\verb,chld,!value (\verb,Signal,)}
val cont : signal \index{cont@\verb,cont,!value (\verb,Signal,)}
val stop : signal \index{stop@\verb,stop,!value (\verb,Signal,)}
val tstp : signal \index{tstp@\verb,tstp,!value (\verb,Signal,)}
val ttin : signal \index{ttin@\verb,ttin,!value (\verb,Signal,)}
val ttou : signal \index{ttou@\verb,ttou,!value (\verb,Signal,)}

val toWord   : signal \verb"-"\verb">" Word.word \index{toWord@\verb,toWord,!value (\verb,Signal,)}
val fromWord : Word.word \verb"-"\verb">" signal \index{fromWord@\verb,fromWord,!value (\verb,Signal,)}

\separatingline
   [signal] is the type of Unix/Posix\verb"-"style signals, which can be sent\index{signal@\verb,signal,!type (\verb,Signal,)}
   to another process.  

   [toWord sig] returns the signal number as an unsigned word.\index{toWord@\verb,toWord,!value (\verb,Signal,)}

   [fromWord w] returns the signal whose number is w.\index{fromWord@\verb,fromWord,!value (\verb,Signal,)}

   [abrt] is SIGABRT, the abort signal from abort(3).\index{abrt@\verb,abrt,!value (\verb,Signal,)}

   [alrm] is SIGALRM, a timer signal from alarm(1).\index{alrm@\verb,alrm,!value (\verb,Signal,)}

   [bus]  is SIGBUS, a bus error.\index{bus@\verb,bus,!value (\verb,Signal,)}

   [fpe]  is SIGFPE, a floating point exception.\index{fpe@\verb,fpe,!value (\verb,Signal,)}

   [hup]  is SIGHUP, a hangup.\index{hup@\verb,hup,!value (\verb,Signal,)}

   [ill]  is SIGILL, an illegal instruction.\index{ill@\verb,ill,!value (\verb,Signal,)}

   [int]  is SIGINT, an interrupt.\index{int@\verb,int,!value (\verb,Signal,)}

   [kill] is SIGKILL, the kill signal.\index{kill@\verb,kill,!value (\verb,Signal,)}

   [pipe] is SIGPIPE, a broken pipe.\index{pipe@\verb,pipe,!value (\verb,Signal,)}

   [quit] is SIGQUIT, a quit from keyboard.\index{quit@\verb,quit,!value (\verb,Signal,)}

   [segv] is SIGSEGV, a segmentation violation.\index{segv@\verb,segv,!value (\verb,Signal,)}

   [term] is SIGTERM, the termination signal.\index{term@\verb,term,!value (\verb,Signal,)}

   [usr1] is SIGUSR1, the first user signal.\index{usr1@\verb,usr1,!value (\verb,Signal,)}

   [usr2] is SIGUSR2, the second user signal.\index{usr2@\verb,usr2,!value (\verb,Signal,)}
   
   [chld] is SIGCHLD, child process stopped or terminated.\index{chld@\verb,chld,!value (\verb,Signal,)}

   [cont] is SIGCONT, continue if stopped.\index{cont@\verb,cont,!value (\verb,Signal,)}

   [stop] is SIGSTOP, signal to stop process.\index{stop@\verb,stop,!value (\verb,Signal,)}

   [tstp] is SIGTSTP, a stop signal typed at the tty.

   [ttin] is SIGTTIN, tty input for background process.\index{ttin@\verb,ttin,!value (\verb,Signal,)}

   [ttou] is SIGTTOU, tty output for background process.\index{ttou@\verb,ttou,!value (\verb,Signal,)}
\end{longprogram}
\index{Signal@\verb,Signal, (structure)|)}\newpage

\section*{Module Socket}
\index{Socket@\verb,Socket, (structure)|(}
\markboth{\MakeUppercase{Socket}}{\MakeUppercase{Socket}}
\addcontentsline{toc}{section}{Socket}
\begin{longprogram}
{\itshape{}Socket \verb"-"\verb"-" SML Basis Library \verb"-"\verb"-" requires Dynlib }

type ('addressfam, 'socktype) sock\index{sock@\verb,sock,!type (\verb,Socket,)}
type 'addressfam sock_addr\index{sock_addr@\verb,sock_addr,!type (\verb,Socket,)}

{\itshape{}Socket types }
type dgram                              {\itshape{}A datagram socket             }\index{dgram@\verb,dgram,!type (\verb,Socket,)}
type 'a stream                          {\itshape{}A stream socket               }\index{stream@\verb,stream,!type (\verb,Socket,)}
type passive                            {\itshape{}A passive stream              }\index{passive@\verb,passive,!type (\verb,Socket,)}
type active                             {\itshape{}An active, connected, stream  }\index{active@\verb,active,!type (\verb,Socket,)}

{\itshape{}Socket protocol families }
type pf_file                            {\itshape{}The Unix file protocol family }\index{pf_file@\verb,pf_file,!type (\verb,Socket,)}
type pf_inet                            {\itshape{}The Internet protocol family  }\index{pf_inet@\verb,pf_inet,!type (\verb,Socket,)}

{\itshape{}Address constructors }
val fileAddr   : string \verb"-"\verb">" pf_file sock_addr\index{fileAddr@\verb,fileAddr,!value (\verb,Socket,)}
val inetAddr   : string \verb"-"\verb">" int \verb"-"\verb">" pf_inet sock_addr\index{inetAddr@\verb,inetAddr,!value (\verb,Socket,)}

{\itshape{}Socket constructors }
val fileStream : unit \verb"-"\verb">" (pf_file, 'a stream) sock\index{fileStream@\verb,fileStream,!value (\verb,Socket,)}
val fileDgram  : unit \verb"-"\verb">" (pf_file, dgram) sock\index{fileDgram@\verb,fileDgram,!value (\verb,Socket,)}
val inetStream : unit \verb"-"\verb">" (pf_inet, 'a stream) sock\index{inetStream@\verb,inetStream,!value (\verb,Socket,)}
val inetDgram  : unit \verb"-"\verb">" (pf_inet, dgram) sock\index{inetDgram@\verb,inetDgram,!value (\verb,Socket,)}

val accept     : ('a, passive stream) sock \index{accept@\verb,accept,!value (\verb,Socket,)}
                 \verb"-"\verb">" ('a, active stream) sock * 'a sock_addr
val bind       : ('a, 'b) sock * 'a sock_addr \verb"-"\verb">" unit\index{bind@\verb,bind,!value (\verb,Socket,)}
val connect    : ('a, 'b) sock * 'a sock_addr \verb"-"\verb">" unit\index{connect@\verb,connect,!value (\verb,Socket,)}
val listen     : ('a, passive stream) sock * int \verb"-"\verb">" unit\index{listen@\verb,listen,!value (\verb,Socket,)}
val close      : ('a, 'b) sock \verb"-"\verb">" unit\index{close@\verb,close,!value (\verb,Socket,)}

{\itshape{}Socket management }
datatype shutdown_mode = \index{shutdown_mode@\verb,shutdown_mode,!type (\verb,Socket,)}
    NO_RECVS                            {\itshape{}No further receives   }
  | NO_SENDS                            {\itshape{}No further sends      }
  | NO_RECVS_OR_SENDS                   {\itshape{}No receives nor sends }

val shutdown   : ('a, 'b stream) sock * shutdown_mode \verb"-"\verb">" unit\index{shutdown@\verb,shutdown,!value (\verb,Socket,)}

type sock_desc\index{sock_desc@\verb,sock_desc,!type (\verb,Socket,)}

val sockDesc   : ('a, 'b) sock \verb"-"\verb">" sock_desc\index{sockDesc@\verb,sockDesc,!value (\verb,Socket,)}
val sameDesc   : sock_desc * sock_desc \verb"-"\verb">" bool\index{sameDesc@\verb,sameDesc,!value (\verb,Socket,)}
val compare    : sock_desc * sock_desc \verb"-"\verb">" order\index{compare@\verb,compare,!value (\verb,Socket,)}
val select     : \index{select@\verb,select,!value (\verb,Socket,)}
    \verb"{" rds : sock_desc list, wrs : sock_desc list, exs : sock_desc list, 
      timeout : Time.time option \verb"}" 
    \verb"-"\verb">" \verb"{" rds : sock_desc list, wrs : sock_desc list, exs : sock_desc list \verb"}"

val getinetaddr : pf_inet sock_addr \verb"-"\verb">" string\index{getinetaddr@\verb,getinetaddr,!value (\verb,Socket,)}

{\itshape{}Sock I/O option types }
type out_flags = \verb"{" don't_route : bool, oob : bool \verb"}"\index{out_flags@\verb,out_flags,!type (\verb,Socket,)}
type in_flags  = \verb"{" peek : bool, oob : bool \verb"}"\index{in_flags@\verb,in_flags,!type (\verb,Socket,)}

type 'a buf = \verb"{" buf : 'a, ofs : int, size : int option \verb"}"\index{buf@\verb,buf,!type (\verb,Socket,)}


{\itshape{}Socket output operations }
val sendVec    : ('a, active stream) sock * Word8Vector.vector buf \verb"-"\verb">" int\index{sendVec@\verb,sendVec,!value (\verb,Socket,)}
val sendArr    : ('a, active stream) sock * Word8Array.array buf \verb"-"\verb">" int\index{sendArr@\verb,sendArr,!value (\verb,Socket,)}
val sendVec'   : ('a, active stream) sock * Word8Vector.vector buf \index{sendVec'@\verb,sendVec',!value (\verb,Socket,)}
                 * out_flags \verb"-"\verb">" int
val sendArr'   : ('a, active stream) sock * Word8Array.array buf \index{sendArr'@\verb,sendArr',!value (\verb,Socket,)}
                 * out_flags \verb"-"\verb">" int
val sendVecTo  : ('a, dgram) sock * 'a sock_addr * Word8Vector.vector buf\index{sendVecTo@\verb,sendVecTo,!value (\verb,Socket,)}
                 \verb"-"\verb">" int
val sendArrTo  : ('a, dgram) sock * 'a sock_addr * Word8Array.array buf \index{sendArrTo@\verb,sendArrTo,!value (\verb,Socket,)}
                 \verb"-"\verb">" int
val sendVecTo' : ('a, dgram) sock * 'a sock_addr * Word8Vector.vector buf\index{sendVecTo'@\verb,sendVecTo',!value (\verb,Socket,)}
                 * out_flags \verb"-"\verb">" int
val sendArrTo' : ('a, dgram) sock * 'a sock_addr * Word8Array.array buf\index{sendArrTo'@\verb,sendArrTo',!value (\verb,Socket,)}
                 * out_flags \verb"-"\verb">" int

{\itshape{}Socket input operations }
val recvVec      : ('a, active stream) sock * int \verb"-"\verb">" Word8Vector.vector\index{recvVec@\verb,recvVec,!value (\verb,Socket,)}
val recvArr      : ('a, active stream) sock * Word8Array.array buf \verb"-"\verb">" int\index{recvArr@\verb,recvArr,!value (\verb,Socket,)}
val recvVec'     : ('a, active stream) sock * int * in_flags\index{recvVec'@\verb,recvVec',!value (\verb,Socket,)}
                   \verb"-"\verb">" Word8Vector.vector
val recvArr'     : ('a, active stream) sock * Word8Array.array buf * in_flags\index{recvArr'@\verb,recvArr',!value (\verb,Socket,)}
                   \verb"-"\verb">" int
val recvVecFrom  : ('a, dgram) sock * int \index{recvVecFrom@\verb,recvVecFrom,!value (\verb,Socket,)}
                   \verb"-"\verb">" Word8Vector.vector * 'a sock_addr
val recvArrFrom  : ('a, dgram) sock * Word8Array.array buf \index{recvArrFrom@\verb,recvArrFrom,!value (\verb,Socket,)}
                   \verb"-"\verb">" int * 'a sock_addr
val recvVecFrom' : ('a, dgram) sock * int * in_flags\index{recvVecFrom'@\verb,recvVecFrom',!value (\verb,Socket,)}
                   \verb"-"\verb">" Word8Vector.vector * 'a sock_addr
val recvArrFrom' : ('a, dgram) sock * Word8Array.array buf * in_flags\index{recvArrFrom'@\verb,recvArrFrom',!value (\verb,Socket,)}
                   \verb"-"\verb">" int * 'a sock_addr

\separatingline
   Structure Socket defines functions for creating and using sockets,
   a means for communication between SML processes on the same machine
   or via a network.

   [('addressfam, 'socktype) sock] is the type of sockets with address\index{sock@\verb,sock,!type (\verb,Socket,)}
   family 'addressfam and having type 'socktype.

   ['addressfam sock_addr] is the type of sockets addresses.\index{sock_addr@\verb,sock_addr,!type (\verb,Socket,)}

   The possible address (protocol) families are 

        type pf_file    The Unix address family (file)\index{pf_file@\verb,pf_file,!type (\verb,Socket,)}
        type pf_inet    The Internet address family\index{pf_inet@\verb,pf_inet,!type (\verb,Socket,)}

   The possible socket types are 
        type dgram      datagram sockets\index{dgram@\verb,dgram,!type (\verb,Socket,)}
        type 'a stream  stream sockets\index{stream@\verb,stream,!type (\verb,Socket,)}
        type passive    passive stream sockets\index{passive@\verb,passive,!type (\verb,Socket,)}
        type active     active, or connected, stream sockets\index{active@\verb,active,!type (\verb,Socket,)}

   [fileAddr fname] returns a socket address for the Unix protocol\index{fileAddr@\verb,fileAddr,!value (\verb,Socket,)}
   family, created from the given file name fname.

   [inetAddr inetaddr portno] returns a socket address for the\index{inetAddr@\verb,inetAddr,!value (\verb,Socket,)}
   Internet protocol family, created from the given Internet number
   (e.g. "130.225.40.253") and port number (e.g. 8080).

   [fileStream ()] returns a new stream socket for the Unix protocol\index{fileStream@\verb,fileStream,!value (\verb,Socket,)}
   family.

   [fileDgram ()] returns a new datagram socket for the Unix protocol\index{fileDgram@\verb,fileDgram,!value (\verb,Socket,)}
   family.

   [inetStream ()] returns a new stream socket for the Internet\index{inetStream@\verb,inetStream,!value (\verb,Socket,)}
   protocol family.

   [inetDgram ()] returns a new datagram socket for the Internet\index{inetDgram@\verb,inetDgram,!value (\verb,Socket,)}
   protocol family.

   [accept sock] extracts the first connection on the queue of pending\index{accept@\verb,accept,!value (\verb,Socket,)}
   connections to sock.  Returns (sock', addr) where sock' is a copy
   of the socket sock, bound to that connection, and addr is the
   address of the communications counterpart (the other end of the
   connection).  Blocks if no connections are pending.  The stream
   socket sock must have been assigned a name (with bind) and must be
   listening for connections (following a call to listen).

   [bind sock addr] binds the socket sock to the address addr, that\index{bind@\verb,bind,!value (\verb,Socket,)}
   is, assigns the name addr to the socket.  Binding a name in the
   Unix protocol family creates a socket in the file system that must
   be deleted when it is no longer needed

   [connect (sock, addr)] attempts to connect socket sock to the\index{connect@\verb,connect,!value (\verb,Socket,)}
   communications peer at address addr.  If sock is a datagram socket,
   then addr is the address to which datagrams is to be sent, and the
   only address from which datagrams will be accepted.  If sock is a
   stream socket, then addr specifies another socket to which to
   connect.

   [listen (sock, queuelen)] enables the passive stream socket sock to\index{listen@\verb,listen,!value (\verb,Socket,)}
   accept incoming connections.  The parameter queuelen specifies the
   maximal number of pending connections.  Further connections from
   clients may be refised when this limit is reached.

   [close sock] closes the socket.\index{close@\verb,close,!value (\verb,Socket,)}

   [shutdown sock shutdown_mode] shuts down socket sock for further\index{shutdown@\verb,shutdown,!value (\verb,Socket,)}
   communication, as specified by the shutdown_mode parameter:

   [NO_RECVS]           no further receives are allowed;\index{NO_RECVS@\verb,NO_RECVS,!constructor (\verb,Socket,)}

   [NO_SENDS]           no further sends are allowed;\index{NO_SENDS@\verb,NO_SENDS,!constructor (\verb,Socket,)}

   [NO_RECVS_OR_SENDS]  no further receives or sends are allowed.\index{NO_RECVS_OR_SENDS@\verb,NO_RECVS_OR_SENDS,!constructor (\verb,Socket,)}

   [getinetaddr addr] returns the Internet number\index{getinetaddr@\verb,getinetaddr,!value (\verb,Socket,)}
   (e.g. "130.225.40.253") of the Internet socket address addr.

   ['a buf] is the type of records \verb"{" buf, ofs, size \verb"}" which represent\index{buf@\verb,buf,!type (\verb,Socket,)}
   subvectors or subarrays:
   if size = SOME s it represents buf[ofs..ofs+s\verb"-"1];
   if size = NONE   it represents buf[ofs..len\verb"-"1] where len is buf's length.
   When the subbuffer is used in a call, exception Subscript will be raised 
   if ofs \verb"<" 0 or size \verb"<" 0 or ofs+size \verb">" len.   

   [sendVec (sock, vecbuf)] transmits the bytes from buffer vecbuf on\index{sendVec@\verb,sendVec,!value (\verb,Socket,)}
   the active stream socket sock.  Returns the number of bytes sent.
   Blocks until sufficient space is available at the socket.

   [sendArr (sock, arrbuf)] is analogous til sendVec.\index{sendArr@\verb,sendArr,!value (\verb,Socket,)}

   [sendVec' (sock, vecbuf, out_flags)] transmits the bytes from\index{sendVec'@\verb,sendVec',!value (\verb,Socket,)}
   buffer vecbuf on the active stream socket sock, observing the
   out_flags.  Returns the number of bytes sent.  Blocks until
   sufficient space is available at the socket.

   [out_flags] is the type of records \verb"{" don't_route, oob \verb"}" in which\index{out_flags@\verb,out_flags,!type (\verb,Socket,)}
   the field don't_route specifies whether routing should be bypassed,
   and the field oob specifies whether data should be sent out\verb"-"of\verb"-"band.

   [sendArr' (sock, arrbuf, out_flags)] is analogous til sendVec'.\index{sendArr'@\verb,sendArr',!value (\verb,Socket,)}

   [sendVecTo (sock, addr, vecbuf)] transmits the bytes from buffer\index{sendVecTo@\verb,sendVecTo,!value (\verb,Socket,)}
   vecbuf on the datagram socket sock to the target address addr.
   Returns the number of bytes sent.  Blocks until sufficient space is
   available at the socket.

   [sendArrTo (sock, addr, arrbuf)] is analogous til sendVecTo.\index{sendArrTo@\verb,sendArrTo,!value (\verb,Socket,)}

   [sendVecTo' (sock, addr, vecbuf, out_flags)] transmits the bytes\index{sendVecTo'@\verb,sendVecTo',!value (\verb,Socket,)}
   from buffer vecbuf on the datagram socket sock to the target
   address addr, observing the out_flags.  Returns the number of bytes
   sent.  Blocks until sufficient space is available at the socket.
   See above for a description of vecbuf and out_flags.

   [sendArrTo' (sock, addr, arrbuf, out_flags)] is analogous til sendVecTo'.\index{sendArrTo'@\verb,sendArrTo',!value (\verb,Socket,)}

   [recvVec (sock, n)] receives up to n bytes from the active stream\index{recvVec@\verb,recvVec,!value (\verb,Socket,)}
   socket sock.  Returns a byte vector containing the bytes actually
   received.  Blocks until some data become available at the socket,
   then returns any available data, up to n bytes.  Excess data are
   not lost; they are available for subsequent receive calls.

   [recvArr (sock, arrbuf)] receives bytes from the active stream\index{recvArr@\verb,recvArr,!value (\verb,Socket,)}
   socket sock into the subarray arrbuf, up to the available space.
   If #size(arrbuf) = SOME(s) the available space is s bytes; if
   #size(arrbuf) = NONE the available space is len \verb"-" #ofs(arrbuf)
   bytes.  Returns the number of bytes actually received.  Blocks
   until some data become available at the socket.  Excess data are
   not lost; they are available for subsequent receive calls.

   [recvVec' (sock, n, in_flags)] receives up to n bytes from the\index{recvVec'@\verb,recvVec',!value (\verb,Socket,)}
   active stream socket sock, observing the in_flags.  Returns a byte
   vector containing the bytes actually received.  Blocks until some
   data become available at the socket, then returns any available
   data, up to n bytes.  Data in excess of n bytes are not lost; they
   are available for subsequent receive calls.

   [in_flags] is the type of records \verb"{" peek, oob \verb"}" in which the field\index{in_flags@\verb,in_flags,!type (\verb,Socket,)}
   peek specifies that the data read should not be removed from the
   receive queue, and the field oob specifies that data may be
   received out\verb"-"of\verb"-"band.

   [recvArr' (sock, arrbuf, in_flags)] receives bytes from the active\index{recvArr'@\verb,recvArr',!value (\verb,Socket,)}
   stream socket sock into the subarray arrbuf, observing the
   in_flags, up to the available space..  Returns the number of bytes
   actually received.  Blocks until some data become available at the
   socket.  Excess data are not lost; they are available for
   subsequent receive calls.

   [recvVecFrom (sock, n)] receives up to n bytes from the datagram\index{recvVecFrom@\verb,recvVecFrom,!value (\verb,Socket,)}
   socket sock.  Returns a byte vector containing the bytes actually
   received.  Blocks until some data become available at the socket,
   then returns any available data, up to n bytes.

   [recvArrFrom (sock, arrbuf)] receives bytes from the datagram\index{recvArrFrom@\verb,recvArrFrom,!value (\verb,Socket,)}
   socket sock into the subarray arrbuf.  Returns the number of bytes
   actually received.  Blocks until some data become available at the
   socket.

   [recvVecFrom' (sock, n, in_flags)] receives up to n bytes from the\index{recvVecFrom'@\verb,recvVecFrom',!value (\verb,Socket,)}
   datagram socket sock, observing the in_flags (see above).  Returns
   (vec, addr) where vec is a byte vector containing the bytes
   actually received, and addr is the source address of the message.
   Blocks until some data become available at the socket, then returns
   any available data, up to n bytes.

   [recvArrFrom' (sock, arrbuf, in_flags)] receives bytes from the\index{recvArrFrom'@\verb,recvArrFrom',!value (\verb,Socket,)}
   datagram socket sock into the array buffer arrbuf, observing the
   in_flags (see above).  Returns (n, addr) where n is the number of
   bytes actually received, and addr is the source address of the
   message.  Blocks until some data become available at the socket.

   [sockDesc sock] returns a descriptor for the socket sock, to be\index{sockDesc@\verb,sockDesc,!value (\verb,Socket,)}
   used in a call to select.

   [compare (sd1, sd2)] compares sd1 and sd2 according to an\index{compare@\verb,compare,!value (\verb,Socket,)}
   unspecified total ordering, and returns LESS if sd1 precedes sd2,
   returns GREATER is sd1 precedes sd2, and returns EQUAL otherwise.
   
   [sameDesc (sd1, sd2)] returns true if sd1 and sd2 describe the same\index{sameDesc@\verb,sameDesc,!value (\verb,Socket,)}
   socket.  Equivalent to compare(sd1, sd2) = EQUAL.  

   [select \verb"{" rds, wrs, exs, timeout \verb"}"] blocks the calling process\index{select@\verb,select,!value (\verb,Socket,)}
   until some input/output operations become possible on some sockets.
   The call will check the sockets described in rds for reading, those
   in wrs for writing, and those in exs for exceptional conditions.
   Returns \verb"{" rds, wrs, exs \verb"}" where rds now is a list of descriptors of
   sockets ready for reading, wrs are ready for writing, and exs have
   exceptional conditions.  The order of the socket descriptors in the
   results is the same as their order in the corresponding arguments.
   If timeout is NONE then the call blocks until some input/output
   operations become possible; if timeout is SOME(t) then the call
   blocks for at most time t.

   A server socket is considered ready for reading if there is a
   pending connection which can be accepted with `accept'.  A client
   socket is ready for writing when its connection is fully
   established.
\end{longprogram}
\index{Socket@\verb,Socket, (structure)|)}\newpage

\section*{Module Splaymap}
\index{Splaymap@\verb,Splaymap, (structure)|(}
\markboth{\MakeUppercase{Splaymap}}{\MakeUppercase{Splaymap}}
\addcontentsline{toc}{section}{Splaymap}
\begin{longprogram}
{\itshape{}Splaymap \verb"-"\verb"-" applicative maps implemented by splay\verb"-"trees       }
{\itshape{}From SML/NJ lib 0.2, copyright 1993 by AT\&T Bell Laboratories }

type ('key, 'a) dict\index{dict@\verb,dict,!type (\verb,Splaymap,)}

exception NotFound\index{NotFound@\verb,NotFound,!exception (\verb,Splaymap,)}

val mkDict    : ('_key * '_key \verb"-"\verb">" order) \verb"-"\verb">" ('_key, '_a) dict\index{mkDict@\verb,mkDict,!value (\verb,Splaymap,)}
val insert    : ('_key, '_a) dict * '_key * '_a \verb"-"\verb">" ('_key, '_a) dict\index{insert@\verb,insert,!value (\verb,Splaymap,)}
val find      : ('key, 'a) dict * 'key \verb"-"\verb">" 'a\index{find@\verb,find,!value (\verb,Splaymap,)}
val peek      : ('key, 'a) dict * 'key \verb"-"\verb">" 'a option\index{peek@\verb,peek,!value (\verb,Splaymap,)}
val remove    : ('_key, '_a) dict * '_key \verb"-"\verb">" ('_key, '_a) dict * '_a\index{remove@\verb,remove,!value (\verb,Splaymap,)}
val numItems  : ('key, 'a) dict \verb"-"\verb">" int\index{numItems@\verb,numItems,!value (\verb,Splaymap,)}
val listItems : ('key, 'a) dict \verb"-"\verb">" ('key * 'a) list\index{listItems@\verb,listItems,!value (\verb,Splaymap,)}
val app       : ('key * 'a \verb"-"\verb">" unit) \verb"-"\verb">" ('key,'a) dict \verb"-"\verb">" unit\index{app@\verb,app,!value (\verb,Splaymap,)}
val revapp    : ('key * 'a \verb"-"\verb">" 'b) \verb"-"\verb">" ('key,'a) dict \verb"-"\verb">" unit\index{revapp@\verb,revapp,!value (\verb,Splaymap,)}
val foldr     : ('key * 'a * 'b \verb"-"\verb">" 'b)\verb"-"\verb">" 'b \verb"-"\verb">" ('key,'a) dict \verb"-"\verb">" 'b\index{foldr@\verb,foldr,!value (\verb,Splaymap,)}
val foldl     : ('key * 'a * 'b \verb"-"\verb">" 'b) \verb"-"\verb">" 'b \verb"-"\verb">" ('key,'a) dict \verb"-"\verb">" 'b\index{foldl@\verb,foldl,!value (\verb,Splaymap,)}
val map       : ('_key * 'a \verb"-"\verb">" '_b) \verb"-"\verb">" ('_key,'a) dict \verb"-"\verb">" ('_key, '_b) dict\index{map@\verb,map,!value (\verb,Splaymap,)}
val transform : ('a \verb"-"\verb">" '_b) \verb"-"\verb">" ('_key,'a) dict \verb"-"\verb">" ('_key, '_b) dict\index{transform@\verb,transform,!value (\verb,Splaymap,)}

\separatingline
   [('key, 'a) dict] is the type of applicative maps from domain type\index{dict@\verb,dict,!type (\verb,Splaymap,)}
   'key to range type 'a, or equivalently, applicative dictionaries
   with keys of type 'key and values of type 'a.  They are implemented
   as ordered splay\verb"-"trees (Sleator and Tarjan).

   [mkDict ordr] returns a new, empty map whose keys have ordering\index{mkDict@\verb,mkDict,!value (\verb,Splaymap,)}
   ordr.

   [insert(m, i, v)] extends (or modifies) map m to map i to v.\index{insert@\verb,insert,!value (\verb,Splaymap,)}

   [find (m, k)] returns v if m maps k to v; otherwise raises NotFound.\index{find@\verb,find,!value (\verb,Splaymap,)}
   
   [peek(m, k)] returns SOME v if m maps k to v; otherwise returns NONE.\index{peek@\verb,peek,!value (\verb,Splaymap,)}

   [remove(m, k)] removes k from the domain of m and returns the\index{remove@\verb,remove,!value (\verb,Splaymap,)}
   modified map and the element v corresponding to k.  Raises NotFound
   if k is not in the domain of m.

   [numItems m] returns the number of entries in m (that is, the size\index{numItems@\verb,numItems,!value (\verb,Splaymap,)}
   of the domain of m).

   [listItems m] returns a list of the entries (k, v) of keys k and\index{listItems@\verb,listItems,!value (\verb,Splaymap,)}
   the corresponding values v in m, in increasing order of k.

   [app f m] applies function f to the entries (k, v) in m, in\index{app@\verb,app,!value (\verb,Splaymap,)}
   increasing order of k (according to the ordering ordr used to
   create the map or dictionary).

   [revapp f m] applies function f to the entries (k, v) in m, in\index{revapp@\verb,revapp,!value (\verb,Splaymap,)}
   decreasing order of k.

   [foldl f e m] applies the folding function f to the entries (k, v)\index{foldl@\verb,foldl,!value (\verb,Splaymap,)}
   in m, in increasing order of k.

   [foldr f e m] applies the folding function f to the entries (k, v)\index{foldr@\verb,foldr,!value (\verb,Splaymap,)}
   in m, in decreasing order of k.

   [map f m] returns a new map whose entries have form (k, f(k,v)),\index{map@\verb,map,!value (\verb,Splaymap,)}
   where (k, v) is an entry in m.

   [transform f m] returns a new map whose entries have form (k, f v),\index{transform@\verb,transform,!value (\verb,Splaymap,)}
   where (k, v) is an entry in m.
\end{longprogram}
\index{Splaymap@\verb,Splaymap, (structure)|)}\newpage

\section*{Module Splayset}
\index{Splayset@\verb,Splayset, (structure)|(}
\markboth{\MakeUppercase{Splayset}}{\MakeUppercase{Splayset}}
\addcontentsline{toc}{section}{Splayset}
\begin{longprogram}
{\itshape{}Splayset \verb"-"\verb"-" applicative sets implemented by splay\verb"-"trees       }
{\itshape{}From SML/NJ lib 0.2, copyright 1993 by AT\&T Bell Laboratories }

type 'item set\index{set@\verb,set,!type (\verb,Splayset,)}

exception NotFound\index{NotFound@\verb,NotFound,!exception (\verb,Splayset,)}

val empty        : ('_item * '_item \verb"-"\verb">" order) \verb"-"\verb">" '_item set\index{empty@\verb,empty,!value (\verb,Splayset,)}
val singleton    : ('_item * '_item \verb"-"\verb">" order) \verb"-"\verb">" '_item \verb"-"\verb">" '_item set\index{singleton@\verb,singleton,!value (\verb,Splayset,)}
val add          : '_item set * '_item \verb"-"\verb">" '_item set\index{add@\verb,add,!value (\verb,Splayset,)}
val addList      : '_item set * '_item list \verb"-"\verb">" '_item set\index{addList@\verb,addList,!value (\verb,Splayset,)}
val retrieve     : 'item set * 'item \verb"-"\verb">" 'item\index{retrieve@\verb,retrieve,!value (\verb,Splayset,)}
val peek         : 'item set * 'item \verb"-"\verb">" 'item option\index{peek@\verb,peek,!value (\verb,Splayset,)}
val isEmpty      : 'item set \verb"-"\verb">" bool\index{isEmpty@\verb,isEmpty,!value (\verb,Splayset,)}
val equal        : 'item set * 'item set \verb"-"\verb">" bool\index{equal@\verb,equal,!value (\verb,Splayset,)}
val isSubset     : 'item set * 'item set \verb"-"\verb">" bool\index{isSubset@\verb,isSubset,!value (\verb,Splayset,)}
val member       : 'item set * 'item \verb"-"\verb">" bool\index{member@\verb,member,!value (\verb,Splayset,)}
val delete       : '_item set * '_item \verb"-"\verb">" '_item set\index{delete@\verb,delete,!value (\verb,Splayset,)}
val numItems     : 'item set \verb"-"\verb">"  int\index{numItems@\verb,numItems,!value (\verb,Splayset,)}
val union        : '_item set * '_item set \verb"-"\verb">" '_item set\index{union@\verb,union,!value (\verb,Splayset,)}
val intersection : '_item set * '_item set \verb"-"\verb">" '_item set\index{intersection@\verb,intersection,!value (\verb,Splayset,)}
val difference   : '_item set * '_item set \verb"-"\verb">" '_item set\index{difference@\verb,difference,!value (\verb,Splayset,)}
val listItems    : 'item set \verb"-"\verb">" 'item list\index{listItems@\verb,listItems,!value (\verb,Splayset,)}
val app          : ('item \verb"-"\verb">" unit) \verb"-"\verb">" 'item set \verb"-"\verb">" unit\index{app@\verb,app,!value (\verb,Splayset,)}
val revapp       : ('item \verb"-"\verb">" unit) \verb"-"\verb">" 'item set \verb"-"\verb">" unit\index{revapp@\verb,revapp,!value (\verb,Splayset,)}
val foldr        : ('item * 'b \verb"-"\verb">" 'b) \verb"-"\verb">" 'b \verb"-"\verb">" 'item set \verb"-"\verb">" 'b\index{foldr@\verb,foldr,!value (\verb,Splayset,)}
val foldl        : ('item * 'b \verb"-"\verb">" 'b) \verb"-"\verb">" 'b \verb"-"\verb">" 'item set \verb"-"\verb">" 'b\index{foldl@\verb,foldl,!value (\verb,Splayset,)}
val find         : ('item \verb"-"\verb">" bool) \verb"-"\verb">" 'item set \verb"-"\verb">" 'item option\index{find@\verb,find,!value (\verb,Splayset,)}

\separatingline
   ['item set] is the type of sets of ordered elements of type 'item.\index{set@\verb,set,!type (\verb,Splayset,)}
   The ordering relation on the elements is used in the representation
   of the set.  The result of combining two sets with different
   underlying ordering relations is undefined.  The implementation
   uses splay\verb"-"trees (Sleator and Tarjan).

   [empty ordr] creates a new empty set with the given ordering\index{empty@\verb,empty,!value (\verb,Splayset,)}
   relation.  

   [singleton ordr i] creates the singleton set containing i, with the\index{singleton@\verb,singleton,!value (\verb,Splayset,)}
   given ordering relation.

   [add(s, i)] adds item i to set s.  \index{add@\verb,add,!value (\verb,Splayset,)}

   [addList(s, xs)] adds all items from the list xs to the set s.\index{addList@\verb,addList,!value (\verb,Splayset,)}

   [retrieve(s, i)] returns i if it is in s; raises NotFound otherwise.\index{retrieve@\verb,retrieve,!value (\verb,Splayset,)}

   [peek(s, i)] returns SOME i if i is in s; returns NONE otherwise.\index{peek@\verb,peek,!value (\verb,Splayset,)}

   [isEmpty s] returns true if and only if the set is empty.\index{isEmpty@\verb,isEmpty,!value (\verb,Splayset,)}

   [equal(s1, s2)] returns true if and only if the two sets have the\index{equal@\verb,equal,!value (\verb,Splayset,)}
   same elements.

   [isSubset(s1, s2)] returns true if and only if s1 is a subset of s2.\index{isSubset@\verb,isSubset,!value (\verb,Splayset,)}

   [member(s, i)] returns true if and only if i is in s.\index{member@\verb,member,!value (\verb,Splayset,)}

   [delete(s, i)] removes item i from s.  Raises NotFound if i is not in s.\index{delete@\verb,delete,!value (\verb,Splayset,)}
   
   [numItems s] returns the number of items in set s.\index{numItems@\verb,numItems,!value (\verb,Splayset,)}

   [union(s1, s2)] returns the union of s1 and s2.  \index{union@\verb,union,!value (\verb,Splayset,)}

   [intersection(s1, s2)] returns the intersectionof s1 and s2.\index{intersection@\verb,intersection,!value (\verb,Splayset,)}

   [difference(s1, s2)] returns the difference between s1 and s2 (that\index{difference@\verb,difference,!value (\verb,Splayset,)}
   is, the set of elements in s1 but not in s2).

   [listItems s] returns a list of the items in set s, in increasing\index{listItems@\verb,listItems,!value (\verb,Splayset,)}
    order.

   [app f s] applies function f to the elements of s, in increasing\index{app@\verb,app,!value (\verb,Splayset,)}
   order.

   [revapp f s] applies function f to the elements of s, in decreasing\index{revapp@\verb,revapp,!value (\verb,Splayset,)}
   order. 

   [foldl f e s] applies the folding function f to the entries of the\index{foldl@\verb,foldl,!value (\verb,Splayset,)}
   set in increasing order.

   [foldr f e s] applies the folding function f to the entries of the\index{foldr@\verb,foldr,!value (\verb,Splayset,)}
   set in decreasing order. 

   [find p s] returns SOME i, where i is an item in s which satisfies\index{find@\verb,find,!value (\verb,Splayset,)}
   p, if one exists; otherwise returns NONE.
\end{longprogram}
\index{Splayset@\verb,Splayset, (structure)|)}\newpage

\section*{Module String}
\index{String@\verb,String, (structure)|(}
\markboth{\MakeUppercase{String}}{\MakeUppercase{String}}
\addcontentsline{toc}{section}{String}
\begin{longprogram}
{\itshape{}String \verb"-"\verb"-" SML Basis Library }

local 
    type char = Char.char
in
    type string = string\index{string@\verb,string,!type (\verb,String,)}
    val maxSize   : int\index{maxSize@\verb,maxSize,!value (\verb,String,)}
    val size      : string \verb"-"\verb">" int\index{size@\verb,size,!value (\verb,String,)}
    val sub       : string * int \verb"-"\verb">" char\index{sub@\verb,sub,!value (\verb,String,)}
    val substring : string * int * int \verb"-"\verb">" string\index{substring@\verb,substring,!value (\verb,String,)}
    val extract   : string * int * int option \verb"-"\verb">" string\index{extract@\verb,extract,!value (\verb,String,)}
    val concat    : string list \verb"-"\verb">" string\index{concat@\verb,concat,!value (\verb,String,)}
    val ^         : string * string \verb"-"\verb">" string\index{^@\verb,^,!value (\verb,String,)}
    val str       : char \verb"-"\verb">" string\index{str@\verb,str,!value (\verb,String,)}
    val implode   : char list \verb"-"\verb">" string \index{implode@\verb,implode,!value (\verb,String,)}
    val explode   : string \verb"-"\verb">" char list\index{explode@\verb,explode,!value (\verb,String,)}

    val map       : (char \verb"-"\verb">" char) \verb"-"\verb">" string \verb"-"\verb">" string \index{map@\verb,map,!value (\verb,String,)}
    val translate : (char \verb"-"\verb">" string) \verb"-"\verb">" string \verb"-"\verb">" string\index{translate@\verb,translate,!value (\verb,String,)}
    val tokens    : (char \verb"-"\verb">" bool) \verb"-"\verb">" string \verb"-"\verb">" string list\index{tokens@\verb,tokens,!value (\verb,String,)}
    val fields    : (char \verb"-"\verb">" bool) \verb"-"\verb">" string \verb"-"\verb">" string list\index{fields@\verb,fields,!value (\verb,String,)}
    val isPrefix  : string \verb"-"\verb">" string \verb"-"\verb">" bool\index{isPrefix@\verb,isPrefix,!value (\verb,String,)}

    val compare   : string * string \verb"-"\verb">" order\index{compare@\verb,compare,!value (\verb,String,)}
    val collate   : (char * char \verb"-"\verb">" order) \verb"-"\verb">" string * string \verb"-"\verb">" order\index{collate@\verb,collate,!value (\verb,String,)}

    val fromString  : string \verb"-"\verb">" string option     {\itshape{}ML escape sequences }\index{fromString@\verb,fromString,!value (\verb,String,)}
    val toString    : string \verb"-"\verb">" string            {\itshape{}ML escape sequences }\index{toString@\verb,toString,!value (\verb,String,)}
    val fromCString : string \verb"-"\verb">" string option     {\itshape{}C escape sequences }\index{fromCString@\verb,fromCString,!value (\verb,String,)}
    val toCString   : string \verb"-"\verb">" string            {\itshape{}C escape sequences }\index{toCString@\verb,toCString,!value (\verb,String,)}

    val \verb"<"  : string * string \verb"-"\verb">" bool\index{<@\verb,<,!value (\verb,String,)}
    val \verb"<"= : string * string \verb"-"\verb">" bool\index{<=@\verb,<=,!value (\verb,String,)}
    val \verb">"  : string * string \verb"-"\verb">" bool\index{>@\verb,>,!value (\verb,String,)}
    val \verb">"= : string * string \verb"-"\verb">" bool\index{>=@\verb,>=,!value (\verb,String,)}
end

\separatingline
   [string] is the type of immutable strings of characters, with\index{string@\verb,string,!type (\verb,String,)}
   constant\verb"-"time indexing.

   [maxSize] is the maximal number of characters in a string.\index{maxSize@\verb,maxSize,!value (\verb,String,)}

   [size s] is the number of characters in string s.\index{size@\verb,size,!value (\verb,String,)}

   [sub(s, i)] is the i'th character of s, counting from zero.  \index{sub@\verb,sub,!value (\verb,String,)}
   Raises Subscript if i\verb"<"0 or i\verb">"=size s.

   [substring(s, i, n)] is the string s[i..i+n\verb"-"1].  Raises Subscript\index{substring@\verb,substring,!value (\verb,String,)}
   if i\verb"<"0 or n\verb"<"0 or i+n\verb">"size s.  Equivalent to extract(s, i, SOME n).

   [extract (s, i, NONE)] is the string s[i..size s\verb"-"1].\index{extract@\verb,extract,!value (\verb,String,)}
   Raises Subscript if i\verb"<"0 or i\verb">"size s. 

   [extract (s, i, SOME n)] is the string s[i..i+n\verb"-"1].\index{extract@\verb,extract,!value (\verb,String,)}
   Raises Subscript if i\verb"<"0 or n\verb"<"0 or i+n\verb">"size s. 

   [concat ss] is the concatenation of all the strings in ss.\index{concat@\verb,concat,!value (\verb,String,)}
   Raises Size if the sum of their sizes is greater than maxSize.

   [s1 ^ s2] is the concatenation of strings s1 and s2.

   [str c] is the string of size one which contains the character c.\index{str@\verb,str,!value (\verb,String,)}

   [implode cs] is the string containing the characters in the list cs.\index{implode@\verb,implode,!value (\verb,String,)}
   Equivalent to  concat (List.map str cs).

   [explode s] is the list of characters in the string s.\index{explode@\verb,explode,!value (\verb,String,)}

   [map f s] applies f to every character of s, from left to right,\index{map@\verb,map,!value (\verb,String,)}
   and returns the string consisting of the resulting characters.
   Equivalent to  CharVector.map f s   
          and to  implode (List.map f (explode s)).

   [translate f s] applies f to every character of s, from left to\index{translate@\verb,translate,!value (\verb,String,)}
   right, and returns the concatenation of the resulting strings.
   Raises Size if the sum of their sizes is greater than maxSize.
   Equivalent to concat (List.map f (explode s)).

   [tokens p s] returns the list of tokens in s, from left to right, \index{tokens@\verb,tokens,!value (\verb,String,)}
   where a token is a non\verb"-"empty maximal substring of s not containing 
   any delimiter, and a delimiter is a character satisfying p.

   [fields p s] returns the list of fields in s, from left to right, \index{fields@\verb,fields,!value (\verb,String,)}
   where a field is a (possibly empty) maximal substring of s not 
   containing any delimiter, and a delimiter is a character satisfying p.

   Two tokens may be separated by more than one delimiter, whereas two
   fields are separated by exactly one delimiter.  If the only delimiter 
   is the character #"|", then
        "abc||def" contains two tokens:   "abc" and "def"
        "abc||def" contains three fields: "abc" and "" and "def"

   [isPrefix s1 s2] is true if s1 is a prefix of s2.  \index{isPrefix@\verb,isPrefix,!value (\verb,String,)}
   That is, if there exists a string t such that s1 ^ t = s2.

   [fromString s] scans the string s as an ML source program string,\index{fromString@\verb,fromString,!value (\verb,String,)}
   converting escape sequences into the appropriate characters.  Does
   not skip leading whitespace.

   [toString s] returns a string corresponding to s, with\index{toString@\verb,toString,!value (\verb,String,)}
   non\verb"-"printable characters replaced by ML escape sequences.
   Equivalent to String.translate Char.toString.

   [fromCString s] scans the string s as a C source program string,\index{fromCString@\verb,fromCString,!value (\verb,String,)}
   converting escape sequences into the appropriate characters.  Does
   not skip leading whitespace.

   [toCString s] returns a string corresponding to s, with\index{toCString@\verb,toCString,!value (\verb,String,)}
   non\verb"-"printable characters replaced by C escape sequences.
   Equivalent to String.translate Char.toCString.

   [compare (s1, s2)] does lexicographic comparison, using the\index{compare@\verb,compare,!value (\verb,String,)}
   standard ordering Char.compare on the characters.  Returns LESS,
   EQUAL, or GREATER, according as s1 is less than, equal to, or
   greater than s2.

   [collate cmp (s1, s2)] performs lexicographic comparison, using the \index{collate@\verb,collate,!value (\verb,String,)}
   given ordering cmp on characters.  

   [\verb"<"]\index{<@\verb,<,!value (\verb,String,)}
   [\verb"<"=]\index{<=@\verb,<=,!value (\verb,String,)}
   [\verb">"]\index{>@\verb,>,!value (\verb,String,)}
   [\verb">"=] compare strings lexicographically, using the representation \index{>=@\verb,>=,!value (\verb,String,)}
   ordering on characters.
\end{longprogram}
\index{String@\verb,String, (structure)|)}\newpage

\section*{Module StringCvt}
\index{StringCvt@\verb,StringCvt, (structure)|(}
\markboth{\MakeUppercase{StringCvt}}{\MakeUppercase{StringCvt}}
\addcontentsline{toc}{section}{StringCvt}
\begin{longprogram}
{\itshape{}StringCvt \verb"-"\verb"-" SML Basis Library }

datatype radix = BIN | OCT | DEC | HEX\index{radix@\verb,radix,!type (\verb,StringCvt,)}

datatype realfmt = \index{realfmt@\verb,realfmt,!type (\verb,StringCvt,)}
    SCI of int option   {\itshape{}scientific,  arg = # dec. digits, dflt=6 }
  | FIX of int option   {\itshape{}fixed\verb"-"point, arg = # dec. digits, dflt=6 }
  | GEN of int option   {\itshape{}auto choice of the above,                }
                        {\itshape{}arg = # significant digits, dflt=12      }

type cs                 {\itshape{}character source state }\index{cs@\verb,cs,!type (\verb,StringCvt,)}

type ('a, 'b) reader = 'b \verb"-"\verb">" ('a * 'b) option\index{reader@\verb,reader,!type (\verb,StringCvt,)}

val scanString : ((char, cs) reader \verb"-"\verb">" ('a, cs) reader) \verb"-"\verb">" string \verb"-"\verb">" 'a option\index{scanString@\verb,scanString,!value (\verb,StringCvt,)}

val splitl     : (char \verb"-"\verb">" bool) \verb"-"\verb">" (char, 'a) reader \verb"-"\verb">" 'a \verb"-"\verb">" string * 'a\index{splitl@\verb,splitl,!value (\verb,StringCvt,)}
val takel      : (char \verb"-"\verb">" bool) \verb"-"\verb">" (char, 'a) reader \verb"-"\verb">" 'a \verb"-"\verb">" string \index{takel@\verb,takel,!value (\verb,StringCvt,)}
val dropl      : (char \verb"-"\verb">" bool) \verb"-"\verb">" (char, 'a) reader \verb"-"\verb">" 'a \verb"-"\verb">" 'a \index{dropl@\verb,dropl,!value (\verb,StringCvt,)}
val skipWS     : (char, 'a) reader \verb"-"\verb">" 'a \verb"-"\verb">" 'a \index{skipWS@\verb,skipWS,!value (\verb,StringCvt,)}

val padLeft    : char \verb"-"\verb">" int \verb"-"\verb">" string \verb"-"\verb">" string\index{padLeft@\verb,padLeft,!value (\verb,StringCvt,)}
val padRight   : char \verb"-"\verb">" int \verb"-"\verb">" string \verb"-"\verb">" string\index{padRight@\verb,padRight,!value (\verb,StringCvt,)}

\separatingline
   This structure presents tools for scanning strings and values from
   functional character streams, and for simple formatting.

   [('elm, 'src) reader] is the type of source readers for reading a\index{reader@\verb,reader,!type (\verb,StringCvt,)}
   sequence of 'elm values from a source of type 'src.  For instance, 
   a character source reader
        getc : (char, cs) reader 
   is used for obtaining characters from a functional character source
   src of type cs, one at a time. It should hold that

        getc src = SOME(c, src')        if the next character in src 
                                        is c, and src' is the rest of src;
                 = NONE                 if src contains no characters

   A character source scanner takes a character source reader getc as
   argument and uses it to scan a data value from the character
   source.

   [scanString scan s] turns the string s into a character source and\index{scanString@\verb,scanString,!value (\verb,StringCvt,)}
   applies the scanner `scan' to that source.

   [splitl p getc src] returns (pref, suff) where pref is the\index{splitl@\verb,splitl,!value (\verb,StringCvt,)}
   longest prefix (left substring) of src all of whose characters
   satisfy p, and suff is the remainder of src.  That is, the first
   character retrievable from suff, if any, is the leftmost character
   not satisfying p.  Does not skip leading whitespace.

   [takel p getc src] returns the longest prefix (left substring) of\index{takel@\verb,takel,!value (\verb,StringCvt,)}
   src all of whose characters satisfy predicate p.  That is, if the
   left\verb"-"most character does not satisfy p, the result is the empty
   string.  Does not skip leading whitespace.  It holds that
        takel p getc src = #1 (splitl p getc src)

   [dropl p getc src] drops the longest prefix (left substring) of\index{dropl@\verb,dropl,!value (\verb,StringCvt,)}
   src all of whose characters satisfy predicate p.  If all characters
   do, it returns the empty source.  It holds that
        dropl p getc src = #2 (splitl p getc src)

   [skipWS getc src] drops any leading whitespace from src.\index{skipWS@\verb,skipWS,!value (\verb,StringCvt,)}
   Equivalent to dropl Char.isSpace.

   [padLeft c n s] returns the string s if size s \verb">"= n, otherwise pads\index{padLeft@\verb,padLeft,!value (\verb,StringCvt,)}
   s with (n \verb"-" size s) copies of the character c on the left.  
   In other words, right\verb"-"justifies s in a field n characters wide.

   [padRight c n s] returns the string s if size s \verb">"= n, otherwise pads\index{padRight@\verb,padRight,!value (\verb,StringCvt,)}
   s with (n \verb"-" size s) copies of the character c on the right.
   In other words, left\verb"-"justifies s in a field n characters wide.
\end{longprogram}
\index{StringCvt@\verb,StringCvt, (structure)|)}\newpage

\section*{Module Substring}
\index{Substring@\verb,Substring, (structure)|(}
\markboth{\MakeUppercase{Substring}}{\MakeUppercase{Substring}}
\addcontentsline{toc}{section}{Substring}
\begin{longprogram}
{\itshape{}Substring \verb"-"\verb"-" SML Basis Library }

type substring\index{substring@\verb,substring,!type (\verb,Substring,)}

val substring : string * int * int \verb"-"\verb">" substring\index{substring@\verb,substring,!value (\verb,Substring,)}
val extract   : string * int * int option \verb"-"\verb">" substring\index{extract@\verb,extract,!value (\verb,Substring,)}
val all       : string \verb"-"\verb">" substring\index{all@\verb,all,!value (\verb,Substring,)}
val string    : substring \verb"-"\verb">" string\index{string@\verb,string,!value (\verb,Substring,)}
val base      : substring \verb"-"\verb">" (string * int * int)\index{base@\verb,base,!value (\verb,Substring,)}

val isEmpty   : substring \verb"-"\verb">" bool\index{isEmpty@\verb,isEmpty,!value (\verb,Substring,)}
val getc      : substring \verb"-"\verb">" (char * substring) option\index{getc@\verb,getc,!value (\verb,Substring,)}
val first     : substring \verb"-"\verb">" char option\index{first@\verb,first,!value (\verb,Substring,)}
val triml     : int \verb"-"\verb">" substring \verb"-"\verb">" substring\index{triml@\verb,triml,!value (\verb,Substring,)}
val trimr     : int \verb"-"\verb">" substring \verb"-"\verb">" substring\index{trimr@\verb,trimr,!value (\verb,Substring,)}
val sub       : substring * int \verb"-"\verb">" char\index{sub@\verb,sub,!value (\verb,Substring,)}
val size      : substring \verb"-"\verb">" int\index{size@\verb,size,!value (\verb,Substring,)}
val slice     : substring * int * int option \verb"-"\verb">" substring\index{slice@\verb,slice,!value (\verb,Substring,)}
val concat    : substring list \verb"-"\verb">" string\index{concat@\verb,concat,!value (\verb,Substring,)}
val explode   : substring \verb"-"\verb">" char list\index{explode@\verb,explode,!value (\verb,Substring,)}
val isPrefix  : string \verb"-"\verb">" substring \verb"-"\verb">" bool\index{isPrefix@\verb,isPrefix,!value (\verb,Substring,)}
val compare   : substring * substring \verb"-"\verb">" order\index{compare@\verb,compare,!value (\verb,Substring,)}
val collate   : (char * char \verb"-"\verb">" order) \verb"-"\verb">" substring * substring \verb"-"\verb">" order\index{collate@\verb,collate,!value (\verb,Substring,)}

val dropl     : (char \verb"-"\verb">" bool) \verb"-"\verb">" substring \verb"-"\verb">" substring\index{dropl@\verb,dropl,!value (\verb,Substring,)}
val dropr     : (char \verb"-"\verb">" bool) \verb"-"\verb">" substring \verb"-"\verb">" substring\index{dropr@\verb,dropr,!value (\verb,Substring,)}
val takel     : (char \verb"-"\verb">" bool) \verb"-"\verb">" substring \verb"-"\verb">" substring\index{takel@\verb,takel,!value (\verb,Substring,)}
val taker     : (char \verb"-"\verb">" bool) \verb"-"\verb">" substring \verb"-"\verb">" substring\index{taker@\verb,taker,!value (\verb,Substring,)}
val splitl    : (char \verb"-"\verb">" bool) \verb"-"\verb">" substring \verb"-"\verb">" substring * substring\index{splitl@\verb,splitl,!value (\verb,Substring,)}
val splitr    : (char \verb"-"\verb">" bool) \verb"-"\verb">" substring \verb"-"\verb">" substring * substring\index{splitr@\verb,splitr,!value (\verb,Substring,)}
val splitAt   : substring * int \verb"-"\verb">" substring * substring\index{splitAt@\verb,splitAt,!value (\verb,Substring,)}

val position  : string \verb"-"\verb">" substring \verb"-"\verb">" substring * substring\index{position@\verb,position,!value (\verb,Substring,)}

exception Span\index{Span@\verb,Span,!exception (\verb,Substring,)}
val span      : substring * substring \verb"-"\verb">" substring\index{span@\verb,span,!value (\verb,Substring,)}

val translate : (char \verb"-"\verb">" string) \verb"-"\verb">" substring \verb"-"\verb">" string\index{translate@\verb,translate,!value (\verb,Substring,)}

val tokens    : (char \verb"-"\verb">" bool) \verb"-"\verb">" substring \verb"-"\verb">" substring list\index{tokens@\verb,tokens,!value (\verb,Substring,)}
val fields    : (char \verb"-"\verb">" bool) \verb"-"\verb">" substring \verb"-"\verb">" substring list\index{fields@\verb,fields,!value (\verb,Substring,)}

val foldl     : (char * 'a \verb"-"\verb">" 'a) \verb"-"\verb">" 'a \verb"-"\verb">" substring \verb"-"\verb">" 'a\index{foldl@\verb,foldl,!value (\verb,Substring,)}
val foldr     : (char * 'a \verb"-"\verb">" 'a) \verb"-"\verb">" 'a \verb"-"\verb">" substring \verb"-"\verb">" 'a\index{foldr@\verb,foldr,!value (\verb,Substring,)}
val app       : (char \verb"-"\verb">" unit) \verb"-"\verb">" substring \verb"-"\verb">" unit\index{app@\verb,app,!value (\verb,Substring,)}

\separatingline
   [substring] is the type of substrings of a basestring, an efficient \index{substring@\verb,substring,!type (\verb,Substring,)}
   representation of a piece of a string.
   A substring (s,i,n) is valid if 0 \verb"<"= i \verb"<"= i+n \verb"<"= size s, 
                  or equivalently, 0 \verb"<"= i and 0 \verb"<"= n and i+n \verb"<"= size s.  
   A valid substring (s, i, n) represents the string s[i...i+n\verb"-"1].  
   Invariant in the implementation: Any value of type substring is valid.

   [substring(s, i, n)] creates the substring (s, i, n), consisting of\index{substring@\verb,substring,!value (\verb,Substring,)}
   the substring of s with length n starting at i.  Raises Subscript
   if i\verb"<"0 or n\verb"<"0 or i+n \verb">" size s.  Equivalent to extract(s, i, SOME n).

   [extract(s, i, NONE)] creates the substring (s, i, size s\verb"-"i)\index{extract@\verb,extract,!value (\verb,Substring,)}
   consisting of the tail of s starting at i.  
   Raises Subscript if i\verb"<"0 or i \verb">" size s.

   [extract(s, i, SOME n)] creates the substring (s, i, n),\index{extract@\verb,extract,!value (\verb,Substring,)}
   consisting of the substring of s with length n starting at i.
   Raises Subscript if i\verb"<"0 or n\verb"<"0 or i+n \verb">" size s.

   [all s] is the substring (s, 0, size s).\index{all@\verb,all,!value (\verb,Substring,)}

   [string sus] is the string s[i..i+n\verb"-"1] represented by sus = (s, i, n).\index{string@\verb,string,!value (\verb,Substring,)}

   [base sus] is the concrete triple (s, i, n), where sus = (s, i, n).\index{base@\verb,base,!value (\verb,Substring,)}

   [isEmpty (s, i, n)] true if the substring is empty (that is, n = 0).\index{isEmpty@\verb,isEmpty,!value (\verb,Substring,)}

   [getc sus] returns SOME(c, rst) where c is the first character and\index{getc@\verb,getc,!value (\verb,Substring,)}
   rst the remainder of sus, if sus is non\verb"-"empty; otherwise returns
   NONE.  Note that 
        #1 o valOf o scanFn Substring.getc
   is equivalent to, but more efficient than, 
        valOf o StringCvt.scanString scanFn o Substring.string

   [first sus] returns SOME c where c is the first character in sus,\index{first@\verb,first,!value (\verb,Substring,)}
   if sus is non\verb"-"empty; otherwise returns NONE.

   [triml k sus] returns sus less its leftmost k characters; or the\index{triml@\verb,triml,!value (\verb,Substring,)}
   empty string at the end of sus if it has less than k characters.
   Raises Subscript if k \verb"<" 0, even in the partial application triml(k). 

   [trimr k sus] returns sus less its rightmost k characters; or the\index{trimr@\verb,trimr,!value (\verb,Substring,)}
   empty string at the beginning of sus if it has less than k characters.  
   Raises Subscript if k \verb"<" 0, even in the partial application triml(k).

   [sub (sus, k)] returns the k'th character of the substring; that is,\index{sub@\verb,sub,!value (\verb,Substring,)}
   s(i+k) where sus = (s, i, n).  Raises Subscript if k\verb"<"0 or k\verb">"=n.

   [size (s, i, n)] returns the size of the substring, that is, n.\index{size@\verb,size,!value (\verb,Substring,)}

   [slice (sus, i', NONE)] returns the substring (s, i+i', n\verb"-"i'), where\index{slice@\verb,slice,!value (\verb,Substring,)}
   sus = (s, i, n).  Raises Subscript if i' \verb"<" 0 or i' \verb">" n.

   [slice (sus, i', SOME n')] returns the substring (s, i+i', n'), where\index{slice@\verb,slice,!value (\verb,Substring,)}
   sus = (s, i, n).  Raises Subscript if i' \verb"<" 0 or n' \verb"<" 0 or i'+n' \verb">"= n.

   [concat suss] returns a string consisting of the concatenation of\index{concat@\verb,concat,!value (\verb,Substring,)}
   the substrings.  Equivalent to String.concat (List.map string suss).

   [explode sus] returns the list of characters of sus, that is,\index{explode@\verb,explode,!value (\verb,Substring,)}
        [s(i), s(i+1), ..., s(i+n\verb"-"1)]
   where sus = (s, i, n).  Equivalent to String.explode(string ss).

   [isPrefix s1 s2] is true if s1 is a prefix of s2. That is, if there \index{isPrefix@\verb,isPrefix,!value (\verb,Substring,)}
   exists a string t such that string s1 ^ t = string s2.

   [compare (sus1, sus2)] performs lexicographic comparison, using the\index{compare@\verb,compare,!value (\verb,Substring,)}
   standard ordering Char.compare on the characters.  Returns LESS,
   EQUAL, or GREATER, according as sus1 is less than, equal to, or
   greater than sus2.  Equivalent to, but more efficient than,
       String.compare(string sus1, string sus2).

   [collate cmp (sus1, sus2)] performs lexicographic comparison, using the \index{collate@\verb,collate,!value (\verb,Substring,)}
   given ordering cmp on characters.  Equivalent to, but more efficient 
   than, String.collate cmp (string sus1, string sus2).

   [dropl p sus] drops the longest prefix (left substring) of sus all\index{dropl@\verb,dropl,!value (\verb,Substring,)}
   of whose characters satisfy predicate p.  If all characters do, it
   returns the empty substring (s, i+n, 0) where sus = (s, i, n).

   [dropr p sus] drops the longest suffix (right substring) of sus all\index{dropr@\verb,dropr,!value (\verb,Substring,)}
   of whose characters satisfy predicate p.  If all characters do, it
   returns the empty substring (s, i, 0) where sus = (s, i, n).

   [takel p sus] returns the longest prefix (left substring) of sus\index{takel@\verb,takel,!value (\verb,Substring,)}
   all of whose characters satisfy predicate p.  That is, if the
   left\verb"-"most character does not satisfy p, returns the empty (s, i, 0)
   where sus = (s, i, n).

   [taker p sus] returns the longest suffix (right substring) of sus\index{taker@\verb,taker,!value (\verb,Substring,)}
   all of whose characters satisfy predicate p.  That is, if the
   right\verb"-"most character satisfies p, returns the empty (s, i+n, 0)
   where sus = (s, i, n).

   Let p be a predicate and xxxxfyyyyfzzzz a string where all
   characters in xxxx and zzzz satisfy p, and f a is character
   not satisfying p.  Then

                sus = xxxxfyyyyfzzzz         sus = xxxxzzzz
        \verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"
        dropl p sus =     fyyyyfzzzz               
        dropr p sus = xxxxfyyyyf       
        takel p sus = xxxx                         xxxxzzzz
        taker p sus =           zzzz               xxxxzzzz

   It also holds that 
        concat[takel p sus, dropl p sus] = string sus
        concat[dropr p sus, taker p sus] = string sus 

   [splitl p sus] splits sus into a pair (sus1, sus2) of substrings\index{splitl@\verb,splitl,!value (\verb,Substring,)}
   where sus1 is the longest prefix (left substring) all of whose
   characters satisfy p, and sus2 is the rest.  That is, sus2 begins
   with the leftmost character not satisfying p.  Disregarding
   sideeffects, we have: 
        splitl p sus = (takel p sus, dropl p sus).

   [splitr p sus] splits sus into a pair (sus1, sus2) of substrings\index{splitr@\verb,splitr,!value (\verb,Substring,)}
   where sus2 is the longest suffix (right substring) all of whose
   characters satisfy p, and sus1 is the rest.  That is, sus1 ends
   with the rightmost character not satisfying p.  Disregarding
   sideeffects, we have:
        splitr p sus = (dropr p sus, taker p sus)

   [splitAt (sus, k)] returns the pair (sus1, sus2) of substrings,\index{splitAt@\verb,splitAt,!value (\verb,Substring,)}
   where sus1 contains the first k characters of sus, and sus2
   contains the rest.  Raises Subscript if k \verb"<" 0 or k \verb">" size sus.

   [position s (s',i,n)] splits the substring into a pair (pref, suff)\index{position@\verb,position,!value (\verb,Substring,)}
   of substrings, where suff is the longest suffix of (s', i, n) which
   has s as a prefix.  More precisely, let m = size s.  If there is a
   least index k in i..i+n\verb"-"m for which s = s'[k..k+m\verb"-"1], 
   then the result is       pref = (s', i, k\verb"-"i) and suff = (s', k, n\verb"-"(k\verb"-"i)); 
   otherwise the result is  pref = (s', i, n)   and suff = (s', i+n, 0).

   [span (sus1, sus2)] returns a substring spanning from the start of\index{span@\verb,span,!value (\verb,Substring,)}
   sus1 to the end of sus2, provided this is well\verb"-"defined: sus1 and
   sus2 must have the same underlying string, and the start of sus1
   must not be to the right of the end of sus2; otherwise raises Span.

   More precisely, if base(sus1) = (s,i,n) and base(sus2) = (s',i',n') 
   and s = s' and i \verb"<"= i'+n', then base(join(sus1, sus2)) = (s, i, i'+n'\verb"-"i).
   This may be used to compute `span', `union', and `intersection'.

   [translate f sus] applies f to every character of sus, from left to\index{translate@\verb,translate,!value (\verb,Substring,)}
   right, and returns the concatenation of the results.  Raises Size
   if the sum of their sizes is greater than String.maxSize.
   Equivalent to String.concat(List.map f (explode sus)).

   [tokens p sus] returns the list of tokens in sus, from left to right, \index{tokens@\verb,tokens,!value (\verb,Substring,)}
   where a token is a non\verb"-"empty maximal substring of sus not containing 
   any delimiter, and a delimiter is a character satisfying p.

   [fields p sus] returns the list of fields in sus, from left to right, \index{fields@\verb,fields,!value (\verb,Substring,)}
   where a field is a (possibly empty) maximal substring of sus not 
   containing any delimiter, and a delimiter is a character satisfying p.

   Two tokens may be separated by more than one delimiter, whereas two
   fields are separated by exactly one delimiter.  If the only delimiter 
   is the character #"|", then
        "abc||def" contains two tokens:   "abc" and "def"
        "abc||def" contains three fields: "abc" and "" and "def"

   [foldl f e sus] folds f over sus from left to right.  That is, \index{foldl@\verb,foldl,!value (\verb,Substring,)}
   evaluates f(s[i+n\verb"-"1], f( ... f(s[i+1], f(s[i] \verb"%" e)) ...)) 
   tail\verb"-"recursively, where sus = (s, i, n).  
   Equivalent to List.foldl f e (explode sus).

   [foldr f e sus] folds f over sus from right to left.  That is, \index{foldr@\verb,foldr,!value (\verb,Substring,)}
   evaluates f(s[i], f(s[i+1], f(... f(s[i+n\verb"-"1] \verb"%" e) ...)))
   tail\verb"-"recursively, where sus = (s, i, n).
   Equivalent to List.foldr f e (explode sus).

   [app f sus] applies f to all characters of sus, from left to right.\index{app@\verb,app,!value (\verb,Substring,)}
   Equivalent to List.app f (explode sus).

\end{longprogram}
\index{Substring@\verb,Substring, (structure)|)}\newpage

\section*{Module Susp}
\index{Susp@\verb,Susp, (structure)|(}
\markboth{\MakeUppercase{Susp}}{\MakeUppercase{Susp}}
\addcontentsline{toc}{section}{Susp}
\begin{longprogram}
{\itshape{}Susp \verb"-"\verb"-" support for lazy evaluation }

type 'a susp\index{susp@\verb,susp,!type (\verb,Susp,)}

val delay : (unit \verb"-"\verb">" 'a) \verb"-"\verb">" 'a susp\index{delay@\verb,delay,!value (\verb,Susp,)}
val force : 'a susp \verb"-"\verb">" 'a\index{force@\verb,force,!value (\verb,Susp,)}

\separatingline
   ['a susp] is the type of lazily evaluated expressions with result\index{susp@\verb,susp,!type (\verb,Susp,)}
   type 'a.

   [delay (fn () =\verb">" e)] creates a suspension for the expression e.\index{delay@\verb,delay,!value (\verb,Susp,)}
   The first time the suspension is forced, the expression e will be
   evaluated, and the result stored in the suspension.  All subsequent
   forcing of the suspension will just return this result, so e is
   evaluated at most once.  If the suspension is never forced, then e
   is never evaluated.

   [force su] forces the suspension su and returns the result of the\index{force@\verb,force,!value (\verb,Susp,)}
   expression e stored in the suspension.
\end{longprogram}
\index{Susp@\verb,Susp, (structure)|)}\newpage

\section*{Module TextIO}
\index{TextIO@\verb,TextIO, (structure)|(}
\markboth{\MakeUppercase{TextIO}}{\MakeUppercase{TextIO}}
\addcontentsline{toc}{section}{TextIO}
\begin{longprogram}
{\itshape{}TextIO \verb"-"\verb"-" SML Basis Library }

type elem   = Char.char\index{elem@\verb,elem,!type (\verb,TextIO,)}
type vector = string\index{vector@\verb,vector,!type (\verb,TextIO,)}

{\itshape{}Text input }

type instream \index{instream@\verb,instream,!type (\verb,TextIO,)}

val openIn       : string \verb"-"\verb">" instream\index{openIn@\verb,openIn,!value (\verb,TextIO,)}
val closeIn      : instream \verb"-"\verb">" unit\index{closeIn@\verb,closeIn,!value (\verb,TextIO,)}
val input        : instream \verb"-"\verb">" vector\index{input@\verb,input,!value (\verb,TextIO,)}
val inputAll     : instream \verb"-"\verb">" vector\index{inputAll@\verb,inputAll,!value (\verb,TextIO,)}
val inputNoBlock : instream \verb"-"\verb">" vector option\index{inputNoBlock@\verb,inputNoBlock,!value (\verb,TextIO,)}
val input1       : instream \verb"-"\verb">" elem option\index{input1@\verb,input1,!value (\verb,TextIO,)}
val inputN       : instream * int \verb"-"\verb">" vector\index{inputN@\verb,inputN,!value (\verb,TextIO,)}
val inputLine    : instream \verb"-"\verb">" string\index{inputLine@\verb,inputLine,!value (\verb,TextIO,)}
val endOfStream  : instream \verb"-"\verb">" bool\index{endOfStream@\verb,endOfStream,!value (\verb,TextIO,)}
val lookahead    : instream \verb"-"\verb">" elem option\index{lookahead@\verb,lookahead,!value (\verb,TextIO,)}

type cs {\itshape{}character source state }\index{cs@\verb,cs,!type (\verb,TextIO,)}

val scanStream   : ((char, cs) StringCvt.reader \verb"-"\verb">" ('a, cs) StringCvt.reader) \index{scanStream@\verb,scanStream,!value (\verb,TextIO,)}
                   \verb"-"\verb">" instream \verb"-"\verb">" 'a option

val stdIn        : instream\index{stdIn@\verb,stdIn,!value (\verb,TextIO,)}

{\itshape{}Text output }

type outstream\index{outstream@\verb,outstream,!type (\verb,TextIO,)}

val openOut      : string \verb"-"\verb">" outstream\index{openOut@\verb,openOut,!value (\verb,TextIO,)}
val openAppend   : string \verb"-"\verb">" outstream\index{openAppend@\verb,openAppend,!value (\verb,TextIO,)}
val closeOut     : outstream \verb"-"\verb">" unit\index{closeOut@\verb,closeOut,!value (\verb,TextIO,)}
val output       : outstream * vector \verb"-"\verb">" unit\index{output@\verb,output,!value (\verb,TextIO,)}
val output1      : outstream * elem \verb"-"\verb">" unit\index{output1@\verb,output1,!value (\verb,TextIO,)}
val outputSubstr : outstream * substring \verb"-"\verb">" unit\index{outputSubstr@\verb,outputSubstr,!value (\verb,TextIO,)}
val flushOut     : outstream \verb"-"\verb">" unit\index{flushOut@\verb,flushOut,!value (\verb,TextIO,)}

val stdOut       : outstream\index{stdOut@\verb,stdOut,!value (\verb,TextIO,)}
val stdErr       : outstream\index{stdErr@\verb,stdErr,!value (\verb,TextIO,)}

val print        : string \verb"-"\verb">" unit\index{print@\verb,print,!value (\verb,TextIO,)}

\separatingline
   This structure provides input/output functions on text streams.
   The functions are state\verb"-"based: reading from or writing to a stream
   changes the state of the stream.  The streams are buffered: output
   to a stream may not immediately affect the underlying file or
   device.

   Note that under DOS, Windows, OS/2, and MacOS, text streams will be
   `translated' by converting (e.g.) the double newline CRLF to a
   single newline character \verb"\"n.

   [instream] is the type of state\verb"-"based characters input streams.\index{instream@\verb,instream,!type (\verb,TextIO,)}

   [outstream] is the type of state\verb"-"based character output streams.\index{outstream@\verb,outstream,!type (\verb,TextIO,)}

   [elem] is the type char of characters.\index{elem@\verb,elem,!type (\verb,TextIO,)}

   [vector] is the type of character vectors, that is, strings.\index{vector@\verb,vector,!type (\verb,TextIO,)}


   TEXT INPUT:

   [openIn s] creates a new instream associated with the file named s.\index{openIn@\verb,openIn,!value (\verb,TextIO,)}
   Raises Io.Io is file s does not exist or is not accessible.

   [closeIn istr] closes stream istr.  Has no effect if istr is closed\index{closeIn@\verb,closeIn,!value (\verb,TextIO,)}
   already.  Further operations on istr will behave as if istr is at
   end of stream (that is, will return "" or NONE or true).

   [input istr] reads some elements from istr, returning a vector v of\index{input@\verb,input,!value (\verb,TextIO,)}
   those elements.  The vector will be empty (size v = 0) if and only
   if istr is at end of stream or is closed.  May block (not return
   until data are available in the external world).

   [inputAll istr] reads and returns the string v of all characters\index{inputAll@\verb,inputAll,!value (\verb,TextIO,)}
   remaining in istr up to end of stream.

   [inputNoBlock istr] returns SOME(v) if some elements v can be read\index{inputNoBlock@\verb,inputNoBlock,!value (\verb,TextIO,)}
   without blocking; returns SOME("") if it can be determined without
   blocking that istr is at end of stream; returns NONE otherwise.  If
   istr does not support non\verb"-"blocking input, raises
   Io.NonblockingNotSupported.

   [input1 istr] returns SOME(e) if at least one element e of istr is\index{input1@\verb,input1,!value (\verb,TextIO,)}
   available; returns NONE if istr is at end of stream or is closed;
   blocks if necessary until one of these conditions holds.

   [inputN(istr, n)] returns the next n characters from istr as a\index{inputN@\verb,inputN,!value (\verb,TextIO,)}
   string, if that many are available; returns all remaining
   characters if end of stream is reached before n characters are
   available; blocks if necessary until one of these conditions holds.
   (This is the behaviour of the `input' function prescribed in the
   1990 Definition of Standard ML).

   [inputLine istr] returns one line of text, including the\index{inputLine@\verb,inputLine,!value (\verb,TextIO,)}
   terminating newline character.  If end of stream is reached before
   a newline character, then the remaining part of the stream is
   returned, with a newline character added.  If istr is at end of
   stream or is closed, then the empty string "" is returned.

   [endOfStream istr] returns false if any elements are available in\index{endOfStream@\verb,endOfStream,!value (\verb,TextIO,)}
   istr; returns true if istr is at end of stream or closed; blocks if
   necessary until one of these conditions holds.

   [lookahead istr] returns SOME(e) where e is the next element in the\index{lookahead@\verb,lookahead,!value (\verb,TextIO,)}
   stream; returns NONE if istr is at end of stream or is closed;
   blocks if necessary until one of these conditions holds.  Does not
   advance the stream.

   [stdIn] is the buffered state\verb"-"based standard input stream.\index{stdIn@\verb,stdIn,!value (\verb,TextIO,)}

   [scanStream scan istr] turns the instream istr into a character\index{scanStream@\verb,scanStream,!value (\verb,TextIO,)}
   source and applies the scanner `scan' to that source.  See
   StringCvt for more on character sources and scanners.  The Moscow
   ML implementation currently can backtrack only 512 characters, and
   raises Fail if the scanner backtracks further than that.


   TEXT OUTPUT:

   [openOut s] creates a new outstream associated with the file named\index{openOut@\verb,openOut,!value (\verb,TextIO,)}
   s.  If file s does not exist, and the directory exists and is
   writable, then a new file is created.  If file s exists, it is
   truncated (any existing contents are lost).

   [openAppend s] creates a new outstream associated with the file\index{openAppend@\verb,openAppend,!value (\verb,TextIO,)}
   named s.  If file s does not exist, and the directory exists and is
   writable, then a new file is created.  If file s exists, any
   existing contents are retained, and output goes at the end of the
   file.

   [closeOut ostr] closes stream ostr; further operations on ostr\index{closeOut@\verb,closeOut,!value (\verb,TextIO,)}
   (except for additional close operations) will raise exception Io.Io.

   [output(ostr, v)] writes the string v on outstream ostr.\index{output@\verb,output,!value (\verb,TextIO,)}

   [output1(ostr, e)] writes the character e on outstream ostr.\index{output1@\verb,output1,!value (\verb,TextIO,)}

   [flushOut ostr] flushes the outstream ostr, so that all data\index{flushOut@\verb,flushOut,!value (\verb,TextIO,)}
   written to ostr becomes available to the underlying file or device.

   [stdOut] is the buffered state\verb"-"based standard output stream.\index{stdOut@\verb,stdOut,!value (\verb,TextIO,)}

   [stdErr] is the unbuffered state\verb"-"based standard error stream.  That\index{stdErr@\verb,stdErr,!value (\verb,TextIO,)}
   is, it is always kept flushed, so flushOut(stdErr) is redundant.

   [print s] outputs s to stdOut and flushes immediately.\index{print@\verb,print,!value (\verb,TextIO,)}


   The functions below are not yet implemented:

   [setPosIn(istr, i)] sets istr to the (untranslated) position i.
   Raises Io.Io if not supported on istr.

   [getPosIn istr] returns the (untranslated) current position of istr.
   Raises Io.Io if not supported on istr.

   [endPosIn istr] returns the (untranslated) last position of istr.
   Because of translation, one cannot expect to read 
        endPosIn istr \verb"-" getPosIn istr
   from the current position.

   [getPosOut ostr] returns the current position in stream ostr.
   Raises Io.Io if not supported on ostr.

   [endPosOut ostr] returns the ending position in stream ostr.
   Raises Io.Io if not supported on ostr.

   [setPosOut(ostr, i)] sets the current position in stream to ostr to
   i.  Raises Io.Io if not supported on ostr.

   [mkInstream sistr] creates a state\verb"-"based instream from the
   functional instream sistr.

   [getInstream istr] returns the functional instream underlying the
   state\verb"-"based instream istr.

   [setInstream(istr, sistr)] redirects istr, so that subsequent input
   is taken from the functional instream sistr.

   [mkOutstream sostr] creates a state\verb"-"based outstream from the
   outstream sostr.

   [getOutstream ostr] returns the outstream underlying the
   state\verb"-"based outstream ostr.

   [setOutstream(ostr, sostr)] redirects the outstream ostr so that
   subsequent output goes to sostr.
\end{longprogram}
\index{TextIO@\verb,TextIO, (structure)|)}\newpage

\section*{Module Time}
\index{Time@\verb,Time, (structure)|(}
\markboth{\MakeUppercase{Time}}{\MakeUppercase{Time}}
\addcontentsline{toc}{section}{Time}
\begin{longprogram}
{\itshape{}Time \verb"-"\verb"-" SML Basis Library }

eqtype time\index{time@\verb,time,!type (\verb,Time,)}

exception Time\index{Time@\verb,Time,!exception (\verb,Time,)}

val zeroTime         : time\index{zeroTime@\verb,zeroTime,!value (\verb,Time,)}
val now              : unit \verb"-"\verb">" time\index{now@\verb,now,!value (\verb,Time,)}

val toSeconds        : time \verb"-"\verb">" int\index{toSeconds@\verb,toSeconds,!value (\verb,Time,)}
val toMilliseconds   : time \verb"-"\verb">" int\index{toMilliseconds@\verb,toMilliseconds,!value (\verb,Time,)}
val toMicroseconds   : time \verb"-"\verb">" int\index{toMicroseconds@\verb,toMicroseconds,!value (\verb,Time,)}
val fromSeconds      : int \verb"-"\verb">" time\index{fromSeconds@\verb,fromSeconds,!value (\verb,Time,)}
val fromMilliseconds : int \verb"-"\verb">" time\index{fromMilliseconds@\verb,fromMilliseconds,!value (\verb,Time,)}
val fromMicroseconds : int \verb"-"\verb">" time\index{fromMicroseconds@\verb,fromMicroseconds,!value (\verb,Time,)}

val fromReal         : real \verb"-"\verb">" time\index{fromReal@\verb,fromReal,!value (\verb,Time,)}
val toReal           : time \verb"-"\verb">" real\index{toReal@\verb,toReal,!value (\verb,Time,)}

val toString         : time \verb"-"\verb">" string	{\itshape{}rounded to millisecond precision }\index{toString@\verb,toString,!value (\verb,Time,)}
val fmt              : int \verb"-"\verb">" time \verb"-"\verb">" string\index{fmt@\verb,fmt,!value (\verb,Time,)}
val fromString       : string \verb"-"\verb">" time option\index{fromString@\verb,fromString,!value (\verb,Time,)}
val scan             : (char, 'a) StringCvt.reader \index{scan@\verb,scan,!value (\verb,Time,)}
                       \verb"-"\verb">" (time, 'a) StringCvt.reader

val +       : time * time \verb"-"\verb">" time\index{+@\verb,+,!value (\verb,Time,)}
val \verb"-"       : time * time \verb"-"\verb">" time\index{-@\verb,-,!value (\verb,Time,)}
val \verb"<"       : time * time \verb"-"\verb">" bool\index{<@\verb,<,!value (\verb,Time,)}
val \verb"<"=      : time * time \verb"-"\verb">" bool\index{<=@\verb,<=,!value (\verb,Time,)}
val \verb">"       : time * time \verb"-"\verb">" bool\index{>@\verb,>,!value (\verb,Time,)}
val \verb">"=      : time * time \verb"-"\verb">" bool\index{>=@\verb,>=,!value (\verb,Time,)}

val compare : time * time \verb"-"\verb">" order\index{compare@\verb,compare,!value (\verb,Time,)}

\separatingline
   [time] is a type for representing durations as well as absolute\index{time@\verb,time,!type (\verb,Time,)}
   points in time (which can be thought of as durations since some
   fixed time zero).

   [zeroTime] represents the 0\verb"-"second duration, and the origin of time, \index{zeroTime@\verb,zeroTime,!value (\verb,Time,)}
   so zeroTime + t = t + zeroTime = t for all t.

   [now ()] returns the point in time at which the application occurs.\index{now@\verb,now,!value (\verb,Time,)}

   [fromSeconds s] returns the time value corresponding to s seconds.  \index{fromSeconds@\verb,fromSeconds,!value (\verb,Time,)}
   Raises Time if s \verb"<" 0.

   [fromMilliseconds ms] returns the time value corresponding to ms\index{fromMilliseconds@\verb,fromMilliseconds,!value (\verb,Time,)}
   milliseconds.  Raises Time if ms \verb"<" 0.

   [fromMicroseconds us] returns the time value corresponding to us\index{fromMicroseconds@\verb,fromMicroseconds,!value (\verb,Time,)}
   microseconds.  Raises Time if us \verb"<" 0.

   [toSeconds t] returns the number of seconds represented by t,\index{toSeconds@\verb,toSeconds,!value (\verb,Time,)}
   truncated.  Raises Overflow if that number is not representable as
   an int.

   [toMilliseconds t] returns the number of milliseconds\index{toMilliseconds@\verb,toMilliseconds,!value (\verb,Time,)}
   represented by t, truncated.  Raises Overflow if that number is not
   representable as an int.

   [toMicroseconds t] returns the number of microseconds\index{toMicroseconds@\verb,toMicroseconds,!value (\verb,Time,)}
   represented by t, truncated.  Raises Overflow if t that number is
   not representable as an int.

   [fromReal r] converts a real to a time value representing that\index{fromReal@\verb,fromReal,!value (\verb,Time,)}
   many seconds.  Raises Time if r \verb"<" 0 or if r is not representable
   as a time value.  It holds that realToTime 0.0 = zeroTime.  

   [toReal t] converts a time the number of seconds it represents;\index{toReal@\verb,toReal,!value (\verb,Time,)}
   hence realToTime and timeToReal are inverses of each other when 
   defined.  Raises Overflow if t is not representable as a real.

   [fmt n t] returns as a string the number of seconds represented by\index{fmt@\verb,fmt,!value (\verb,Time,)}
   t, rounded to n decimal digits.  If n \verb"<"= 0, then no decimal digits
   are reported. 

   [toString t] returns as a string the number of seconds represented\index{toString@\verb,toString,!value (\verb,Time,)}
   by t, rounded to 3 decimal digits.  Equivalent to (fmt 3 t).  

   [fromString s] returns SOME t where t is the time value represented\index{fromString@\verb,fromString,!value (\verb,Time,)}
   by the string s of form [\verb"\"n\verb"\"t ]*([0\verb"-"9]+(\verb"\".[0\verb"-"9]+)?)|(\verb"\".[0\verb"-"9]+); 
   or returns NONE if s cannot be parsed as a time value.

   [scan getc src], where getc is a character accessor, returns SOME\index{scan@\verb,scan,!value (\verb,Time,)}
   (t, rest) where t is a time and rest is rest of the input, or NONE
   if s cannot be parsed as a time value.

   [+] adds two time values. For reals r1, r2 \verb">"= 0.0, it holds that\index{+@\verb,+,!value (\verb,Time,)}
   realToTime r1 + realToTime r2 = realToTime(Real.+(r1,r2)).  
   Raises Overflow if the result is not representable as a time value.

   [\verb"-"] subtracts a time value from another.  That is, t1 \verb"-" t2 is the\index{-@\verb,-,!value (\verb,Time,)}
   duration from t2 to t1.  Raises Time if t1 \verb"<" t2 or if the result is
   not representable as a time value.  It holds that t \verb"-" zeroTime = t.

   [\verb"<"]\index{<@\verb,<,!value (\verb,Time,)}
   [\verb"<"=]\index{<=@\verb,<=,!value (\verb,Time,)}
   [\verb">"]\index{>@\verb,>,!value (\verb,Time,)}
   [\verb">"=] compares time values.  For instance, for reals r1, r2 \verb">"= 0.0 \index{>=@\verb,>=,!value (\verb,Time,)}
   it holds that realToTime r1 \verb"<" realToTime r2 iff Real.\verb"<"(r1, r2)

   [compare(t1, t2)] returns LESS, EQUAL, or GREATER, according \index{compare@\verb,compare,!value (\verb,Time,)}
   as t1 precedes, equals, or follows t2 in time.
\end{longprogram}
\index{Time@\verb,Time, (structure)|)}\newpage

\section*{Module Timer}
\index{Timer@\verb,Timer, (structure)|(}
\markboth{\MakeUppercase{Timer}}{\MakeUppercase{Timer}}
\addcontentsline{toc}{section}{Timer}
\begin{longprogram}
{\itshape{}Timer \verb"-"\verb"-" SML Basis Library }

type cpu_timer\index{cpu_timer@\verb,cpu_timer,!type (\verb,Timer,)}
type real_timer\index{real_timer@\verb,real_timer,!type (\verb,Timer,)}

val startCPUTimer  : unit \verb"-"\verb">" cpu_timer\index{startCPUTimer@\verb,startCPUTimer,!value (\verb,Timer,)}
val totalCPUTimer  : unit \verb"-"\verb">" cpu_timer\index{totalCPUTimer@\verb,totalCPUTimer,!value (\verb,Timer,)}
val checkCPUTimer  : cpu_timer \verb"-"\verb">" \index{checkCPUTimer@\verb,checkCPUTimer,!value (\verb,Timer,)}
                     \verb"{" usr : Time.time, sys : Time.time, gc : Time.time \verb"}"

val startRealTimer : unit \verb"-"\verb">" real_timer\index{startRealTimer@\verb,startRealTimer,!value (\verb,Timer,)}
val totalRealTimer : unit \verb"-"\verb">" real_timer\index{totalRealTimer@\verb,totalRealTimer,!value (\verb,Timer,)}
val checkRealTimer : real_timer \verb"-"\verb">" Time.time\index{checkRealTimer@\verb,checkRealTimer,!value (\verb,Timer,)}

\separatingline
   [cpu_timer] is the type of timers for measuring CPU time consumption\index{cpu_timer@\verb,cpu_timer,!type (\verb,Timer,)}
   (user time, garbage collection time, and system time).

   [real_timer] is the type of timers for measuring the passing of\index{real_timer@\verb,real_timer,!type (\verb,Timer,)}
   real time (wall\verb"-"clock time).

   [startCPUTimer ()] returns a cpu_timer started at the moment of \index{startCPUTimer@\verb,startCPUTimer,!value (\verb,Timer,)}
   the call.

   [totalCPUTimer ()] returns a cpu_timer started at the moment the \index{totalCPUTimer@\verb,totalCPUTimer,!value (\verb,Timer,)}
   library was loaded.

   [checkCPUTimer tmr] returns \verb"{"usr, sys, gc\verb"}" where usr is the amount\index{checkCPUTimer@\verb,checkCPUTimer,!value (\verb,Timer,)}
   of user CPU time consumed since tmr was started, gc is the amount
   of user CPU time spent on garbage collection, and sys is the
   amount of system CPU time consumed since tmr was started.  Note
   that gc time is included in the usr time.  Under MS DOS, usr time
   and gc time are measured in real time.

   [startRealTimer ()] returns a real_timer started at the moment of \index{startRealTimer@\verb,startRealTimer,!value (\verb,Timer,)}
   the call.

   [totalRealTimer ()] returns a real_timer started at the moment the \index{totalRealTimer@\verb,totalRealTimer,!value (\verb,Timer,)}
   library was loaded.

   [checkRealTimer tmr] returns the amount of real time that has passed\index{checkRealTimer@\verb,checkRealTimer,!value (\verb,Timer,)}
   since tmr was started.
\end{longprogram}
\index{Timer@\verb,Timer, (structure)|)}\newpage

\section*{Module Unix}
\index{Unix@\verb,Unix, (structure)|(}
\markboth{\MakeUppercase{Unix}}{\MakeUppercase{Unix}}
\addcontentsline{toc}{section}{Unix}
\begin{longprogram}
{\itshape{}Unix \verb"-"\verb"-" SML Basis Library }

type proc\index{proc@\verb,proc,!type (\verb,Unix,)}
type signal = Signal.signal\index{signal@\verb,signal,!type (\verb,Unix,)}

val executeInEnv : string * string list * string list \verb"-"\verb">" proc \index{executeInEnv@\verb,executeInEnv,!value (\verb,Unix,)}
val execute      : string * string list \verb"-"\verb">" proc \index{execute@\verb,execute,!value (\verb,Unix,)}
val streamsOf    : proc \verb"-"\verb">" TextIO.instream * TextIO.outstream\index{streamsOf@\verb,streamsOf,!value (\verb,Unix,)}
val kill         : proc * signal \verb"-"\verb">" unit\index{kill@\verb,kill,!value (\verb,Unix,)}
val reap         : proc \verb"-"\verb">" Process.status \index{reap@\verb,reap,!value (\verb,Unix,)}

\separatingline
   This structure allows Moscow ML programs to start other processes
   and to communicate with them.  

   Child processes are not automatically terminated when the parent
   (ML) process terminates.  To forcibly terminate a child process pr,
   use Unix.kill(pr, Signal.term).  Then, to remove the terminated
   process from the operating system tables, call Unix.reap(pr).

   The protocol for communication between the ML program and its child
   process must be designed with some care, typically using
   non\verb"-"blocking input for reading from the child process.

   [proc] is the type of processes started by the ML program.\index{proc@\verb,proc,!type (\verb,Unix,)}

   [signal] is the type of Unix\verb"-"style signals, which can be sent to\index{signal@\verb,signal,!type (\verb,Unix,)}
   another process.  Signal values must be obtained from the Signal
   structure.

   [execute (cmd, args)] asks the operating system to execute the\index{execute@\verb,execute,!value (\verb,Unix,)}
   command cmd with the argument list args, as a separate process.
   Two pipes connected to the standard input and standard output of
   the new process are created; these may be obtained using streamsOf.
   A proc value representing the new process is returned.  The new
   process executes using the same environment as the calling process.
   Raises Fail in case of failure, e.g. if the process or the pipes
   cannot be created.

   Typically, the cmd argument will be the full pathname of an
   executable.  On Unix systems, simple command searching as done by
   the shell, allowing cmd to be a relative pathname, can be achieved
   by using
        execute("/bin/sh", "\verb"-"c" :: concat (cmd :: " " :: args))

   [executeInEnv (cmd, args, env)] asks the operating system to\index{executeInEnv@\verb,executeInEnv,!value (\verb,Unix,)}
   execute the command cmd with the argument list args in the
   environment env, as a separate process.  Returns a proc value
   representing the new process.  Typically, a string in the env list
   has the form "NAME=VALUE".  See also Process.getEnv.  

   [streamsOf pr] returns a pair (ins, outs) of input and output\index{streamsOf@\verb,streamsOf,!value (\verb,Unix,)}
   streams associated with process pr.  The standard output of pr is
   the source for the input stream ins, and the standard input of pr
   is the sink for the output stream outs.

   [reap pr] closes the input and output streams associated with pr,\index{reap@\verb,reap,!value (\verb,Unix,)}
   and then suspends the current (ML) process until the process
   corresponding to pr terminates.  Returns the exit status given by
   pr when it terminated.  Raises Fail in case of failure, e.g. if pr
   has already been reaped.

   Under Unix, information about a terminated process remains in the
   system tables until the process is reaped.  Thus, an ML program
   using execute or executeInEnv must make sure to reap any process it
   has created, or else the system tables will fill up.

   [kill (pr, s)] sends the signal s to the process pr.  Raises Fail\index{kill@\verb,kill,!value (\verb,Unix,)}
   in case of failure, e.g. if pr has already been killed.
\end{longprogram}
\index{Unix@\verb,Unix, (structure)|)}\newpage

\section*{Module Vector}
\index{Vector@\verb,Vector, (structure)|(}
\markboth{\MakeUppercase{Vector}}{\MakeUppercase{Vector}}
\addcontentsline{toc}{section}{Vector}
\begin{longprogram}
{\itshape{}Vector \verb"-"\verb"-" SML Basis Library }

type 'a vector = 'a vector\index{vector@\verb,vector,!type (\verb,Vector,)}
val maxLen   : int\index{maxLen@\verb,maxLen,!value (\verb,Vector,)}

val fromList : 'a list \verb"-"\verb">" 'a vector\index{fromList@\verb,fromList,!value (\verb,Vector,)}
val tabulate : int * (int \verb"-"\verb">" 'a) \verb"-"\verb">" 'a vector\index{tabulate@\verb,tabulate,!value (\verb,Vector,)}

val length   : 'a vector \verb"-"\verb">" int\index{length@\verb,length,!value (\verb,Vector,)}
val sub      : 'a vector * int \verb"-"\verb">" 'a\index{sub@\verb,sub,!value (\verb,Vector,)}
val extract  : 'a vector * int * int option \verb"-"\verb">" 'a vector\index{extract@\verb,extract,!value (\verb,Vector,)}
val concat   : 'a vector list \verb"-"\verb">" 'a vector\index{concat@\verb,concat,!value (\verb,Vector,)}

val app      : ('a \verb"-"\verb">" unit) \verb"-"\verb">" 'a vector \verb"-"\verb">" unit\index{app@\verb,app,!value (\verb,Vector,)}
val map      : ('a \verb"-"\verb">" 'b) \verb"-"\verb">" 'a vector \verb"-"\verb">" 'b vector\index{map@\verb,map,!value (\verb,Vector,)}
val foldl    : ('a * 'b \verb"-"\verb">" 'b) \verb"-"\verb">" 'b \verb"-"\verb">" 'a vector \verb"-"\verb">" 'b\index{foldl@\verb,foldl,!value (\verb,Vector,)}
val foldr    : ('a * 'b \verb"-"\verb">" 'b) \verb"-"\verb">" 'b \verb"-"\verb">" 'a vector \verb"-"\verb">" 'b\index{foldr@\verb,foldr,!value (\verb,Vector,)}

val appi     : (int * 'a \verb"-"\verb">" unit) \verb"-"\verb">" 'a vector * int * int option \verb"-"\verb">" unit\index{appi@\verb,appi,!value (\verb,Vector,)}
val mapi     : (int * 'a \verb"-"\verb">" 'b) \verb"-"\verb">" 'a vector * int * int option \verb"-"\verb">" 'b vector\index{mapi@\verb,mapi,!value (\verb,Vector,)}
val foldli   : (int * 'a * 'b \verb"-"\verb">" 'b) \verb"-"\verb">" 'b \verb"-"\verb">" 'a vector*int*int option \verb"-"\verb">" 'b\index{foldli@\verb,foldli,!value (\verb,Vector,)}
val foldri   : (int * 'a * 'b \verb"-"\verb">" 'b) \verb"-"\verb">" 'b \verb"-"\verb">" 'a vector*int*int option \verb"-"\verb">" 'b\index{foldri@\verb,foldri,!value (\verb,Vector,)}

\separatingline
   ['ty vector] is the type of one\verb"-"dimensional, immutable, zero\verb"-"based\index{vector@\verb,vector,!type (\verb,Vector,)}
   constant\verb"-"time\verb"-"access vectors with elements of type 'ty.  
   Type 'ty vector admits equality if 'ty does.  Vectors v1 and v2 are 
   equal if they have the same length and their elements are equal.

   [maxLen] is the maximal number of elements in a vector.\index{maxLen@\verb,maxLen,!value (\verb,Vector,)}

   [fromList xs] returns a vector whose elements are those of xs.\index{fromList@\verb,fromList,!value (\verb,Vector,)}
   Raises Size if length xs \verb">" maxLen.

   [tabulate(n, f)] returns a vector of length n whose elements\index{tabulate@\verb,tabulate,!value (\verb,Vector,)}
   are f 0, f 1, ..., f (n\verb"-"1), created from left to right.  Raises
   Size if n\verb"<"0 or n\verb">"maxLen.

   [length v] returns the number of elements in v.\index{length@\verb,length,!value (\verb,Vector,)}

   [sub(v, i)] returns the i'th element of v, counting from 0.\index{sub@\verb,sub,!value (\verb,Vector,)}
   Raises Subscript if i\verb"<"0 or i\verb">"=length v.

   [extract(v, i, NONE)] returns a vector of the elements v[i..length v\verb"-"1]\index{extract@\verb,extract,!value (\verb,Vector,)}
   of v.  Raises Subscript if i\verb"<"0 or i\verb">"length v.

   [extract(v, i, SOME n)] returns a vector of the elements v[i..i+n\verb"-"1]\index{extract@\verb,extract,!value (\verb,Vector,)}
   of v.  Raises Subscript if i\verb"<"0 or n\verb"<"0 or i+n\verb">"length v.

   [concat vs] returns a vector which is the concatenation from left\index{concat@\verb,concat,!value (\verb,Vector,)}
   to right og the vectors in vs.  Raises Size if the sum of the
   sizes of the vectors in vs is larger than maxLen.

   [foldl f e v] folds function f over v from left to right.  That is,\index{foldl@\verb,foldl,!value (\verb,Vector,)}
   computes f(v[len\verb"-"1], f(v[len\verb"-"2], ..., f(v[1], f(v[0], e)) ...)),
   where len is the length of v.

   [foldr f e v] folds function f over v from right to left.  That is,\index{foldr@\verb,foldr,!value (\verb,Vector,)}
   computes f(v[0], f(v[1], ..., f(v[len\verb"-"2], f(v[len\verb"-"1], e)) ...)),
   where len is the length of v.

   [app f v] applies f to v[j] for j=0,1,...,length v\verb"-"1.\index{app@\verb,app,!value (\verb,Vector,)}

   [map f v] applies f to v[j] for j=0,1,...,length v\verb"-"1 and returns a \index{map@\verb,map,!value (\verb,Vector,)}
   new vector containing the results.
   

   The following iterators generalize the above ones in two ways:

    * the index j is also being passed to the function being iterated;
    * the iterators work on a slice (subvector) of a vector.

   The slice (v, i, SOME n) denotes the subvector v[i..i+n\verb"-"1].  That is,
   v[i] is the first element of the slice, and n is the length of the
   slice.  Valid only if 0 \verb"<"= i \verb"<"= i+n \verb"<"= length v.

   The slice (v, i, NONE) denotes the subvector v[i..length v\verb"-"1].  That
   is, the slice denotes the suffix of the vector starting at i.  Valid
   only if 0 \verb"<"= i \verb"<"= length v.  Equivalent to (v, i, SOME(length v \verb"-" i)).

       slice             meaning 
       \verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"
       (v, 0, NONE)      the whole vector             v[0..len\verb"-"1]   
       (v, 0, SOME n)    a left subvector (prefix)    v[0..n\verb"-"1]
       (v, i, NONE)      a right subvector (suffix)   v[i..len\verb"-"1]
       (v, i, SOME n)    a general slice              v[i..i+n\verb"-"1] 

   [foldli f e (v, i, SOME n)] folds function f over the subvector\index{foldli@\verb,foldli,!value (\verb,Vector,)}
   v[i..i+n\verb"-"1] from left to right.  That is, computes 
   f(i+n\verb"-"1, v[i+n\verb"-"1], f(..., f(i+1, v[i+1], f(i, v[i], e)) ...)).  
   Raises Subscript if i\verb"<"0 or n\verb"<"0 or i+n \verb">" length v.

   [foldli f e (v, i, NONE)] folds function f over the subvector\index{foldli@\verb,foldli,!value (\verb,Vector,)}
   v[i..len\verb"-"1] from left to right, where len =  length v.  That is, 
   computes f(len\verb"-"1, v[len\verb"-"1], f(..., f(i+1, v[i+1], f(i, v[i], e)) ...)).  
   Raises Subscript if i\verb"<"0 or i \verb">" length v.

   [foldri f e (v, i, SOME n)] folds function f over the subvector\index{foldri@\verb,foldri,!value (\verb,Vector,)}
   v[i..i+n\verb"-"1] from right to left.  That is, computes 
   f(i, v[i], f(i+1, v[i+1], ..., f(i+n\verb"-"1, v[i+n\verb"-"1], e) ...)).
   Raises Subscript if i\verb"<"0 or n\verb"<"0 or i+n \verb">" length v.

   [foldri f e (v, i, NONE)] folds function f over the subvector\index{foldri@\verb,foldri,!value (\verb,Vector,)}
   v[i..len\verb"-"1] from right to left, where len = length v.  That is, 
   computes f(i, v[i], f(i+1, v[i+1], ..., f(len\verb"-"1, v[len\verb"-"1], e) ...)).
   Raises Subscript if i\verb"<"0 or i \verb">" length v.

   [appi f (v, i, SOME n)] applies f to successive pairs (j, v[j]) for\index{appi@\verb,appi,!value (\verb,Vector,)}
   j=i,i+1,...,i+n\verb"-"1.  Raises Subscript if i\verb"<"0 or n\verb"<"0 or i+n \verb">" length v.

   [appi f (v, i, NONE)] applies f to successive pairs (j, v[j]) for\index{appi@\verb,appi,!value (\verb,Vector,)}
   j=i,i+1,...,len\verb"-"1, where len = length v.  Raises Subscript if i\verb"<"0
   or i \verb">" length v.

   [mapi f (v, i, SOME n)] applies f to successive pairs (j, v[j]) for \index{mapi@\verb,mapi,!value (\verb,Vector,)}
   j=i,i+1,...,i+n\verb"-"1 and returns a new vector (of length n) containing 
   the results.  Raises Subscript if i\verb"<"0 or n\verb"<"0 or i+n \verb">" length v.

   [mapi f (v, i, NONE)] applies f to successive pairs (j, v[j]) for \index{mapi@\verb,mapi,!value (\verb,Vector,)}
   j=i,i+1,...,len\verb"-"1, where len = length v, and returns a new vector
   (of length len\verb"-"i) containing the results.  Raises Subscript if i\verb"<"0
   or i \verb">" length v.
\end{longprogram}
\index{Vector@\verb,Vector, (structure)|)}\newpage

\section*{Module Weak}
\index{Weak@\verb,Weak, (structure)|(}
\markboth{\MakeUppercase{Weak}}{\MakeUppercase{Weak}}
\addcontentsline{toc}{section}{Weak}
\begin{longprogram}
{\itshape{}Weak \verb"-"\verb"-"\verb"-" weak pointers and arrays of weak pointers }

{\itshape{}Single weak pointers }

type 'a weak\index{weak@\verb,weak,!type (\verb,Weak,)}
val weak    : 'a \verb"-"\verb">" 'a weak\index{weak@\verb,weak,!value (\verb,Weak,)}
val set     : 'a weak * 'a \verb"-"\verb">" unit\index{set@\verb,set,!value (\verb,Weak,)}
val get     : 'a weak \verb"-"\verb">" 'a                  {\itshape{}Raises Fail }\index{get@\verb,get,!value (\verb,Weak,)}
val isweak  : 'a weak \verb"-"\verb">" bool\index{isweak@\verb,isweak,!value (\verb,Weak,)}

{\itshape{}Arrays of weak pointers }

prim_EQtype 'a array\index{array@\verb,array,!type (\verb,Weak,)}

val maxLen  : int\index{maxLen@\verb,maxLen,!value (\verb,Weak,)}

val array   : int \verb"-"\verb">" '_a array               {\itshape{}Raises Size               }\index{array@\verb,array,!value (\verb,Weak,)}
val sub     : 'a array * int \verb"-"\verb">" 'a           {\itshape{}Raises Fail and Subscript }\index{sub@\verb,sub,!value (\verb,Weak,)}
val update  : 'a array * int * 'a \verb"-"\verb">" unit    {\itshape{}Raises Subscript          }\index{update@\verb,update,!value (\verb,Weak,)}
val isdead  : 'a array * int \verb"-"\verb">" bool         {\itshape{}Raises Subscript          }\index{isdead@\verb,isdead,!value (\verb,Weak,)}
val length  : 'a array \verb"-"\verb">" int\index{length@\verb,length,!value (\verb,Weak,)}

val app     : ('a \verb"-"\verb">" unit) \verb"-"\verb">" 'a array \verb"-"\verb">" unit\index{app@\verb,app,!value (\verb,Weak,)}
val foldl   : ('a * 'b \verb"-"\verb">" 'b) \verb"-"\verb">" 'b \verb"-"\verb">" 'a array \verb"-"\verb">" 'b\index{foldl@\verb,foldl,!value (\verb,Weak,)}
val foldr   : ('a * 'b \verb"-"\verb">" 'b) \verb"-"\verb">" 'b \verb"-"\verb">" 'a array \verb"-"\verb">" 'b\index{foldr@\verb,foldr,!value (\verb,Weak,)}
val modify  : ('a \verb"-"\verb">" 'a) \verb"-"\verb">" 'a array \verb"-"\verb">" unit\index{modify@\verb,modify,!value (\verb,Weak,)}

val appi    : (int * 'a \verb"-"\verb">" unit) \verb"-"\verb">" 'a array * int * int option \verb"-"\verb">" unit\index{appi@\verb,appi,!value (\verb,Weak,)}
val foldli  : (int * 'a * 'b \verb"-"\verb">" 'b) \verb"-"\verb">" 'b \verb"-"\verb">" 'a array * int * int option \index{foldli@\verb,foldli,!value (\verb,Weak,)}
              \verb"-"\verb">" 'b
val foldri  : (int * 'a * 'b \verb"-"\verb">" 'b) \verb"-"\verb">" 'b \verb"-"\verb">" 'a array * int * int option \index{foldri@\verb,foldri,!value (\verb,Weak,)}
              \verb"-"\verb">" 'b
val modifyi : (int * 'a \verb"-"\verb">" 'a) \verb"-"\verb">" 'a array * int * int option \verb"-"\verb">" unit\index{modifyi@\verb,modifyi,!value (\verb,Weak,)}

\separatingline
   ['a weak] is the type of weak pointers to objects of type 'a.  A\index{weak@\verb,weak,!type (\verb,Weak,)}
   weak pointer is a pointer that cannot itself keep an object alive.
   Hence the object pointed to by a weak pointer may be deallocated by
   the garbage collector if the object is reachable only by weak
   pointers.  In this case, subsequent accesses via the `get' function
   will raise Fail "Dangling weak pointer".  (We raise an exception
   instead of returning an option value, because access via a weak
   pointer to a deallocated object is likely to be a programming
   error).

   Integers, characters, words and booleans will not be deallocated by
   the garbage collector and will remain reachable forever by a weak
   pointer.  Reals, strings, tuples and other non\verb"-"nullary constructors
   may be deallocated by the garbage collector.  Constants, even
   composite ones, will not be deallocated either.

   [weak v] creates and returns a weak pointer to value v.\index{weak@\verb,weak,!value (\verb,Weak,)}

   [get w] returns the value pointed to by weak pointer w, if the\index{get@\verb,get,!value (\verb,Weak,)}
   value is still alive.  Otherwise raises Fail "Dangling weak pointer".

   [set(w, v)] makes the weak pointer w point to the value v.\index{set@\verb,set,!value (\verb,Weak,)}

   [isweak w] returns true if the value pointed to by w is dead;\index{isweak@\verb,isweak,!value (\verb,Weak,)}
   returns false otherwise.  If an object is reported to be dead, it
   remains dead.  However, an object is reported to be live just if it
   has not yet been deallocated by the garbage collector.  The
   allocation of any new value may activate the garbage collector and
   cause the object to die.  Thus
        if not (isweak w) then get w else "blah" 
   will not raise exception Fail, whereas the following might:
        if not (isweak w) then ([1,2] @ [3,4]; get w) else "blah" 
   because evaluation of the list append may cause w to die.

   The value of isweak w is the same as that of
         (get w; false) handle Fail _ =\verb">" true
   but evaluating the latter expression may have the side effect of
   keeping w alive for slightly longer, because a pointer to w is
   returned by get w.

   \verb"-"\verb"-"\verb"-"

   ['a array] is the type of arrays of weak pointers to objects of\index{array@\verb,array,!type (\verb,Weak,)}
   type 'a.

   A value of type 'a Weak.weak (above) is equivalent to, but more
   efficient than, a one\verb"-"element 'a Weak.array.  On the other hand, an
   'a Weak.array is more efficient than an ('a Weak.weak) Array.array.

   [array n] creates an array of n weak pointers.  Initially, any\index{array@\verb,array,!value (\verb,Weak,)}
   access to the array will raise Fail.

   [sub(a, i)] returns the object pointed to by cell i (counting from\index{sub@\verb,sub,!value (\verb,Weak,)}
   0) of the array a, if it is live.  Raises Fail "Dangling weak
   pointer" if cell i has never been updated or if the object pointed
   to has been deallocated by the garbage collector.  Raises Subscript
   if i\verb"<"0 or i\verb">"=length a.  To make `sub' infix, use the declaration
                             infix 9 sub

   [update(a, i, v)] updates cell i of array a to point (weakly) to\index{update@\verb,update,!value (\verb,Weak,)}
   the value v.  Raises Subscript if i\verb"<"0 or i\verb">"=length a.

   [isdead(a, i)] returns true if the object in cell i of array a is\index{isdead@\verb,isdead,!value (\verb,Weak,)}
   dead, and false otherwise.  Analogous to isweak; see above.

   [length a] returns the number of elements in a.\index{length@\verb,length,!value (\verb,Weak,)}

   [maxLen] is the maximal number of elements in an array.\index{maxLen@\verb,maxLen,!value (\verb,Weak,)}

   The iterators described below operate on the live elements only.
   Note that an element a[k] may die in the course of folding f over
   earlier elements (e.g. a[1] ... a[k\verb"-"1]).  Thus the functions should
   be used with great care.

   [foldl f e a] folds function f over the live elements of a, from\index{foldl@\verb,foldl,!value (\verb,Weak,)}
   left to right.  

   [foldr f e a] folds function f over the live elements of a, from\index{foldr@\verb,foldr,!value (\verb,Weak,)}
   right to left.

   [app f a] applies f to the live elements of a from left to right.\index{app@\verb,app,!value (\verb,Weak,)}

   [modify f a] applies f to a[j] and updates a[j] with the result\index{modify@\verb,modify,!value (\verb,Weak,)}
   f(a[j]), for each live element a[j], from left to right.

   The following iterators generalize the above ones in two ways:

    . the index j is also being passed to the function being iterated;
    . the iterators work on a slice (subarray) of an array.

   The slice (a, i, SOME n) denotes the subarray a[i..i+n\verb"-"1].  That is,
   a[i] is the first element of the slice, and n is the length of the
   slice.  Valid only if 0 \verb"<"= i \verb"<"= i+n \verb"<"= length a.

   The slice (a, i, NONE) denotes the subarray a[i..length a\verb"-"1].  That
   is, the slice denotes the suffix of the array starting at i.  Valid
   only if 0 \verb"<"= i \verb"<"= length a.  Equivalent to (a, i, SOME(length a \verb"-" i)).

       slice             meaning 
       \verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"
       (a, 0, NONE)      the whole array              a[0..len\verb"-"1]   
       (a, 0, SOME n)    a left subarray (prefix)     a[0..n\verb"-"1]
       (a, i, NONE)      a right subarray (suffix)    a[i..len\verb"-"1]
       (a, i, SOME n)    a general slice              a[i..i+n\verb"-"1] 

   [foldli f e (a, i, SOME n)] folds function f over the live elements\index{foldli@\verb,foldli,!value (\verb,Weak,)}
   of the subarray a[i..i+n\verb"-"1] from left to right.  Raises Subscript
   if i\verb"<"0 or n\verb"<"0 or i+n \verb">" length a.

   [foldli f e (a, i, NONE)] folds function f over the live elements\index{foldli@\verb,foldli,!value (\verb,Weak,)}
   of the subarray a[i..len\verb"-"1] from left to right, where len = length
   a.  Raises Subscript if i\verb"<"0 or i \verb">" length a.

   [foldri f e (a, i, SOME n)] folds function f over the live elements\index{foldri@\verb,foldri,!value (\verb,Weak,)}
   of the subarray a[i..i+n\verb"-"1] from right to left.  Raises Subscript
   if i\verb"<"0 or n\verb"<"0 or i+n \verb">" length a.

   [foldri f e (a, i, NONE)] folds function f over the live elements\index{foldri@\verb,foldri,!value (\verb,Weak,)}
   of the subarray a[i..len\verb"-"1] from right to left, where len = length
   a.  Raises Subscript if i\verb"<"0 or i \verb">" length a.

   [appi f (a, i, SOME n)] applies f to successive pairs (j, a[j]) for\index{appi@\verb,appi,!value (\verb,Weak,)}
   j=i,i+1,...,i+n\verb"-"1, provided a[j] is live.  Raises Subscript if i\verb"<"0
   or n\verb"<"0 or i+n \verb">" length a.

   [appi f (a, i, NONE)] applies f to successive pairs (j, a[j]) for\index{appi@\verb,appi,!value (\verb,Weak,)}
   j=i,i+1,...,len\verb"-"1, where len = length a, provided a[j] is live.
   Raises Subscript if i\verb"<"0 or i \verb">" length a.

   [modifyi f (a, i, SOME n)] applies f to (j, a[j]) and updates a[j]\index{modifyi@\verb,modifyi,!value (\verb,Weak,)}
   with the result f(j, a[j]) for j=i,i+1,...,i+n\verb"-"1, provided a[j] is
   live.  Raises Subscript if i\verb"<"0 or n\verb"<"0 or i+n \verb">" length a.

   [modifyi f (a, i, NONE)] applies f to (j, a[j]) and updates a[j]\index{modifyi@\verb,modifyi,!value (\verb,Weak,)}
   with the result f(j, a[j]) for j=i,i+1,...,len\verb"-"1, provided a[j] is
   live.  Raises Subscript if i\verb"<"0 or i \verb">" length a.  
\end{longprogram}
\index{Weak@\verb,Weak, (structure)|)}\newpage

\section*{Module Word}
\index{Word@\verb,Word, (structure)|(}
\markboth{\MakeUppercase{Word}}{\MakeUppercase{Word}}
\addcontentsline{toc}{section}{Word}
\begin{longprogram}
{\itshape{}Word \verb"-"\verb"-" SML Basis Library }

type word = word\index{word@\verb,word,!type (\verb,Word,)}

val wordSize   : int\index{wordSize@\verb,wordSize,!value (\verb,Word,)}

val orb        : word * word \verb"-"\verb">" word\index{orb@\verb,orb,!value (\verb,Word,)}
val andb       : word * word \verb"-"\verb">" word\index{andb@\verb,andb,!value (\verb,Word,)}
val xorb       : word * word \verb"-"\verb">" word\index{xorb@\verb,xorb,!value (\verb,Word,)}
val notb       : word \verb"-"\verb">" word\index{notb@\verb,notb,!value (\verb,Word,)}

val \verb"<"\verb"<"         : word * word \verb"-"\verb">" word\index{<<@\verb,<<,!value (\verb,Word,)}
val \verb">"\verb">"         : word * word \verb"-"\verb">" word\index{>>@\verb,>>,!value (\verb,Word,)}
val ~\verb">"\verb">"        : word * word \verb"-"\verb">" word\index{~>>@\verb,~>>,!value (\verb,Word,)}

val +          : word * word \verb"-"\verb">" word\index{+@\verb,+,!value (\verb,Word,)}
val \verb"-"          : word * word \verb"-"\verb">" word\index{-@\verb,-,!value (\verb,Word,)}
val *          : word * word \verb"-"\verb">" word\index{*@\verb,*,!value (\verb,Word,)}
val div        : word * word \verb"-"\verb">" word\index{div@\verb,div,!value (\verb,Word,)}
val mod        : word * word \verb"-"\verb">" word\index{mod@\verb,mod,!value (\verb,Word,)}

val \verb">"          : word * word \verb"-"\verb">" bool\index{>@\verb,>,!value (\verb,Word,)}
val \verb"<"          : word * word \verb"-"\verb">" bool\index{<@\verb,<,!value (\verb,Word,)}
val \verb">"=         : word * word \verb"-"\verb">" bool\index{>=@\verb,>=,!value (\verb,Word,)}
val \verb"<"=         : word * word \verb"-"\verb">" bool\index{<=@\verb,<=,!value (\verb,Word,)}
val compare    : word * word \verb"-"\verb">" order\index{compare@\verb,compare,!value (\verb,Word,)}

val min        : word * word \verb"-"\verb">" word\index{min@\verb,min,!value (\verb,Word,)}
val max        : word * word \verb"-"\verb">" word\index{max@\verb,max,!value (\verb,Word,)}

val toString   : word \verb"-"\verb">" string\index{toString@\verb,toString,!value (\verb,Word,)}
val fromString : string \verb"-"\verb">" word option\index{fromString@\verb,fromString,!value (\verb,Word,)}
val scan       : StringCvt.radix \index{scan@\verb,scan,!value (\verb,Word,)}
                \verb"-"\verb">" (char, 'a) StringCvt.reader \verb"-"\verb">" (word, 'a) StringCvt.reader
val fmt        : StringCvt.radix \verb"-"\verb">" word \verb"-"\verb">" string\index{fmt@\verb,fmt,!value (\verb,Word,)}

val toInt      : word \verb"-"\verb">" int\index{toInt@\verb,toInt,!value (\verb,Word,)}
val toIntX     : word \verb"-"\verb">" int            {\itshape{}with sign extension }\index{toIntX@\verb,toIntX,!value (\verb,Word,)}
val fromInt    : int \verb"-"\verb">" word\index{fromInt@\verb,fromInt,!value (\verb,Word,)}

val toLargeWord   : word \verb"-"\verb">" word\index{toLargeWord@\verb,toLargeWord,!value (\verb,Word,)}
val toLargeWordX  : word \verb"-"\verb">" word        {\itshape{}with sign extension }\index{toLargeWordX@\verb,toLargeWordX,!value (\verb,Word,)}
val fromLargeWord : word \verb"-"\verb">" word\index{fromLargeWord@\verb,fromLargeWord,!value (\verb,Word,)}

val toLargeInt    : word \verb"-"\verb">" int\index{toLargeInt@\verb,toLargeInt,!value (\verb,Word,)}
val toLargeIntX   : word \verb"-"\verb">" int         {\itshape{}with sign extension }\index{toLargeIntX@\verb,toLargeIntX,!value (\verb,Word,)}
val fromLargeInt  : int \verb"-"\verb">" word\index{fromLargeInt@\verb,fromLargeInt,!value (\verb,Word,)}

\separatingline
   [word] is the type of n\verb"-"bit words, or n\verb"-"bit unsigned integers.\index{word@\verb,word,!type (\verb,Word,)}

   [wordSize] is the value of n above.  In Moscow ML, n=31 on 32\verb"-"bit\index{wordSize@\verb,wordSize,!value (\verb,Word,)}
   machines and n=63 on 64\verb"-"bit machines.

   [orb(w1, w2)] returns the bitwise `or' of w1 and w2.\index{orb@\verb,orb,!value (\verb,Word,)}

   [andb(w1, w2)] returns the bitwise `and' of w1 and w2.\index{andb@\verb,andb,!value (\verb,Word,)}

   [xorb(w1, w2)] returns the bitwise `exclusive or' or w1 and w2.\index{xorb@\verb,xorb,!value (\verb,Word,)}

   [notb w] returns the bitwise negation of w.\index{notb@\verb,notb,!value (\verb,Word,)}

   [\verb"<"\verb"<"(w, k)] returns the word resulting from shifting w left by k\index{<<@\verb,<<,!value (\verb,Word,)}
   bits.  The bits shifted in are zero, so this is a logical shift.
   Consequently, the result is 0\verb"-"bits when k \verb">"= wordSize.

   [\verb">"\verb">"(w, k)] returns the word resulting from shifting w right by k\index{>>@\verb,>>,!value (\verb,Word,)}
   bits.  The bits shifted in are zero, so this is a logical shift.
   Consequently, the result is 0\verb"-"bits when k \verb">"= wordSize.

   [~\verb">"\verb">"(w, k)] returns the word resulting from shifting w right by k\index{~>>@\verb,~>>,!value (\verb,Word,)}
   bits.  The bits shifted in are replications of the left\verb"-"most bit:
   the `sign bit', so this is an arithmetical shift.  Consequently,
   for k \verb">"= wordSize and wordToInt w \verb">"= 0 the result is all 0\verb"-"bits, and 
   for k \verb">"= wordSize and wordToInt w \verb"<"  0 the result is all 1\verb"-"bits.

   To make \verb"<"\verb"<", \verb">"\verb">", and ~\verb">"\verb">" infix, use the declaration 
                          infix 5 \verb"<"\verb"<" \verb">"\verb">" ~\verb">"\verb">"

   [+]\index{+@\verb,+,!value (\verb,Word,)}
   [\verb"-"]\index{-@\verb,-,!value (\verb,Word,)}
   [*]\index{*@\verb,*,!value (\verb,Word,)}
   [div]\index{div@\verb,div,!value (\verb,Word,)}
   [mod] represent unsigned integer addition, subtraction,\index{mod@\verb,mod,!value (\verb,Word,)}
   multiplication, division, and remainder, modulus 2 raised to the n'th 
   power, where n=wordSize.  The operations (i div j) and (i mod j)
   raise Div when j=0.  Otherwise no exceptions are raised.

   [\verb"<"]\index{<@\verb,<,!value (\verb,Word,)}
   [\verb"<"=]\index{<=@\verb,<=,!value (\verb,Word,)}
   [\verb">"]\index{>@\verb,>,!value (\verb,Word,)}
   [\verb">"=] compare words as unsigned integers.\index{>=@\verb,>=,!value (\verb,Word,)}

   [compare(w1, w2)] returns LESS, EQUAL, or GREATER, according \index{compare@\verb,compare,!value (\verb,Word,)}
   as w1 is less than, equal to, or greater than w2 (as unsigned integers).

   [min(w1, w2)] returns the smaller of w1 and w2 (as unsigned integers).\index{min@\verb,min,!value (\verb,Word,)}

   [max(w1, w2)] returns the larger of w1 and w2 (as unsigned integers).\index{max@\verb,max,!value (\verb,Word,)}

   [fmt radix w] returns a string representing w, in the radix (base)\index{fmt@\verb,fmt,!value (\verb,Word,)}
   specified by radix.

     radix    description                     output format  
     \verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"  
      BIN     unsigned binary      (base  2)  [01]+         
      OCT     unsigned octal       (base  8)  [0\verb"-"7]+          
      DEC     unsigned decimal     (base 10)  [0\verb"-"9]+          
      HEX     unsigned hexadecimal (base 16)  [0\verb"-"9A\verb"-"F]+       

   [toString w] returns a string representing w in unsigned\index{toString@\verb,toString,!value (\verb,Word,)}
   hexadecimal format.  Equivalent to (fmt HEX w).
   
   [fromString s] returns SOME(w) if a hexadecimal unsigned numeral\index{fromString@\verb,fromString,!value (\verb,Word,)}
   can be scanned from a prefix of string s, ignoring any initial
   whitespace; returns NONE otherwise.  Raises Overflow if the scanned 
   number cannot be represented as a word.  An unsigned hexadecimal
   numeral must have form, after possible initial whitespace:
        [0\verb"-"9a\verb"-"fA\verb"-"F]+

   [scan radix getc charsrc] attempts to scan an unsigned numeral from\index{scan@\verb,scan,!value (\verb,Word,)}
   the character source charsrc, using the accessor getc, and ignoring
   any initial whitespace.  The radix argument specifies the base of
   the numeral (BIN, OCT, DEC, HEX).  If successful, it returns
   SOME(w, rest) where w is the value of the numeral scanned, and rest
   is the unused part of the character source.  Raises Overflow if the
   scanned number cannot be represented as a word.  A numeral must
   have form, after possible initial whitespace:

     radix    input format 
     \verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"
      BIN     (0w)?[0\verb"-"1]+
      OCT     (0w)?[0\verb"-"7]+
      DEC     (0w)?[0\verb"-"9]+
      HEX     (0wx|0wX|0x|0X)?[0\verb"-"9a\verb"-"fA\verb"-"F]+

   [toInt w] returns the (signed) integer represented by bit\verb"-"pattern w.\index{toInt@\verb,toInt,!value (\verb,Word,)}
   [toIntX w] returns the (signed) integer represented by bit\verb"-"pattern w.\index{toIntX@\verb,toIntX,!value (\verb,Word,)}
   [fromInt i] returns the word representing integer i.\index{fromInt@\verb,fromInt,!value (\verb,Word,)}

   [toLargeInt w] returns the (signed) integer represented by bit\verb"-"pattern w.\index{toLargeInt@\verb,toLargeInt,!value (\verb,Word,)}
   [toLargeIntX w] returns the (signed) integer represented by bit\verb"-"pattern w.\index{toLargeIntX@\verb,toLargeIntX,!value (\verb,Word,)}
   [fromLargeInt i] returns the word representing integer i.\index{fromLargeInt@\verb,fromLargeInt,!value (\verb,Word,)}

   [toLargeWord w] returns w.\index{toLargeWord@\verb,toLargeWord,!value (\verb,Word,)}
   [toLargeWordX w] returns w.\index{toLargeWordX@\verb,toLargeWordX,!value (\verb,Word,)}
   [fromLargeWord w] returns w.\index{fromLargeWord@\verb,fromLargeWord,!value (\verb,Word,)}
\end{longprogram}
\index{Word@\verb,Word, (structure)|)}\newpage

\section*{Module Word8}
\index{Word8@\verb,Word8, (structure)|(}
\markboth{\MakeUppercase{Word8}}{\MakeUppercase{Word8}}
\addcontentsline{toc}{section}{Word8}
\begin{longprogram}
{\itshape{}Word8 \verb"-"\verb"-" SML Basis Library }

type word = word8\index{word@\verb,word,!type (\verb,Word8,)}

val wordSize   : int\index{wordSize@\verb,wordSize,!value (\verb,Word8,)}

val orb        : word * word \verb"-"\verb">" word\index{orb@\verb,orb,!value (\verb,Word8,)}
val andb       : word * word \verb"-"\verb">" word\index{andb@\verb,andb,!value (\verb,Word8,)}
val xorb       : word * word \verb"-"\verb">" word\index{xorb@\verb,xorb,!value (\verb,Word8,)}
val notb       : word \verb"-"\verb">" word\index{notb@\verb,notb,!value (\verb,Word8,)}

val \verb"<"\verb"<"         : word * Word.word \verb"-"\verb">" word\index{<<@\verb,<<,!value (\verb,Word8,)}
val \verb">"\verb">"         : word * Word.word \verb"-"\verb">" word\index{>>@\verb,>>,!value (\verb,Word8,)}
val ~\verb">"\verb">"        : word * Word.word \verb"-"\verb">" word\index{~>>@\verb,~>>,!value (\verb,Word8,)}

val +          : word * word \verb"-"\verb">" word\index{+@\verb,+,!value (\verb,Word8,)}
val \verb"-"          : word * word \verb"-"\verb">" word\index{-@\verb,-,!value (\verb,Word8,)}
val *          : word * word \verb"-"\verb">" word\index{*@\verb,*,!value (\verb,Word8,)}
val div        : word * word \verb"-"\verb">" word\index{div@\verb,div,!value (\verb,Word8,)}
val mod        : word * word \verb"-"\verb">" word\index{mod@\verb,mod,!value (\verb,Word8,)}

val \verb">"          : word * word \verb"-"\verb">" bool\index{>@\verb,>,!value (\verb,Word8,)}
val \verb"<"          : word * word \verb"-"\verb">" bool\index{<@\verb,<,!value (\verb,Word8,)}
val \verb">"=         : word * word \verb"-"\verb">" bool\index{>=@\verb,>=,!value (\verb,Word8,)}
val \verb"<"=         : word * word \verb"-"\verb">" bool\index{<=@\verb,<=,!value (\verb,Word8,)}
val compare    : word * word \verb"-"\verb">" order\index{compare@\verb,compare,!value (\verb,Word8,)}

val min        : word * word \verb"-"\verb">" word\index{min@\verb,min,!value (\verb,Word8,)}
val max        : word * word \verb"-"\verb">" word\index{max@\verb,max,!value (\verb,Word8,)}

val toString   : word \verb"-"\verb">" string\index{toString@\verb,toString,!value (\verb,Word8,)}
val fromString : string \verb"-"\verb">" word option\index{fromString@\verb,fromString,!value (\verb,Word8,)}
val scan       : StringCvt.radix \index{scan@\verb,scan,!value (\verb,Word8,)}
               \verb"-"\verb">" (char, 'a) StringCvt.reader \verb"-"\verb">" (word, 'a) StringCvt.reader
val fmt        : StringCvt.radix \verb"-"\verb">" word \verb"-"\verb">" string\index{fmt@\verb,fmt,!value (\verb,Word8,)}

val toInt      : word \verb"-"\verb">" int\index{toInt@\verb,toInt,!value (\verb,Word8,)}
val toIntX     : word \verb"-"\verb">" int            {\itshape{}with sign extension }\index{toIntX@\verb,toIntX,!value (\verb,Word8,)}
val fromInt    : int \verb"-"\verb">" word\index{fromInt@\verb,fromInt,!value (\verb,Word8,)}

val toLargeInt    : word \verb"-"\verb">" int\index{toLargeInt@\verb,toLargeInt,!value (\verb,Word8,)}
val toLargeIntX   : word \verb"-"\verb">" int         {\itshape{}with sign extension }\index{toLargeIntX@\verb,toLargeIntX,!value (\verb,Word8,)}
val fromLargeInt  : int \verb"-"\verb">" word\index{fromLargeInt@\verb,fromLargeInt,!value (\verb,Word8,)}

val toLargeWord   : word \verb"-"\verb">" Word.word\index{toLargeWord@\verb,toLargeWord,!value (\verb,Word8,)}
val toLargeWordX  : word \verb"-"\verb">" Word.word   {\itshape{}with sign extension }\index{toLargeWordX@\verb,toLargeWordX,!value (\verb,Word8,)}
val fromLargeWord : Word.word \verb"-"\verb">" word\index{fromLargeWord@\verb,fromLargeWord,!value (\verb,Word8,)}

\separatingline
   [word] is the type of 8\verb"-"bit words, or 8\verb"-"bit unsigned integers in\index{word@\verb,word,!type (\verb,Word8,)}
   the range 0..255.

   [wordSize] equals 8.\index{wordSize@\verb,wordSize,!value (\verb,Word8,)}

   [orb(w1, w2)] returns the bitwise `or' of w1 and w2.\index{orb@\verb,orb,!value (\verb,Word8,)}

   [andb(w1, w2)] returns the bitwise `and' of w1 and w2.\index{andb@\verb,andb,!value (\verb,Word8,)}

   [xorb(w1, w2)] returns the bitwise `exclusive or' or w1 and w2.\index{xorb@\verb,xorb,!value (\verb,Word8,)}

   [notb w] returns the bitwise negation of w.\index{notb@\verb,notb,!value (\verb,Word8,)}

   [\verb"<"\verb"<"(w, k)] returns the word resulting from shifting w left by k\index{<<@\verb,<<,!value (\verb,Word8,)}
   bits.  The bits shifted in are zero, so this is a logical shift.
   Consequently, the result is 0\verb"-"bits when k \verb">"= wordSize.

   [\verb">"\verb">"(w, k)] returns the word resulting from shifting w right by k\index{>>@\verb,>>,!value (\verb,Word8,)}
   bits.  The bits shifted in are zero, so this is a logical shift.
   Consequently, the result is 0\verb"-"bits when k \verb">"= wordSize.

   [~\verb">"\verb">"(w, k)] returns the word resulting from shifting w right by k\index{~>>@\verb,~>>,!value (\verb,Word8,)}
   bits.  The bits shifted in are replications of the left\verb"-"most bit:
   the `sign bit', so this is an arithmetical shift.  Consequently,
   for k \verb">"= wordSize and wordToInt w \verb">"= 0 the result is all 0\verb"-"bits, and 
   for k \verb">"= wordSize and wordToInt w \verb"<"  0 the result is all 1\verb"-"bits.

   To make \verb"<"\verb"<", \verb">"\verb">", and ~\verb">"\verb">" infix, use the declaration:
                          infix 5 \verb"<"\verb"<" \verb">"\verb">" ~\verb">"\verb">"

   [+]\index{+@\verb,+,!value (\verb,Word8,)}
   [\verb"-"]\index{-@\verb,-,!value (\verb,Word8,)}
   [*]\index{*@\verb,*,!value (\verb,Word8,)}
   [div]\index{div@\verb,div,!value (\verb,Word8,)}
   [mod] represent unsigned integer addition, subtraction,\index{mod@\verb,mod,!value (\verb,Word8,)}
   multiplication, division, and remainder, modulus 256.  The
   operations (i div j) and (i mod j) raise Div when j = 0.  Otherwise
   no exceptions are raised.

   [\verb"<"]\index{<@\verb,<,!value (\verb,Word8,)}
   [\verb"<"=]\index{<=@\verb,<=,!value (\verb,Word8,)}
   [\verb">"]\index{>@\verb,>,!value (\verb,Word8,)}
   [\verb">"=] compare words as unsigned integers.\index{>=@\verb,>=,!value (\verb,Word8,)}

   [compare(w1, w2)] returns LESS, EQUAL, or GREATER, according \index{compare@\verb,compare,!value (\verb,Word8,)}
   as w1 is less than, equal to, or greater than w2 (as unsigned integers).

   [min(w1, w2)] returns the smaller of w1 and w2 (as unsigned integers).\index{min@\verb,min,!value (\verb,Word8,)}

   [max(w1, w2)] returns the larger of w1 and w2 (as unsigned integers).\index{max@\verb,max,!value (\verb,Word8,)}

   [fmt radix w] returns a string representing w, in the radix (base)\index{fmt@\verb,fmt,!value (\verb,Word8,)}
   specified by radix.

     radix    description                     output format  
     \verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"  
      BIN     unsigned binary      (base  2)  [01]+         
      OCT     unsigned octal       (base  8)  [0\verb"-"7]+          
      DEC     unsigned decimal     (base 10)  [0\verb"-"9]+          
      HEX     unsigned hexadecimal (base 16)  [0\verb"-"9A\verb"-"F]+       

   [toString w] returns a string representing w in unsigned\index{toString@\verb,toString,!value (\verb,Word8,)}
   hexadecimal format.  Equivalent to (fmt HEX w).
   
   [fromString s] returns SOME(w) if a hexadecimal unsigned numeral\index{fromString@\verb,fromString,!value (\verb,Word8,)}
   can be scanned from a prefix of string s, ignoring any initial
   whitespace; returns NONE otherwise.  Raises Overflow if the scanned
   number cannot be represented as a word.  An unsigned hexadecimal
   numeral must have form, after possible initial whitespace:
       [0\verb"-"9a\verb"-"fA\verb"-"F]+

   [scan radix \verb"{"getc\verb"}" charsrc] attempts to scan an unsigned numeral\index{scan@\verb,scan,!value (\verb,Word8,)}
   from the character source charsrc, using the accessor getc, and
   ignoring any initial whitespace.  The radix argument specifies the
   base of the numeral (BIN, OCT, DEC, HEX).  If successful, it
   returns SOME(w, rest) where w is the value of the numeral scanned,
   and rest is the unused part of the character source.  Raises
   Overflow if the scanned number cannot be represented as a word.  A
   numeral must have form, after possible initial whitespace:

     radix    input format 
     \verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"\verb"-"
      BIN     (0w)?[0\verb"-"1]+
      OCT     (0w)?[0\verb"-"7]+
      DEC     (0w)?[0\verb"-"9]+
      HEX     (0wx|0wX|0x|0X)?[0\verb"-"9a\verb"-"fA\verb"-"F]+

   [toInt w] returns the integer in the range 0..255 represented by w.\index{toInt@\verb,toInt,!value (\verb,Word8,)}

   [toIntX w] returns the signed integer (in the range ~128..127) \index{toIntX@\verb,toIntX,!value (\verb,Word8,)}
   represented by bit\verb"-"pattern w.
   
   [fromInt i] returns the word holding the 8 least significant bits of i.\index{fromInt@\verb,fromInt,!value (\verb,Word8,)}

   [toLargeInt w] returns the integer in the range 0..255 represented by w.\index{toLargeInt@\verb,toLargeInt,!value (\verb,Word8,)}

   [toLargeIntX w] returns the signed integer (in the range ~128..127) \index{toLargeIntX@\verb,toLargeIntX,!value (\verb,Word8,)}
   represented by bit\verb"-"pattern w.
   
   [fromLargeInt i] returns the word holding the 8 least significant bits of i.\index{fromLargeInt@\verb,fromLargeInt,!value (\verb,Word8,)}

   [toLargeWord w] returns the Word.word value corresponding to w.\index{toLargeWord@\verb,toLargeWord,!value (\verb,Word8,)}

   [toLargeWordX w] returns the Word.word value corresponding to w,\index{toLargeWordX@\verb,toLargeWordX,!value (\verb,Word8,)}
   with sign extension.  That is, the 8 least significant bits of the
   result are those of w, and the remaining bits are all equal to the
   most significant bit of w: its `sign bit'.

   [fromLargeWord w] returns w modulo 256.\index{fromLargeWord@\verb,fromLargeWord,!value (\verb,Word8,)}
\end{longprogram}
\index{Word8@\verb,Word8, (structure)|)}\newpage

\section*{Module Word8Array}
\index{Word8Array@\verb,Word8Array, (structure)|(}
\markboth{\MakeUppercase{Word8Array}}{\MakeUppercase{Word8Array}}
\addcontentsline{toc}{section}{Word8Array}
\begin{longprogram}
{\itshape{}Word8Array \verb"-"\verb"-" SML Basis Library }

eqtype array\index{array@\verb,array,!type (\verb,Word8Array,)}
type elem   = Word8.word\index{elem@\verb,elem,!type (\verb,Word8Array,)}
type vector = Word8Vector.vector\index{vector@\verb,vector,!type (\verb,Word8Array,)}

val maxLen   : int\index{maxLen@\verb,maxLen,!value (\verb,Word8Array,)}

val array    : int * elem \verb"-"\verb">" array\index{array@\verb,array,!value (\verb,Word8Array,)}
val tabulate : int * (int \verb"-"\verb">" elem) \verb"-"\verb">" array\index{tabulate@\verb,tabulate,!value (\verb,Word8Array,)}
val fromList : elem list \verb"-"\verb">" array\index{fromList@\verb,fromList,!value (\verb,Word8Array,)}

val length   : array \verb"-"\verb">" int\index{length@\verb,length,!value (\verb,Word8Array,)}
val sub      : array * int \verb"-"\verb">" elem\index{sub@\verb,sub,!value (\verb,Word8Array,)}
val update   : array * int * elem \verb"-"\verb">" unit\index{update@\verb,update,!value (\verb,Word8Array,)}
val extract  : array * int * int option \verb"-"\verb">" vector\index{extract@\verb,extract,!value (\verb,Word8Array,)}

val copy     : \verb"{"src: array,  si: int, len: int option, \index{copy@\verb,copy,!value (\verb,Word8Array,)}
                dst: array, di: int\verb"}" \verb"-"\verb">" unit
val copyVec  : \verb"{"src: vector, si: int, len: int option, \index{copyVec@\verb,copyVec,!value (\verb,Word8Array,)}
                dst: array, di: int\verb"}" \verb"-"\verb">" unit

val app      : (elem \verb"-"\verb">" unit) \verb"-"\verb">" array \verb"-"\verb">" unit\index{app@\verb,app,!value (\verb,Word8Array,)}
val foldl    : (elem * 'b \verb"-"\verb">" 'b) \verb"-"\verb">" 'b \verb"-"\verb">" array \verb"-"\verb">" 'b\index{foldl@\verb,foldl,!value (\verb,Word8Array,)}
val foldr    : (elem * 'b \verb"-"\verb">" 'b) \verb"-"\verb">" 'b \verb"-"\verb">" array \verb"-"\verb">" 'b\index{foldr@\verb,foldr,!value (\verb,Word8Array,)}
val modify   : (elem \verb"-"\verb">" elem) \verb"-"\verb">" array \verb"-"\verb">" unit\index{modify@\verb,modify,!value (\verb,Word8Array,)}

val appi     : (int * elem \verb"-"\verb">" unit) \verb"-"\verb">" array * int * int option \verb"-"\verb">" unit\index{appi@\verb,appi,!value (\verb,Word8Array,)}
val foldli   : (int * elem * 'b \verb"-"\verb">" 'b) \verb"-"\verb">" 'b \verb"-"\verb">" array * int * int option \verb"-"\verb">" 'b\index{foldli@\verb,foldli,!value (\verb,Word8Array,)}
val foldri   : (int * elem * 'b \verb"-"\verb">" 'b) \verb"-"\verb">" 'b \verb"-"\verb">" array * int * int option \verb"-"\verb">" 'b\index{foldri@\verb,foldri,!value (\verb,Word8Array,)}
val modifyi  : (int * elem \verb"-"\verb">" elem) \verb"-"\verb">" array * int * int option \verb"-"\verb">" unit\index{modifyi@\verb,modifyi,!value (\verb,Word8Array,)}

\separatingline
   [array] is the type of one\verb"-"dimensional, mutable, zero\verb"-"based\index{array@\verb,array,!type (\verb,Word8Array,)}
   constant\verb"-"time\verb"-"access arrays with elements of type Word8.word, that
   is, 8\verb"-"bit words.  Arrays a1 and a2 are equal if both were created
   by the same call to a primitive (array0, array, tabulate, fromList).

   All operations are as for Array.array.
\end{longprogram}
\index{Word8Array@\verb,Word8Array, (structure)|)}\newpage

\section*{Module Word8Vector}
\index{Word8Vector@\verb,Word8Vector, (structure)|(}
\markboth{\MakeUppercase{Word8Vector}}{\MakeUppercase{Word8Vector}}
\addcontentsline{toc}{section}{Word8Vector}
\begin{longprogram}
{\itshape{}Word8Vector \verb"-"\verb"-" SML Basis Library }

eqtype vector\index{vector@\verb,vector,!type (\verb,Word8Vector,)}
type elem = Word8.word\index{elem@\verb,elem,!type (\verb,Word8Vector,)}

val maxLen   : int\index{maxLen@\verb,maxLen,!value (\verb,Word8Vector,)}

val fromList : elem list \verb"-"\verb">" vector\index{fromList@\verb,fromList,!value (\verb,Word8Vector,)}
val tabulate : int * (int \verb"-"\verb">" elem) \verb"-"\verb">" vector\index{tabulate@\verb,tabulate,!value (\verb,Word8Vector,)}

val length   : vector \verb"-"\verb">" int\index{length@\verb,length,!value (\verb,Word8Vector,)}
val sub      : vector * int \verb"-"\verb">" elem\index{sub@\verb,sub,!value (\verb,Word8Vector,)}
val extract  : vector * int * int option \verb"-"\verb">" vector\index{extract@\verb,extract,!value (\verb,Word8Vector,)}
val concat   : vector list \verb"-"\verb">" vector\index{concat@\verb,concat,!value (\verb,Word8Vector,)}

val app      : (elem \verb"-"\verb">" unit) \verb"-"\verb">" vector \verb"-"\verb">" unit\index{app@\verb,app,!value (\verb,Word8Vector,)}
val map      : (elem \verb"-"\verb">" elem) \verb"-"\verb">" vector \verb"-"\verb">" vector\index{map@\verb,map,!value (\verb,Word8Vector,)}
val foldl    : (elem * 'b \verb"-"\verb">" 'b) \verb"-"\verb">" 'b \verb"-"\verb">" vector \verb"-"\verb">" 'b\index{foldl@\verb,foldl,!value (\verb,Word8Vector,)}
val foldr    : (elem * 'b \verb"-"\verb">" 'b) \verb"-"\verb">" 'b \verb"-"\verb">" vector \verb"-"\verb">" 'b\index{foldr@\verb,foldr,!value (\verb,Word8Vector,)}

val appi     : (int * elem \verb"-"\verb">" unit) \verb"-"\verb">" vector * int * int option \verb"-"\verb">" unit\index{appi@\verb,appi,!value (\verb,Word8Vector,)}
val mapi     : (int * elem \verb"-"\verb">" elem) \verb"-"\verb">" vector * int * int option \verb"-"\verb">" vector\index{mapi@\verb,mapi,!value (\verb,Word8Vector,)}
val foldli   : (int * elem * 'b \verb"-"\verb">" 'b) \verb"-"\verb">" 'b \verb"-"\verb">" vector*int*int option \verb"-"\verb">" 'b\index{foldli@\verb,foldli,!value (\verb,Word8Vector,)}
val foldri   : (int * elem * 'b \verb"-"\verb">" 'b) \verb"-"\verb">" 'b \verb"-"\verb">" vector*int*int option \verb"-"\verb">" 'b\index{foldri@\verb,foldri,!value (\verb,Word8Vector,)}

\separatingline
   [vector] is the type of one\verb"-"dimensional, immutable, zero\verb"-"based\index{vector@\verb,vector,!type (\verb,Word8Vector,)}
   constant\verb"-"time\verb"-"access vectors with elements of type Word8.word, that
   is, 8\verb"-"bit words.  Type vector admits equality, and vectors v1 and
   v2 are equal if they have the same length and their elements are
   equal.

   All operations are as for Vector.vector.
\end{longprogram}
\index{Word8Vector@\verb,Word8Vector, (structure)|)}